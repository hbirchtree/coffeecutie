var cameraThrottle = 1.0;

//Input should only interact with the controller-object
var c_target = world.blade.physics;
var c_moveProp = new CoffeePhysicsEvent();
c_moveProp.type = PhysicsProperty.ActionApplyImpulse;
var c_vec = new Vector3Value();
c_vec.value = [0,100,0];
c_moveProp.data = [c_vec];
c_moveProp.addTarget(c_target);
c_target.modifyPhysics(c_moveProp);

function axisReact(axe,val,diff){
	switch(axe){
	case 6:{
//		val = val * cameraThrottle;
//		controller.addSpeedRight(coffeeroot.evloop.world.camera.right,[val*5,val*5,val*5]);
		c_vec.value = [val,0,0];
		c_target.modifyPhysics(c_moveProp);
		break;
	}
	case 7:{
//		val = val * cameraThrottle;
//		controller.addSpeedForward(coffeeroot.evloop.world.camera.forward,[-val*5,-val*5,-val*5]);
		c_vec.value = [0,0,val];
		c_target.modifyPhysics(c_moveProp);
		break;
	}
	case 3:{
		if(!((val<0&&diff>0)||(val>0&&diff<0))){
			controller.joystickSetRotationYaw(Math.pow(val,3)*100);
		}
		break;
	}
	case 4:{
		if(!((val<0&&diff>0)||(val>0&&diff<0))){
			controller.joystickSetRotationPitch(Math.pow(val,3)*(-100));
		}
		break;
	}
	case 5:{
		cameraThrottle = 2.0 + val;
		break;
	}
	};
}
function buttonReact(btn){
	switch(btn){
	case 0:{
		c_vec.value = [0,50,0];
		c_target.modifyPhysics(c_moveProp);
//		coffeeroot.evloop.world.wireframeMode = !coffeeroot.evloop.world.wireframeMode;
		break;
	}
	case 7:{
		renderClose();
		break;
	}
	default:{
		print("Joystick button pressed:",btn);
		break;
	}
	}
}

var js1 = renderer.getJoystickDevice(0);

js1.axisMoved.connect(axisReact);
js1.buttonPressed.connect(buttonReact);
