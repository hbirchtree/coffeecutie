//Load CoffeeStandardObject

//TODO : add the other shapes, both here and in code
function _phys_translate_string_shape(str){
	switch(str){
		case "static_plane":{
			return PhysicsProperty.StaticPlaneShape;
		}
		case "sphere":{
			return PhysicsProperty.SphereShape;
		}
		case "box":{
			return PhysicsProperty.BoxShape;
		}
		case "cylinder":{
			return PhysicsProperty.CylinderShape;
		}
		case "capsule":{
			return PhysicsProperty.CapsuleShape;
		}
		case "cone":{
			return PhysicsProperty.ConeShape;
		}
	}
	return PhysicsProperty.NullShape;
}

function _load_object_physics(src,parent,world){
	var phys = new PhysicsObject(parent);
	var desc = new CoffeePhysicsEvent(phys);
	desc.dispose = true;
	desc.intent = PhysicsProperty.CreateIntent;

	var scalar = new ScalarValue();
	var vec3 = new Vector3Value();
	var quat = new QuatValue();

	for(p in src){
		switch(p){
			case "shape":{
				desc.setInt(PhysicsProperty.ShapeProperty,_phys_translate_string_shape(src[p]));
				break;
			}
			case "position":{
				vec3.value = src[p]
				desc.setVector3(PhysicsProperty.PositionProperty,vec3);
				break;
			}
			case "scale":{
				vec3.value = src[p]
				desc.setVector3(PhysicsProperty.ScaleProperty,vec3);
				break;
			}
			case "rotation":{
				quat.value = src[p]
				desc.setQuaternion(PhysicsProperty.OrientationProperty,quat);
				break;
			}
			case "angular-velocity":{
				vec3.value = src[p]
				desc.setVector3(PhysicsProperty.AngularVelocityProperty,vec3);
				break;
			}
			case "inertia":{
				vec3.value = src[p]
				desc.setVector3(PhysicsProperty.LocalInertiaProperty,vec3);
				break;
			}
			case "linear-factory":{
				vec3.value = src[p]
				desc.setVector3(PhysicsProperty.LinearFactorProperty,vec3);
				break;
			}
			case "velocity":{
				vec3.value = src[p]
				desc.setVector3(PhysicsProperty.VelocityProperty,vec3);
				break;
			}
			case "friction":{
				scalar.value = src[p]
				desc.setScalar(PhysicsProperty.FrictionProperty,scalar);
				break;
			}
			case "mass":{
				scalar.value = src[p]
				desc.setScalar(PhysicsProperty.MassProperty,scalar);
				break;
			}
			case "restitution":{
				scalar.value = src[p]
				desc.setScalar(PhysicsProperty.RestitutionProperty,scalar);
				break;
			}
			case "normal":{
				vec3.value = src[p]
				desc.setVector3(PhysicsProperty.OrientationProperty,vec3);
				break;
			}
			case "plane-constant":{
				scalar.value = src[p];
				desc.setScalar(PhysicsProperty.PlaneConstantProperty,scalar);
			}
		}
	}
	desc.targets = [phys];
	world.handlePhysEvent(desc);
	return phys;
}

function _load_object_standard(src,parent,assetSource){
	var obj = new CoffeeStandardObject(parent);
	for(p in src){
		switch(p){
			case "id":{
				obj.objectName = src[p];
				break;
			}
			case "model.id":{
				var model = assetSource.getModel(src[p]);
				obj.mesh = model.mesh;
				obj.material = model.material;
				break;
			}
			case "model.position":{
				obj.position.value = src[p];
				break;
			}
			case "model.scale":{
				obj.scale.value = src[p];
				break;
			}
			case "model.rotation":{
				obj.rotation.value = src[p];
				break;
			}
			case "shader.id":{
				obj.shader = assetSource.shaders[src[p]];
				break;
			}
			case "physics":{
				obj.physics = _load_object_physics(src[p],obj,parent);
				break;
			}
		}
	}

	if(obj.physics!=null){
		obj.position.bindValue(obj.physics.position);
		obj.rotation.bindValue(obj.physics.rotation);
	}

	return obj;
}
