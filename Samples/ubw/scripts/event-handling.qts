
//////////////
//
// This file contains the scripting necessary to control the camera
//  as well as close the window. This is put together as
//  event-handling.
// If we want true low-latency input, we would rather write a QObject to handle the task.
//
//////////////

function axisReact(axe,val,diff){
	switch(axe){
	case 1:{
		controller.addSpeedForward(world.camera.forward,[-val*5,-val*5,-val*5]);
		break;
	}
	case 0:{
		controller.addSpeedRight(world.camera.right,[val*5,val*5,val*5]);
		break;
	}
	case 3:{
		if(!((val<0&&diff>0)||(val>0&&diff<0))){
			controller.joystickSetRotationYaw(Math.pow(val,3)*100);
		}
		break;
	}
	case 4:{
		if(!((val<0&&diff>0)||(val>0&&diff<0))){
			controller.joystickSetRotationPitch(Math.pow(val,3)*(-100));
		}
		break;
	}
	};
}
function buttonReact(btn){
	switch(btn){
	case 0:{
		world.wireframeMode = !world.wireframeMode;
		break;
	}
	}
}

function inputReact(event){
	switch(event.type){
	case CoffeeInputEventType.Mouse:{
		if(renderer.mouseGrabbing){
			renderer.setMousePos(0,0);
			controller.mouseSetRotation(event.pos.x,event.pos.y);
		}
		if(event.qtype==QEvent.MouseButtonPress){
			if(event.mouseButtons&Qt.LeftButton){
				renderer.mouseGrabbing = true;
			}else if(event.mouseButtons&Qt.RightButton){
				renderer.mouseGrabbing = false;
			}
		}
		break;
	}
	case CoffeeInputEventType.Keyboard:{
		if(event.qtype==QEvent.KeyPress){
			switch(event.key){
			case Qt.Key_J:{
				renderer.jsdev.enabled = !renderer.jsdev.enabled;
				break;
			}
			case Qt.Key_W:{
				controller.addSpeedForward(world.camera.forward,[6,6,6]);
				break;
			}
			case Qt.Key_A:{
				controller.addSpeedRight(world.camera.right,[-6,-6,-6]);
				break;
			}
			case Qt.Key_S:{
				controller.addSpeedForward(world.camera.forward,[-6,-6,-6]);
				break;
			}
			case Qt.Key_D:{
				controller.addSpeedRight(world.camera.right,[6,6,6]);
				break;
			}
			}
		} else if(event.qtype == QEvent.KeyRelease){
			switch(event.key){
			case Qt.Key_Escape:{
				renderer.requestWindowClose();
				break;
			}
			}
		}
		break;
	}
	}
	event.accept();
}

function renderClose(){
	renderer.requestWindowClose();
}

renderer.jsdev.axisMoved.connect(axisReact);
renderer.jsdev.buttonPressed.connect(buttonReact);
renderer.inputEvent.connect(inputReact);
renderer.winClose.connect(renderClose);
