var world = coffeeroot.evloop.world1;
var controller = coffeeroot.evloop.cameracontrol;

world.lights[0].position.bind(world.camera.position)

function objInit(target){
	var obj = target;
	var mat = obj.material;

	//Material textures
	for(var i=0;i<mat.textureTypes.length;i++){
		var t = mat.textureTypes[i];
		switch(t){
		case CoffeeTexture.CoffeeTexture_Ambient:
			obj.setTexture("mtl.ambientSampler",mat.getTexture(t));
			break;
		case CoffeeTexture.CoffeeTexture_Heightmap:
			obj.setTexture("mtl.heightmapSampler",mat.getTexture(t));
			break;
		case CoffeeTexture.CoffeeTexture_Emissive:
			obj.setTexture("mtl.emissiveSampler",mat.getTexture(t));
			break;
		case CoffeeTexture.CoffeeTexture_Displacement:
			obj.setTexture("mtl.displacementSampler",mat.getTexture(t));
			break;
		case CoffeeTexture.CoffeeTexture_Lightmap:
			obj.setTexture("mtl.lightmapSampler",mat.getTexture(t));
			break;
		case CoffeeTexture.CoffeeTexture_Reflection:
			obj.setTexture("mtl.reflectivitySampler",mat.getTexture(t));
			break;
		case CoffeeTexture.CoffeeTexture_Diffusion:
			obj.setTexture("mtl.diffuseSampler",mat.getTexture(t));
            break;
		case CoffeeTexture.CoffeeTexture_Bumpmap:
			obj.setTexture("mtl.bumpSampler",mat.getTexture(t));
			break;
		case CoffeeTexture.CoffeeTexture_Specular:
			obj.setTexture("mtl.specularSampler",mat.getTexture(t));
			break;
		case CoffeeTexture.CoffeeTexture_Highlight:
			obj.setTexture("mtl.highlightSampler",mat.getTexture(t));
			break;
		case CoffeeTexture.CoffeeTexture_Transparency:
            obj.setTexture("mtl.transparencySampler",mat.getTexture(t));
			break;
		default:
			break;
        }
	}

	//Material
	obj.setUniform("mtl.opacity",mat.opacityVariant,false);
	obj.setUniform("mtl.shininess",mat.shininessVariant,false);
	obj.setUniform("mtl.shininessStrength",mat.shininessStrengthVariant,false);
	obj.setUniform("mtl.transparencyValue",mat.transparency,false);
	obj.setUniform("mtl.colorMultiplier",mat.colorMultiplier,false);
	obj.setUniform("mtl.specularColor",mat.specularColor,false);
	obj.setUniform("mtl.ambientColor",mat.ambientColor,false);
	obj.setUniform("mtl.diffuseColor",mat.diffuseColor,false);
	obj.setUniform("mtl.emissiveColor",mat.emissiveColor,false);
	obj.setUniform("mtl.refraction",mat.refractionVariant,false);
	obj.setUniform("mtl.reflectivity",mat.reflectivityVariant,false);

	//Camera
	obj.setUniform("camera",world.camera.matrix,false);
	obj.setUniform("cameraPosition",world.camera.positionVariant,false);

	//Lights
	obj.setUniform("light.position",world.lights[0].positionVariant,false);
	obj.setUniform("light.intensities",world.lights[0].colorVariant,false);
	obj.setUniform("light.attenuation",world.lights[0].attenuationVariant,false);
	obj.setUniform("light.ambientCoefficient",world.lights[0].ambientCoefficientVariant,false);

	//Fog
	obj.setUniform("fogParams.fDensity",world.fogDensityVariant,false);
	obj.setUniform("fogParams.fColor",world.fogColorVariant,false);

	//Model
	obj.setUniform("model",obj.matrix,false);

	if(obj.objectName == "gear"){
		obj.mesh.useInstancing = true;
	}
}
function axisReact(axe,val,diff){
	switch(axe){
	case 1:{
		controller.addSpeedForward(world.camera.forward,[-val*5,-val*5,-val*5]);
		break;
	}
	case 0:{
		controller.addSpeedRight(world.camera.right,[val*5,val*5,val*5]);
		break;
	}
	case 3:{
		if(!((val<0&&diff>0)||(val>0&&diff<0))){
			controller.joystickSetRotationYaw(Math.pow(val,3)*100);
		}
		break;
	}
	case 4:{
		if(!((val<0&&diff>0)||(val>0&&diff<0))){
			controller.joystickSetRotationPitch(Math.pow(val,3)*(-100));
		}
		break;
	}
	};
}
function buttonReact(btn){
	switch(btn){
	case 0:{
		world.wireframeMode = !world.wireframeMode;
		break;
	}
	}
}

var evcatcher;

function inputReact(event){
	evcatcher = event;
	switch(event.type){
	case CoffeeInputEventType.Mouse:{
		if(renderer.mouseGrabbing){
			renderer.setMousePos(0,0);
			controller.mouseSetRotation(event.pos.x,event.pos.y);
		}
		if(event.qtype==QEvent.MouseButtonPress){
			if(event.mouseButtons&Qt.LeftButton){
				renderer.mouseGrabbing = true;
			}else if(event.mouseButtons&Qt.RightButton){
				renderer.mouseGrabbing = false;
			}
		}
		break;
	}
	case CoffeeInputEventType.Keyboard:{
		if(event.qtype==QEvent.KeyPress){
			switch(event.key){
			case Qt.Key_J:{
				renderer.jsdev.enabled = !renderer.jsdev.enabled;
				break;
			}
			case Qt.Key_W:{
				controller.addSpeedForward(world.camera.forward,[6,6,6]);
				break;
			}
			case Qt.Key_A:{
				controller.addSpeedRight(world.camera.right,[-6,-6,-6]);
				break;
			}
			case Qt.Key_S:{
				controller.addSpeedForward(world.camera.forward,[-6,-6,-6]);
				break;
			}
			case Qt.Key_D:{
				controller.addSpeedRight(world.camera.right,[6,6,6]);
				break;
			}
			}
		} else if(event.qtype == QEvent.KeyRelease){
			switch(event.key){
			case Qt.Key_Escape:{
				renderer.requestWindowClose();
				break;
			}
			}
		}
		break;
	}
	}
	event.accept();
}

function renderClose(){
	renderer.requestWindowClose();
}

renderer.jsdev.axisMoved.connect(axisReact);
renderer.jsdev.buttonPressed.connect(buttonReact);
renderer.inputEvent.connect(inputReact);
renderer.winClose.connect(renderClose);

{
	var objects = [world.gear, world.plane, world.blade, world.blade2];

	for(var i=0;i<objects.length;i++){
		objInit(objects[i]);
	}
}

/*
for(i=0;i<5;i++){
	world.gear.mesh.instances.createInstance();
}

var objStack = new Array();

for(i=0;i<6;i++){
	var test = new PhysicsDescriptor();
	test.setShape(1);
	test.mass = 1;
	var test2 = new PhysicsObject();
	test2.setDescr(test);

	world.injectPhysicsObject(test2);
	world.gear.mesh.instances.instanceObjects[i].bindObject(test2);

	objStack.push(test);
	objStack.push(test2);
}

var target = world.gear.mesh.instances.instanceObjects[0].physics;
var testProp = new CoffeePhysicsEvent();
testProp.type = PhysicsProperty.ActionApplyForce;
var vec = new VectorVariant();
vec.vec3 = [0,100,0];
testProp.data = vec;
testProp.target = target;
target.modifyPhysics(testProp);
*/


print("Done!");
