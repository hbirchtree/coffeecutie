#pragma once

#include "groups.h"

namespace gl::ext {

#ifdef GL_AMD_blend_minmax_factor
namespace amd_blend_minmax_factor {
constexpr u32 factor_min_amd = 0x901C;
constexpr u32 factor_max_amd = 0x901D;
} // amd_blend_minmax_factor
#endif // GL_AMD_blend_minmax_factor
#ifdef GL_AMD_compressed_3DC_texture
namespace amd_compressed_3dc_texture {
constexpr u32 3dc_x_amd = 0x87F9;
constexpr u32 3dc_xy_amd = 0x87FA;
} // amd_compressed_3dc_texture
#endif // GL_AMD_compressed_3DC_texture
#ifdef GL_AMD_compressed_ATC_texture
namespace amd_compressed_atc_texture {
constexpr u32 atc_rgba_interpolated_alpha_amd = 0x87EE;
constexpr u32 atc_rgb_amd = 0x8C92;
constexpr u32 atc_rgba_explicit_alpha_amd = 0x8C93;
} // amd_compressed_atc_texture
#endif // GL_AMD_compressed_ATC_texture
#ifdef GL_AMD_conservative_depth
namespace amd_conservative_depth {
} // amd_conservative_depth
#endif // GL_AMD_conservative_depth
#ifdef GL_AMD_debug_output
namespace amd_debug_output {
constexpr u32 max_debug_message_length_amd = 0x9143;
constexpr u32 max_debug_logged_messages_amd = 0x9144;
constexpr u32 debug_logged_messages_amd = 0x9145;
constexpr u32 debug_severity_high_amd = 0x9146;
constexpr u32 debug_severity_medium_amd = 0x9147;
constexpr u32 debug_severity_low_amd = 0x9148;
constexpr u32 debug_category_api_error_amd = 0x9149;
constexpr u32 debug_category_window_system_amd = 0x914A;
constexpr u32 debug_category_deprecation_amd = 0x914B;
constexpr u32 debug_category_undefined_behavior_amd = 0x914C;
constexpr u32 debug_category_performance_amd = 0x914D;
constexpr u32 debug_category_shader_compiler_amd = 0x914E;
constexpr u32 debug_category_application_amd = 0x914F;
constexpr u32 debug_category_other_amd = 0x9150;
template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void debug_message_callback_amd(GLDEBUGPROCAMD callback, span_byte userParam)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDebugMessageCallbackAMD)
                Throw(undefined_behavior(
                    "unloaded function DebugMessageCallbackAMD"));
    }
    glDebugMessageCallbackAMD(callback, reinterpret_cast<void *>(userParam.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void debug_message_enable_amd(GLenum category, groups::debug_severity severity, span_const_u32 const& ids, bool enabled)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDebugMessageEnableAMD)
                Throw(undefined_behavior(
                    "unloaded function DebugMessageEnableAMD"));
    }
    glDebugMessageEnableAMD(category, static_cast<GLenum>(severity), ids.size(), reinterpret_cast<const GLuint *>(ids.data()), enabled);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void debug_message_insert_amd(GLenum category, groups::debug_severity severity, u32 id, std::string_view const& buf)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDebugMessageInsertAMD)
                Throw(undefined_behavior(
                    "unloaded function DebugMessageInsertAMD"));
    }
    glDebugMessageInsertAMD(category, static_cast<GLenum>(severity), id, buf.size(), buf.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLchar,
    class span_GLenum,
    class span_i32,
    class span_u32
>
requires (
    semantic::concepts::Span<span_GLenum> &&
    std::is_same_v<std::decay_t<typename span_GLenum::value_type>, GLenum> &&
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32> &&
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32> &&
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE GLuint get_debug_message_log_amd(span_GLenum categories, span_u32 severities, span_u32 ids, span_i32 lengths, span_GLchar message)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetDebugMessageLogAMD)
                Throw(undefined_behavior(
                    "unloaded function GetDebugMessageLogAMD"));
    }
    auto out = glGetDebugMessageLogAMD(categories.size(), message.size(), reinterpret_cast<GLenum *>(categories.data()), reinterpret_cast<GLuint *>(severities.data()), reinterpret_cast<GLuint *>(ids.data()), reinterpret_cast<GLsizei *>(lengths.data()), message.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // amd_debug_output
#endif // GL_AMD_debug_output
#ifdef GL_AMD_depth_clamp_separate
namespace amd_depth_clamp_separate {
constexpr u32 depth_clamp_near_amd = 0x901E;
constexpr u32 depth_clamp_far_amd = 0x901F;
} // amd_depth_clamp_separate
#endif // GL_AMD_depth_clamp_separate
#ifdef GL_AMD_draw_buffers_blend
namespace amd_draw_buffers_blend {
STATICINLINE void blend_equation_indexed_amd(u32 buf, groups::blend_equation_mode_ext mode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendEquationIndexedAMD)
                Throw(undefined_behavior(
                    "unloaded function BlendEquationIndexedAMD"));
    }
    glBlendEquationIndexedAMD(buf, static_cast<GLenum>(mode));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void blend_equation_separate_indexed_amd(u32 buf, groups::blend_equation_mode_ext modeRGB, groups::blend_equation_mode_ext modeAlpha)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendEquationSeparateIndexedAMD)
                Throw(undefined_behavior(
                    "unloaded function BlendEquationSeparateIndexedAMD"));
    }
    glBlendEquationSeparateIndexedAMD(buf, static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void blend_func_indexed_amd(u32 buf, GLenum src, GLenum dst)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendFuncIndexedAMD)
                Throw(undefined_behavior(
                    "unloaded function BlendFuncIndexedAMD"));
    }
    glBlendFuncIndexedAMD(buf, src, dst);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void blend_func_separate_indexed_amd(u32 buf, groups::blending_factor srcRGB, groups::blending_factor dstRGB, groups::blending_factor srcAlpha, groups::blending_factor dstAlpha)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendFuncSeparateIndexedAMD)
                Throw(undefined_behavior(
                    "unloaded function BlendFuncSeparateIndexedAMD"));
    }
    glBlendFuncSeparateIndexedAMD(buf, static_cast<GLenum>(srcRGB), static_cast<GLenum>(dstRGB), static_cast<GLenum>(srcAlpha), static_cast<GLenum>(dstAlpha));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // amd_draw_buffers_blend
#endif // GL_AMD_draw_buffers_blend
#ifdef GL_AMD_framebuffer_multisample_advanced
namespace amd_framebuffer_multisample_advanced {
constexpr u32 renderbuffer_storage_samples_amd = 0x91B2;
constexpr u32 max_color_framebuffer_samples_amd = 0x91B3;
constexpr u32 max_color_framebuffer_storage_samples_amd = 0x91B4;
constexpr u32 max_depth_stencil_framebuffer_samples_amd = 0x91B5;
constexpr u32 num_supported_multisample_modes_amd = 0x91B6;
constexpr u32 supported_multisample_modes_amd = 0x91B7;
template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void named_renderbuffer_storage_multisample_advanced_amd(u32 renderbuffer, i32 samples, i32 storageSamples, groups::internal_format internalformat, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedRenderbufferStorageMultisampleAdvancedAMD)
                Throw(undefined_behavior(
                    "unloaded function NamedRenderbufferStorageMultisampleAdvancedAMD"));
        glIsRenderbuffer(renderbuffer);
    }
    glNamedRenderbufferStorageMultisampleAdvancedAMD(renderbuffer, samples, storageSamples, static_cast<GLenum>(internalformat), width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void renderbuffer_storage_multisample_advanced_amd(groups::renderbuffer_target target, i32 samples, i32 storageSamples, groups::internal_format internalformat, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glRenderbufferStorageMultisampleAdvancedAMD)
                Throw(undefined_behavior(
                    "unloaded function RenderbufferStorageMultisampleAdvancedAMD"));
    }
    glRenderbufferStorageMultisampleAdvancedAMD(static_cast<GLenum>(target), samples, storageSamples, static_cast<GLenum>(internalformat), width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // amd_framebuffer_multisample_advanced
#endif // GL_AMD_framebuffer_multisample_advanced
#ifdef GL_AMD_framebuffer_sample_positions
namespace amd_framebuffer_sample_positions {
constexpr u32 all_pixels_amd = 0xFFFFFFFF;
constexpr u32 subsample_distance_amd = 0x883F;
constexpr u32 pixels_per_sample_pattern_x_amd = 0x91AE;
constexpr u32 pixels_per_sample_pattern_y_amd = 0x91AF;
template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void framebuffer_sample_positionsfv_amd(groups::framebuffer_target target, u32 numsamples, u32 pixelindex, span_const_f32 const& values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferSamplePositionsfvAMD)
                Throw(undefined_behavior(
                    "unloaded function FramebufferSamplePositionsfvAMD"));
    }
    glFramebufferSamplePositionsfvAMD(static_cast<GLenum>(target), numsamples, pixelindex, reinterpret_cast<const GLfloat *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_framebuffer_parameterfv_amd(groups::framebuffer_target target, groups::framebuffer_attachment_parameter_name pname, u32 numsamples, u32 pixelindex, i32 size, span_f32 values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetFramebufferParameterfvAMD)
                Throw(undefined_behavior(
                    "unloaded function GetFramebufferParameterfvAMD"));
    }
    glGetFramebufferParameterfvAMD(static_cast<GLenum>(target), static_cast<GLenum>(pname), numsamples, pixelindex, size, reinterpret_cast<GLfloat *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_named_framebuffer_parameterfv_amd(u32 framebuffer, GLenum pname, u32 numsamples, u32 pixelindex, i32 size, span_f32 values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetNamedFramebufferParameterfvAMD)
                Throw(undefined_behavior(
                    "unloaded function GetNamedFramebufferParameterfvAMD"));
        glIsFramebuffer(framebuffer);
    }
    glGetNamedFramebufferParameterfvAMD(framebuffer, pname, numsamples, pixelindex, size, reinterpret_cast<GLfloat *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void named_framebuffer_sample_positionsfv_amd(u32 framebuffer, u32 numsamples, u32 pixelindex, span_const_f32 const& values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedFramebufferSamplePositionsfvAMD)
                Throw(undefined_behavior(
                    "unloaded function NamedFramebufferSamplePositionsfvAMD"));
        glIsFramebuffer(framebuffer);
    }
    glNamedFramebufferSamplePositionsfvAMD(framebuffer, numsamples, pixelindex, reinterpret_cast<const GLfloat *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // amd_framebuffer_sample_positions
#endif // GL_AMD_framebuffer_sample_positions
#ifdef GL_AMD_gcn_shader
namespace amd_gcn_shader {
} // amd_gcn_shader
#endif // GL_AMD_gcn_shader
#ifdef GL_AMD_gpu_shader_half_float
namespace amd_gpu_shader_half_float {
constexpr u32 float16_nv = 0x8FF8;
constexpr u32 float16_vec2_nv = 0x8FF9;
constexpr u32 float16_vec3_nv = 0x8FFA;
constexpr u32 float16_vec4_nv = 0x8FFB;
constexpr u32 float16_mat2_amd = 0x91C5;
constexpr u32 float16_mat3_amd = 0x91C6;
constexpr u32 float16_mat4_amd = 0x91C7;
constexpr u32 float16_mat2x3_amd = 0x91C8;
constexpr u32 float16_mat2x4_amd = 0x91C9;
constexpr u32 float16_mat3x2_amd = 0x91CA;
constexpr u32 float16_mat3x4_amd = 0x91CB;
constexpr u32 float16_mat4x2_amd = 0x91CC;
constexpr u32 float16_mat4x3_amd = 0x91CD;
} // amd_gpu_shader_half_float
#endif // GL_AMD_gpu_shader_half_float
#ifdef GL_AMD_gpu_shader_int16
namespace amd_gpu_shader_int16 {
} // amd_gpu_shader_int16
#endif // GL_AMD_gpu_shader_int16
#ifdef GL_AMD_gpu_shader_int64
namespace amd_gpu_shader_int64 {
constexpr u32 int64_nv = 0x140E;
constexpr u32 unsigned_int64_nv = 0x140F;
constexpr u32 int8_nv = 0x8FE0;
constexpr u32 int8_vec2_nv = 0x8FE1;
constexpr u32 int8_vec3_nv = 0x8FE2;
constexpr u32 int8_vec4_nv = 0x8FE3;
constexpr u32 int16_nv = 0x8FE4;
constexpr u32 int16_vec2_nv = 0x8FE5;
constexpr u32 int16_vec3_nv = 0x8FE6;
constexpr u32 int16_vec4_nv = 0x8FE7;
constexpr u32 int64_vec2_nv = 0x8FE9;
constexpr u32 int64_vec3_nv = 0x8FEA;
constexpr u32 int64_vec4_nv = 0x8FEB;
constexpr u32 unsigned_int8_nv = 0x8FEC;
constexpr u32 unsigned_int8_vec2_nv = 0x8FED;
constexpr u32 unsigned_int8_vec3_nv = 0x8FEE;
constexpr u32 unsigned_int8_vec4_nv = 0x8FEF;
constexpr u32 unsigned_int16_nv = 0x8FF0;
constexpr u32 unsigned_int16_vec2_nv = 0x8FF1;
constexpr u32 unsigned_int16_vec3_nv = 0x8FF2;
constexpr u32 unsigned_int16_vec4_nv = 0x8FF3;
constexpr u32 unsigned_int64_vec2_nv = 0x8FF5;
constexpr u32 unsigned_int64_vec3_nv = 0x8FF6;
constexpr u32 unsigned_int64_vec4_nv = 0x8FF7;
constexpr u32 float16_nv = 0x8FF8;
constexpr u32 float16_vec2_nv = 0x8FF9;
constexpr u32 float16_vec3_nv = 0x8FFA;
constexpr u32 float16_vec4_nv = 0x8FFB;
template<
    class span_GLint64EXT
>
requires (
    semantic::concepts::Span<span_GLint64EXT> &&
    std::is_same_v<std::decay_t<typename span_GLint64EXT::value_type>, GLint64EXT>)
STATICINLINE void get_uniformi64v_nv(u32 program, i32 location, span_GLint64EXT params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetUniformi64vNV)
                Throw(undefined_behavior(
                    "unloaded function GetUniformi64vNV"));
        glIsProgram(program);
    }
    glGetUniformi64vNV(program, location, reinterpret_cast<GLint64EXT *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE void get_uniformui64v_nv(u32 program, i32 location, span_GLuint64EXT params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetUniformui64vNV)
                Throw(undefined_behavior(
                    "unloaded function GetUniformui64vNV"));
        glIsProgram(program);
    }
    glGetUniformui64vNV(program, location, reinterpret_cast<GLuint64EXT *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void uniform(i32 location, GLint64EXT x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1i64NV)
                Throw(undefined_behavior(
                    "unloaded function Uniform1i64NV"));
    }
    glUniform1i64NV(location, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_GLint64EXT> &&
    std::is_same_v<std::decay_t<typename span_const_GLint64EXT::value_type>, GLint64EXT>)
STATICINLINE void uniform(i32 location, i32 count, span_const_GLint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1i64vNV)
                Throw(undefined_behavior(
                    "unloaded function Uniform1i64vNV"));
    }
    glUniform1i64vNV(location, count, reinterpret_cast<const GLint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void uniform(i32 location, GLuint64EXT x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1ui64NV)
                Throw(undefined_behavior(
                    "unloaded function Uniform1ui64NV"));
    }
    glUniform1ui64NV(location, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_const_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE void uniform(i32 location, i32 count, span_const_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function Uniform1ui64vNV"));
    }
    glUniform1ui64vNV(location, count, reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_GLint64EXT
>
requires (
    semantic::concepts::Vector<vec_2_GLint64EXT, GLint64EXT, 2>)
STATICINLINE void uniform(i32 location, vec_2_GLint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2i64NV)
                Throw(undefined_behavior(
                    "unloaded function Uniform2i64NV"));
    }
    glUniform2i64NV(location, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_2_GLint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_2_GLint64EXT::value_type, GLint64EXT, 2>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_2_GLint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2i64vNV)
                Throw(undefined_behavior(
                    "unloaded function Uniform2i64vNV"));
    }
    glUniform2i64vNV(location, count, reinterpret_cast<const GLint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_GLuint64EXT
>
requires (
    semantic::concepts::Vector<vec_2_GLuint64EXT, GLuint64EXT, 2>)
STATICINLINE void uniform(i32 location, vec_2_GLuint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2ui64NV)
                Throw(undefined_behavior(
                    "unloaded function Uniform2ui64NV"));
    }
    glUniform2ui64NV(location, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_2_GLuint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_2_GLuint64EXT::value_type, GLuint64EXT, 2>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_2_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function Uniform2ui64vNV"));
    }
    glUniform2ui64vNV(location, count, reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLint64EXT
>
requires (
    semantic::concepts::Vector<vec_3_GLint64EXT, GLint64EXT, 3>)
STATICINLINE void uniform(i32 location, vec_3_GLint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3i64NV)
                Throw(undefined_behavior(
                    "unloaded function Uniform3i64NV"));
    }
    glUniform3i64NV(location, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_3_GLint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_3_GLint64EXT::value_type, GLint64EXT, 3>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_3_GLint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3i64vNV)
                Throw(undefined_behavior(
                    "unloaded function Uniform3i64vNV"));
    }
    glUniform3i64vNV(location, count, reinterpret_cast<const GLint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLuint64EXT
>
requires (
    semantic::concepts::Vector<vec_3_GLuint64EXT, GLuint64EXT, 3>)
STATICINLINE void uniform(i32 location, vec_3_GLuint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3ui64NV)
                Throw(undefined_behavior(
                    "unloaded function Uniform3ui64NV"));
    }
    glUniform3ui64NV(location, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_3_GLuint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_3_GLuint64EXT::value_type, GLuint64EXT, 3>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_3_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function Uniform3ui64vNV"));
    }
    glUniform3ui64vNV(location, count, reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLint64EXT
>
requires (
    semantic::concepts::Vector<vec_4_GLint64EXT, GLint64EXT, 4>)
STATICINLINE void uniform(i32 location, vec_4_GLint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4i64NV)
                Throw(undefined_behavior(
                    "unloaded function Uniform4i64NV"));
    }
    glUniform4i64NV(location, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_4_GLint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_4_GLint64EXT::value_type, GLint64EXT, 4>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_4_GLint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4i64vNV)
                Throw(undefined_behavior(
                    "unloaded function Uniform4i64vNV"));
    }
    glUniform4i64vNV(location, count, reinterpret_cast<const GLint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLuint64EXT
>
requires (
    semantic::concepts::Vector<vec_4_GLuint64EXT, GLuint64EXT, 4>)
STATICINLINE void uniform(i32 location, vec_4_GLuint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4ui64NV)
                Throw(undefined_behavior(
                    "unloaded function Uniform4ui64NV"));
    }
    glUniform4ui64NV(location, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_4_GLuint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_4_GLuint64EXT::value_type, GLuint64EXT, 4>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_4_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function Uniform4ui64vNV"));
    }
    glUniform4ui64vNV(location, count, reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void program_uniform(u32 program, i32 location, GLint64EXT x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1i64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1i64NV"));
        glIsProgram(program);
    }
    glProgramUniform1i64NV(program, location, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_GLint64EXT> &&
    std::is_same_v<std::decay_t<typename span_const_GLint64EXT::value_type>, GLint64EXT>)
STATICINLINE void program_uniform(u32 program, i32 location, span_const_GLint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1i64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1i64vNV"));
        glIsProgram(program);
    }
    glProgramUniform1i64vNV(program, location, value.size(), reinterpret_cast<const GLint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void program_uniform(u32 program, i32 location, GLuint64EXT x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1ui64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1ui64NV"));
        glIsProgram(program);
    }
    glProgramUniform1ui64NV(program, location, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_const_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE void program_uniform(u32 program, i32 location, span_const_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1ui64vNV"));
        glIsProgram(program);
    }
    glProgramUniform1ui64vNV(program, location, value.size(), reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_GLint64EXT
>
requires (
    semantic::concepts::Vector<vec_2_GLint64EXT, GLint64EXT, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_2_GLint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2i64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2i64NV"));
        glIsProgram(program);
    }
    glProgramUniform2i64NV(program, location, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_2_GLint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_2_GLint64EXT::value_type, GLint64EXT, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_2_GLint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2i64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2i64vNV"));
        glIsProgram(program);
    }
    glProgramUniform2i64vNV(program, location, count, reinterpret_cast<const GLint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_GLuint64EXT
>
requires (
    semantic::concepts::Vector<vec_2_GLuint64EXT, GLuint64EXT, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_2_GLuint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2ui64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2ui64NV"));
        glIsProgram(program);
    }
    glProgramUniform2ui64NV(program, location, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_2_GLuint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_2_GLuint64EXT::value_type, GLuint64EXT, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_2_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2ui64vNV"));
        glIsProgram(program);
    }
    glProgramUniform2ui64vNV(program, location, count, reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLint64EXT
>
requires (
    semantic::concepts::Vector<vec_3_GLint64EXT, GLint64EXT, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_3_GLint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3i64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3i64NV"));
        glIsProgram(program);
    }
    glProgramUniform3i64NV(program, location, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_3_GLint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_3_GLint64EXT::value_type, GLint64EXT, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_3_GLint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3i64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3i64vNV"));
        glIsProgram(program);
    }
    glProgramUniform3i64vNV(program, location, count, reinterpret_cast<const GLint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLuint64EXT
>
requires (
    semantic::concepts::Vector<vec_3_GLuint64EXT, GLuint64EXT, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_3_GLuint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3ui64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3ui64NV"));
        glIsProgram(program);
    }
    glProgramUniform3ui64NV(program, location, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_3_GLuint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_3_GLuint64EXT::value_type, GLuint64EXT, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_3_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3ui64vNV"));
        glIsProgram(program);
    }
    glProgramUniform3ui64vNV(program, location, count, reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLint64EXT
>
requires (
    semantic::concepts::Vector<vec_4_GLint64EXT, GLint64EXT, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_4_GLint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4i64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4i64NV"));
        glIsProgram(program);
    }
    glProgramUniform4i64NV(program, location, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_4_GLint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_4_GLint64EXT::value_type, GLint64EXT, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_4_GLint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4i64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4i64vNV"));
        glIsProgram(program);
    }
    glProgramUniform4i64vNV(program, location, count, reinterpret_cast<const GLint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLuint64EXT
>
requires (
    semantic::concepts::Vector<vec_4_GLuint64EXT, GLuint64EXT, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_4_GLuint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4ui64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4ui64NV"));
        glIsProgram(program);
    }
    glProgramUniform4ui64NV(program, location, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_4_GLuint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_4_GLuint64EXT::value_type, GLuint64EXT, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_4_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4ui64vNV"));
        glIsProgram(program);
    }
    glProgramUniform4ui64vNV(program, location, count, reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // amd_gpu_shader_int64
#endif // GL_AMD_gpu_shader_int64
#ifdef GL_AMD_interleaved_elements
namespace amd_interleaved_elements {
constexpr u32 red = 0x1903;
constexpr u32 green = 0x1904;
constexpr u32 blue = 0x1905;
constexpr u32 alpha = 0x1906;
constexpr u32 rg8ui = 0x8238;
constexpr u32 rg16ui = 0x823A;
constexpr u32 rgba8ui = 0x8D7C;
constexpr u32 vertex_element_swizzle_amd = 0x91A4;
constexpr u32 vertex_id_swizzle_amd = 0x91A5;
STATICINLINE void vertex_attrib_parameteri_amd(u32 index, GLenum pname, i32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribParameteriAMD)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribParameteriAMD"));
    }
    glVertexAttribParameteriAMD(index, pname, param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // amd_interleaved_elements
#endif // GL_AMD_interleaved_elements
#ifdef GL_AMD_multi_draw_indirect
namespace amd_multi_draw_indirect {
STATICINLINE void multi_draw_arrays_indirect_amd(groups::primitive_type mode, ptroff indirect, i32 primcount, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiDrawArraysIndirectAMD)
                Throw(undefined_behavior(
                    "unloaded function MultiDrawArraysIndirectAMD"));
    }
    glMultiDrawArraysIndirectAMD(static_cast<GLenum>(mode), reinterpret_cast<const void*>(indirect), primcount, stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_draw_elements_indirect_amd(groups::primitive_type mode, groups::draw_elements_type type, ptroff indirect, i32 primcount, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiDrawElementsIndirectAMD)
                Throw(undefined_behavior(
                    "unloaded function MultiDrawElementsIndirectAMD"));
    }
    glMultiDrawElementsIndirectAMD(static_cast<GLenum>(mode), static_cast<GLenum>(type), reinterpret_cast<const void*>(indirect), primcount, stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // amd_multi_draw_indirect
#endif // GL_AMD_multi_draw_indirect
#ifdef GL_AMD_name_gen_delete
namespace amd_name_gen_delete {
constexpr u32 data_buffer_amd = 0x9151;
constexpr u32 performance_monitor_amd = 0x9152;
constexpr u32 query_object_amd = 0x9153;
constexpr u32 vertex_array_object_amd = 0x9154;
constexpr u32 sampler_object_amd = 0x9155;
template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_names_amd(GLenum identifier, span_const_u32 const& names)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteNamesAMD)
                Throw(undefined_behavior(
                    "unloaded function DeleteNamesAMD"));
    }
    glDeleteNamesAMD(identifier, names.size(), reinterpret_cast<const GLuint *>(names.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void gen_names_amd(GLenum identifier, span_u32 names)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenNamesAMD)
                Throw(undefined_behavior(
                    "unloaded function GenNamesAMD"));
    }
    glGenNamesAMD(identifier, names.size(), reinterpret_cast<GLuint *>(names.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_name_amd(GLenum identifier, u32 name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsNameAMD)
                Throw(undefined_behavior(
                    "unloaded function IsNameAMD"));
    }
    auto out = glIsNameAMD(identifier, name);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // amd_name_gen_delete
#endif // GL_AMD_name_gen_delete
#ifdef GL_AMD_occlusion_query_event
namespace amd_occlusion_query_event {
constexpr u32 query_depth_pass_event_bit_amd = 0x00000001;
constexpr u32 query_depth_fail_event_bit_amd = 0x00000002;
constexpr u32 query_stencil_fail_event_bit_amd = 0x00000004;
constexpr u32 query_depth_bounds_fail_event_bit_amd = 0x00000008;
constexpr u32 query_all_event_bits_amd = 0xFFFFFFFF;
constexpr u32 occlusion_query_event_mask_amd = 0x874F;
STATICINLINE void query_object_parameterui_amd(groups::query_target target, u32 id, GLenum pname, u32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glQueryObjectParameteruiAMD)
                Throw(undefined_behavior(
                    "unloaded function QueryObjectParameteruiAMD"));
    }
    glQueryObjectParameteruiAMD(static_cast<GLenum>(target), id, pname, param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // amd_occlusion_query_event
#endif // GL_AMD_occlusion_query_event
#ifdef GL_AMD_performance_monitor
namespace amd_performance_monitor {
constexpr u32 counter_type_amd = 0x8BC0;
constexpr u32 counter_range_amd = 0x8BC1;
constexpr u32 unsigned_int64_amd = 0x8BC2;
constexpr u32 percentage_amd = 0x8BC3;
constexpr u32 perfmon_result_available_amd = 0x8BC4;
constexpr u32 perfmon_result_size_amd = 0x8BC5;
constexpr u32 perfmon_result_amd = 0x8BC6;
STATICINLINE void begin_perf_monitor_amd(u32 monitor)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBeginPerfMonitorAMD)
                Throw(undefined_behavior(
                    "unloaded function BeginPerfMonitorAMD"));
    }
    glBeginPerfMonitorAMD(monitor);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void delete_perf_monitors_amd(span_u32 monitors)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeletePerfMonitorsAMD)
                Throw(undefined_behavior(
                    "unloaded function DeletePerfMonitorsAMD"));
    }
    glDeletePerfMonitorsAMD(monitors.size(), reinterpret_cast<GLuint *>(monitors.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void end_perf_monitor_amd(u32 monitor)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEndPerfMonitorAMD)
                Throw(undefined_behavior(
                    "unloaded function EndPerfMonitorAMD"));
    }
    glEndPerfMonitorAMD(monitor);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void gen_perf_monitors_amd(span_u32 monitors)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenPerfMonitorsAMD)
                Throw(undefined_behavior(
                    "unloaded function GenPerfMonitorsAMD"));
    }
    glGenPerfMonitorsAMD(monitors.size(), reinterpret_cast<GLuint *>(monitors.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_perf_monitor_counter_data_amd(u32 monitor, GLenum pname, i32 dataSize, span_u32 data, i32& bytesWritten)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPerfMonitorCounterDataAMD)
                Throw(undefined_behavior(
                    "unloaded function GetPerfMonitorCounterDataAMD"));
    }
    glGetPerfMonitorCounterDataAMD(monitor, pname, dataSize, reinterpret_cast<GLuint *>(data.data()), &bytesWritten);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_perf_monitor_counter_info_amd(u32 group, u32 counter, GLenum pname, span_byte data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPerfMonitorCounterInfoAMD)
                Throw(undefined_behavior(
                    "unloaded function GetPerfMonitorCounterInfoAMD"));
    }
    glGetPerfMonitorCounterInfoAMD(group, counter, pname, reinterpret_cast<void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLchar
>
requires (
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE void get_perf_monitor_counter_string_amd(u32 group, u32 counter, i32& length, span_GLchar counterString)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPerfMonitorCounterStringAMD)
                Throw(undefined_behavior(
                    "unloaded function GetPerfMonitorCounterStringAMD"));
    }
    glGetPerfMonitorCounterStringAMD(group, counter, counterString.size(), &length, counterString.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_perf_monitor_counters_amd(u32 group, i32& numCounters, i32& maxActiveCounters, span_u32 counters)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPerfMonitorCountersAMD)
                Throw(undefined_behavior(
                    "unloaded function GetPerfMonitorCountersAMD"));
    }
    glGetPerfMonitorCountersAMD(group, &numCounters, &maxActiveCounters, counters.size(), reinterpret_cast<GLuint *>(counters.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLchar
>
requires (
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE void get_perf_monitor_group_string_amd(u32 group, i32& length, span_GLchar groupString)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPerfMonitorGroupStringAMD)
                Throw(undefined_behavior(
                    "unloaded function GetPerfMonitorGroupStringAMD"));
    }
    glGetPerfMonitorGroupStringAMD(group, groupString.size(), &length, groupString.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_perf_monitor_groups_amd(i32& numGroups, span_u32 groups)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPerfMonitorGroupsAMD)
                Throw(undefined_behavior(
                    "unloaded function GetPerfMonitorGroupsAMD"));
    }
    glGetPerfMonitorGroupsAMD(&numGroups, groups.size(), reinterpret_cast<GLuint *>(groups.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void select_perf_monitor_counters_amd(u32 monitor, bool enable, u32 group, span_u32 counterList)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSelectPerfMonitorCountersAMD)
                Throw(undefined_behavior(
                    "unloaded function SelectPerfMonitorCountersAMD"));
    }
    glSelectPerfMonitorCountersAMD(monitor, enable, group, counterList.size(), reinterpret_cast<GLuint *>(counterList.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // amd_performance_monitor
#endif // GL_AMD_performance_monitor
#ifdef GL_AMD_pinned_memory
namespace amd_pinned_memory {
constexpr u32 external_virtual_memory_buffer_amd = 0x9160;
} // amd_pinned_memory
#endif // GL_AMD_pinned_memory
#ifdef GL_AMD_program_binary_Z400
namespace amd_program_binary_z400 {
constexpr u32 z400_binary_amd = 0x8740;
} // amd_program_binary_z400
#endif // GL_AMD_program_binary_Z400
#ifdef GL_AMD_query_buffer_object
namespace amd_query_buffer_object {
constexpr u32 query_buffer_amd = 0x9192;
constexpr u32 query_buffer_binding_amd = 0x9193;
constexpr u32 query_result_no_wait_amd = 0x9194;
} // amd_query_buffer_object
#endif // GL_AMD_query_buffer_object
#ifdef GL_AMD_sample_positions
namespace amd_sample_positions {
constexpr u32 subsample_distance_amd = 0x883F;
template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void set_multisamplefv_amd(GLenum pname, u32 index, span_const_f32 const& val)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSetMultisamplefvAMD)
                Throw(undefined_behavior(
                    "unloaded function SetMultisamplefvAMD"));
    }
    glSetMultisamplefvAMD(pname, index, reinterpret_cast<const GLfloat *>(val.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // amd_sample_positions
#endif // GL_AMD_sample_positions
#ifdef GL_AMD_seamless_cubemap_per_texture
namespace amd_seamless_cubemap_per_texture {
constexpr u32 texture_cube_map_seamless = 0x884F;
} // amd_seamless_cubemap_per_texture
#endif // GL_AMD_seamless_cubemap_per_texture
#ifdef GL_AMD_shader_atomic_counter_ops
namespace amd_shader_atomic_counter_ops {
} // amd_shader_atomic_counter_ops
#endif // GL_AMD_shader_atomic_counter_ops
#ifdef GL_AMD_shader_ballot
namespace amd_shader_ballot {
} // amd_shader_ballot
#endif // GL_AMD_shader_ballot
#ifdef GL_AMD_shader_gpu_shader_half_float_fetch
namespace amd_shader_gpu_shader_half_float_fetch {
} // amd_shader_gpu_shader_half_float_fetch
#endif // GL_AMD_shader_gpu_shader_half_float_fetch
#ifdef GL_AMD_shader_image_load_store_lod
namespace amd_shader_image_load_store_lod {
} // amd_shader_image_load_store_lod
#endif // GL_AMD_shader_image_load_store_lod
#ifdef GL_AMD_shader_stencil_export
namespace amd_shader_stencil_export {
} // amd_shader_stencil_export
#endif // GL_AMD_shader_stencil_export
#ifdef GL_AMD_shader_trinary_minmax
namespace amd_shader_trinary_minmax {
} // amd_shader_trinary_minmax
#endif // GL_AMD_shader_trinary_minmax
#ifdef GL_AMD_shader_explicit_vertex_parameter
namespace amd_shader_explicit_vertex_parameter {
} // amd_shader_explicit_vertex_parameter
#endif // GL_AMD_shader_explicit_vertex_parameter
#ifdef GL_AMD_sparse_texture
namespace amd_sparse_texture {
constexpr u32 texture_storage_sparse_bit_amd = 0x00000001;
constexpr u32 virtual_page_size_x_amd = 0x9195;
constexpr u32 virtual_page_size_y_amd = 0x9196;
constexpr u32 virtual_page_size_z_amd = 0x9197;
constexpr u32 max_sparse_texture_size_amd = 0x9198;
constexpr u32 max_sparse_3d_texture_size_amd = 0x9199;
constexpr u32 max_sparse_array_texture_layers = 0x919A;
constexpr u32 min_sparse_level_amd = 0x919B;
constexpr u32 min_lod_warning_amd = 0x919C;
template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void tex_storage_sparse_amd(groups::texture_target target, groups::sized_internal_format internalFormat, vec_3_i32 const& width, i32 layers, groups::texture_storage_mask_amd flags)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexStorageSparseAMD)
                Throw(undefined_behavior(
                    "unloaded function TexStorageSparseAMD"));
    }
    glTexStorageSparseAMD(static_cast<GLenum>(target), static_cast<GLenum>(internalFormat), width[0], width[1], width[2], layers, static_cast<GLenum>(flags));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void texture_storage_sparse_amd(u32 texture, GLenum target, groups::sized_internal_format internalFormat, vec_3_i32 const& width, i32 layers, groups::texture_storage_mask_amd flags)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureStorageSparseAMD)
                Throw(undefined_behavior(
                    "unloaded function TextureStorageSparseAMD"));
        glIsTexture(texture);
    }
    glTextureStorageSparseAMD(texture, target, static_cast<GLenum>(internalFormat), width[0], width[1], width[2], layers, static_cast<GLenum>(flags));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // amd_sparse_texture
#endif // GL_AMD_sparse_texture
#ifdef GL_AMD_stencil_operation_extended
namespace amd_stencil_operation_extended {
constexpr u32 set_amd = 0x874A;
constexpr u32 replace_value_amd = 0x874B;
constexpr u32 stencil_op_value_amd = 0x874C;
constexpr u32 stencil_back_op_value_amd = 0x874D;
STATICINLINE void stencil_op_value_amd(groups::stencil_face_direction face, u32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glStencilOpValueAMD)
                Throw(undefined_behavior(
                    "unloaded function StencilOpValueAMD"));
    }
    glStencilOpValueAMD(static_cast<GLenum>(face), value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // amd_stencil_operation_extended
#endif // GL_AMD_stencil_operation_extended
#ifdef GL_AMD_texture_gather_bias_lod
namespace amd_texture_gather_bias_lod {
} // amd_texture_gather_bias_lod
#endif // GL_AMD_texture_gather_bias_lod
#ifdef GL_AMD_texture_texture4
namespace amd_texture_texture4 {
} // amd_texture_texture4
#endif // GL_AMD_texture_texture4
#ifdef GL_AMD_transform_feedback3_lines_triangles
namespace amd_transform_feedback3_lines_triangles {
} // amd_transform_feedback3_lines_triangles
#endif // GL_AMD_transform_feedback3_lines_triangles
#ifdef GL_AMD_transform_feedback4
namespace amd_transform_feedback4 {
constexpr u32 stream_rasterization_amd = 0x91A0;
} // amd_transform_feedback4
#endif // GL_AMD_transform_feedback4
#ifdef GL_AMD_vertex_shader_layer
namespace amd_vertex_shader_layer {
} // amd_vertex_shader_layer
#endif // GL_AMD_vertex_shader_layer
#ifdef GL_AMD_vertex_shader_tessellator
namespace amd_vertex_shader_tessellator {
constexpr u32 sampler_buffer_amd = 0x9001;
constexpr u32 int_sampler_buffer_amd = 0x9002;
constexpr u32 unsigned_int_sampler_buffer_amd = 0x9003;
constexpr u32 tessellation_mode_amd = 0x9004;
constexpr u32 tessellation_factor_amd = 0x9005;
constexpr u32 discrete_amd = 0x9006;
constexpr u32 continuous_amd = 0x9007;
STATICINLINE void tessellation_factor_amd(f32 factor)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTessellationFactorAMD)
                Throw(undefined_behavior(
                    "unloaded function TessellationFactorAMD"));
    }
    glTessellationFactorAMD(factor);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tessellation_mode_amd(GLenum mode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTessellationModeAMD)
                Throw(undefined_behavior(
                    "unloaded function TessellationModeAMD"));
    }
    glTessellationModeAMD(mode);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // amd_vertex_shader_tessellator
#endif // GL_AMD_vertex_shader_tessellator
#ifdef GL_AMD_vertex_shader_viewport_index
namespace amd_vertex_shader_viewport_index {
} // amd_vertex_shader_viewport_index
#endif // GL_AMD_vertex_shader_viewport_index
#ifdef GL_ARB_ES2_compatibility
namespace arb_es2_compatibility {
constexpr u32 fixed = 0x140C;
constexpr u32 implementation_color_read_type = 0x8B9A;
constexpr u32 implementation_color_read_format = 0x8B9B;
constexpr u32 rgb565 = 0x8D62;
constexpr u32 low_float = 0x8DF0;
constexpr u32 medium_float = 0x8DF1;
constexpr u32 high_float = 0x8DF2;
constexpr u32 low_int = 0x8DF3;
constexpr u32 medium_int = 0x8DF4;
constexpr u32 high_int = 0x8DF5;
constexpr u32 shader_binary_formats = 0x8DF8;
constexpr u32 num_shader_binary_formats = 0x8DF9;
constexpr u32 shader_compiler = 0x8DFA;
constexpr u32 max_vertex_uniform_vectors = 0x8DFB;
constexpr u32 max_varying_vectors = 0x8DFC;
constexpr u32 max_fragment_uniform_vectors = 0x8DFD;
STATICINLINE void clear_depthf(f32 d)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClearDepthf)
                Throw(undefined_behavior(
                    "unloaded function ClearDepthf"));
    }
    glClearDepthf(d);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void depth_rangef(f32 n, f32 f)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDepthRangef)
                Throw(undefined_behavior(
                    "unloaded function DepthRangef"));
    }
    glDepthRangef(n, f);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_shader_precision_format(groups::shader_type shadertype, groups::precision_type precisiontype, span_i32 range, i32& precision)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetShaderPrecisionFormat)
                Throw(undefined_behavior(
                    "unloaded function GetShaderPrecisionFormat"));
    }
    glGetShaderPrecisionFormat(static_cast<GLenum>(shadertype), static_cast<GLenum>(precisiontype), reinterpret_cast<GLint *>(range.data()), &precision);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void release_shader_compiler()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glReleaseShaderCompiler)
                Throw(undefined_behavior(
                    "unloaded function ReleaseShaderCompiler"));
    }
    glReleaseShaderCompiler();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void shader_binary(span_const_u32 const& shaders, groups::shader_binary_format binaryFormat, span_const_byte const& binary, i32 length)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glShaderBinary)
                Throw(undefined_behavior(
                    "unloaded function ShaderBinary"));
    }
    glShaderBinary(shaders.size(), reinterpret_cast<const GLuint *>(shaders.data()), static_cast<GLenum>(binaryFormat), reinterpret_cast<const void *>(binary.data()), length);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_es2_compatibility
#endif // GL_ARB_ES2_compatibility
#ifdef GL_ARB_ES3_1_compatibility
namespace arb_es3_1_compatibility {
constexpr u32 back = 0x0405;
STATICINLINE void memory_barrier_by_region(groups::memory_barrier_mask barriers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMemoryBarrierByRegion)
                Throw(undefined_behavior(
                    "unloaded function MemoryBarrierByRegion"));
    }
    glMemoryBarrierByRegion(static_cast<GLenum>(barriers));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_es3_1_compatibility
#endif // GL_ARB_ES3_1_compatibility
#ifdef GL_ARB_ES3_2_compatibility
namespace arb_es3_2_compatibility {
constexpr u32 primitive_bounding_box_arb = 0x92BE;
constexpr u32 multisample_line_width_range_arb = 0x9381;
constexpr u32 multisample_line_width_granularity_arb = 0x9382;
STATICINLINE void primitive_bounding_box_arb(f32 minX, f32 minY, f32 minZ, f32 minW, f32 maxX, f32 maxY, f32 maxZ, f32 maxW)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPrimitiveBoundingBoxARB)
                Throw(undefined_behavior(
                    "unloaded function PrimitiveBoundingBoxARB"));
    }
    glPrimitiveBoundingBoxARB(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_es3_2_compatibility
#endif // GL_ARB_ES3_2_compatibility
#ifdef GL_ARB_ES3_compatibility
namespace arb_es3_compatibility {
constexpr u32 primitive_restart_fixed_index = 0x8D69;
constexpr u32 any_samples_passed_conservative = 0x8D6A;
constexpr u32 max_element_index = 0x8D6B;
constexpr u32 compressed_r11_eac = 0x9270;
constexpr u32 compressed_signed_r11_eac = 0x9271;
constexpr u32 compressed_rg11_eac = 0x9272;
constexpr u32 compressed_signed_rg11_eac = 0x9273;
constexpr u32 compressed_rgb8_etc2 = 0x9274;
constexpr u32 compressed_srgb8_etc2 = 0x9275;
constexpr u32 compressed_rgb8_punchthrough_alpha1_etc2 = 0x9276;
constexpr u32 compressed_srgb8_punchthrough_alpha1_etc2 = 0x9277;
constexpr u32 compressed_rgba8_etc2_eac = 0x9278;
constexpr u32 compressed_srgb8_alpha8_etc2_eac = 0x9279;
} // arb_es3_compatibility
#endif // GL_ARB_ES3_compatibility
#ifdef GL_ARB_arrays_of_arrays
namespace arb_arrays_of_arrays {
} // arb_arrays_of_arrays
#endif // GL_ARB_arrays_of_arrays
#ifdef GL_ARB_base_instance
namespace arb_base_instance {
STATICINLINE void draw_arrays_instanced_base_instance(groups::primitive_type mode, i32 first, i32 count, i32 instancecount, u32 baseinstance)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawArraysInstancedBaseInstance)
                Throw(undefined_behavior(
                    "unloaded function DrawArraysInstancedBaseInstance"));
    }
    glDrawArraysInstancedBaseInstance(static_cast<GLenum>(mode), first, count, instancecount, baseinstance);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void draw_elements_instanced_base_instance(groups::primitive_type mode, i32 count, groups::primitive_type type, ptroff indices, i32 instancecount, u32 baseinstance)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawElementsInstancedBaseInstance)
                Throw(undefined_behavior(
                    "unloaded function DrawElementsInstancedBaseInstance"));
    }
    glDrawElementsInstancedBaseInstance(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), reinterpret_cast<const void*>(indices), instancecount, baseinstance);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void draw_elements_instanced_base_vertex_base_instance(groups::primitive_type mode, i32 count, groups::draw_elements_type type, ptroff indices, i32 instancecount, i32 basevertex, u32 baseinstance)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawElementsInstancedBaseVertexBaseInstance)
                Throw(undefined_behavior(
                    "unloaded function DrawElementsInstancedBaseVertexBaseInstance"));
    }
    glDrawElementsInstancedBaseVertexBaseInstance(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), reinterpret_cast<const void*>(indices), instancecount, basevertex, baseinstance);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_base_instance
#endif // GL_ARB_base_instance
#ifdef GL_ARB_bindless_texture
namespace arb_bindless_texture {
constexpr u32 unsigned_int64_arb = 0x140F;
STATICINLINE GLuint64 get_image_handle_arb(u32 texture, i32 level, bool layered, i32 layer, groups::pixel_format format)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetImageHandleARB)
                Throw(undefined_behavior(
                    "unloaded function GetImageHandleARB"));
        glIsTexture(texture);
    }
    auto out = glGetImageHandleARB(texture, level, layered, layer, static_cast<GLenum>(format));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLuint64 get_texture_handle_arb(u32 texture)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTextureHandleARB)
                Throw(undefined_behavior(
                    "unloaded function GetTextureHandleARB"));
        glIsTexture(texture);
    }
    auto out = glGetTextureHandleARB(texture);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLuint64 get_texture_sampler_handle_arb(u32 texture, u32 sampler)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTextureSamplerHandleARB)
                Throw(undefined_behavior(
                    "unloaded function GetTextureSamplerHandleARB"));
        glIsTexture(texture);
        glIsSampler(sampler);
    }
    auto out = glGetTextureSamplerHandleARB(texture, sampler);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE void get_vertex_attrib_lui64v_arb(u32 index, groups::vertex_attrib_enum pname, span_GLuint64EXT params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribLui64vARB)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribLui64vARB"));
    }
    glGetVertexAttribLui64vARB(index, static_cast<GLenum>(pname), reinterpret_cast<GLuint64EXT *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_image_handle_resident_arb(u64 handle)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsImageHandleResidentARB)
                Throw(undefined_behavior(
                    "unloaded function IsImageHandleResidentARB"));
    }
    auto out = glIsImageHandleResidentARB(handle);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLboolean is_texture_handle_resident_arb(u64 handle)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsTextureHandleResidentARB)
                Throw(undefined_behavior(
                    "unloaded function IsTextureHandleResidentARB"));
    }
    auto out = glIsTextureHandleResidentARB(handle);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void make_image_handle_non_resident_arb(u64 handle)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMakeImageHandleNonResidentARB)
                Throw(undefined_behavior(
                    "unloaded function MakeImageHandleNonResidentARB"));
    }
    glMakeImageHandleNonResidentARB(handle);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void make_image_handle_resident_arb(u64 handle, GLenum access)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMakeImageHandleResidentARB)
                Throw(undefined_behavior(
                    "unloaded function MakeImageHandleResidentARB"));
    }
    glMakeImageHandleResidentARB(handle, access);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void make_texture_handle_non_resident_arb(u64 handle)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMakeTextureHandleNonResidentARB)
                Throw(undefined_behavior(
                    "unloaded function MakeTextureHandleNonResidentARB"));
    }
    glMakeTextureHandleNonResidentARB(handle);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void make_texture_handle_resident_arb(u64 handle)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMakeTextureHandleResidentARB)
                Throw(undefined_behavior(
                    "unloaded function MakeTextureHandleResidentARB"));
    }
    glMakeTextureHandleResidentARB(handle);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void program_uniform_handle(u32 program, i32 location, u64 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformHandleui64ARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformHandleui64ARB"));
        glIsProgram(program);
    }
    glProgramUniformHandleui64ARB(program, location, value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u64
>
requires (
    semantic::concepts::Span<span_const_u64> &&
    std::is_same_v<std::decay_t<typename span_const_u64::value_type>, u64>)
STATICINLINE void program_uniform_handle(u32 program, i32 location, span_const_u64 const& values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformHandleui64vARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformHandleui64vARB"));
        glIsProgram(program);
    }
    glProgramUniformHandleui64vARB(program, location, values.size(), reinterpret_cast<const GLuint64 *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void uniform_handle(i32 location, u64 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformHandleui64ARB)
                Throw(undefined_behavior(
                    "unloaded function UniformHandleui64ARB"));
    }
    glUniformHandleui64ARB(location, value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u64
>
requires (
    semantic::concepts::Span<span_const_u64> &&
    std::is_same_v<std::decay_t<typename span_const_u64::value_type>, u64>)
STATICINLINE void uniform_handle(i32 location, span_const_u64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformHandleui64vARB)
                Throw(undefined_behavior(
                    "unloaded function UniformHandleui64vARB"));
    }
    glUniformHandleui64vARB(location, value.size(), reinterpret_cast<const GLuint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib_l1ui64_arb(u32 index, GLuint64EXT x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL1ui64ARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL1ui64ARB"));
    }
    glVertexAttribL1ui64ARB(index, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_const_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE void vertex_attrib_l1ui64v_arb(u32 index, span_const_GLuint64EXT const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL1ui64vARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL1ui64vARB"));
    }
    glVertexAttribL1ui64vARB(index, reinterpret_cast<const GLuint64EXT *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_bindless_texture
#endif // GL_ARB_bindless_texture
#ifdef GL_ARB_blend_func_extended
namespace arb_blend_func_extended {
constexpr u32 src1_alpha = 0x8589;
constexpr u32 src1_color = 0x88F9;
constexpr u32 one_minus_src1_color = 0x88FA;
constexpr u32 one_minus_src1_alpha = 0x88FB;
constexpr u32 max_dual_source_draw_buffers = 0x88FC;
STATICINLINE void bind_frag_data_location_indexed(u32 program, u32 colorNumber, u32 index, std::string_view const& name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindFragDataLocationIndexed)
                Throw(undefined_behavior(
                    "unloaded function BindFragDataLocationIndexed"));
        glIsProgram(program);
    }
    glBindFragDataLocationIndexed(program, colorNumber, index, name.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLint get_frag_data_index(u32 program, std::string_view const& name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetFragDataIndex)
                Throw(undefined_behavior(
                    "unloaded function GetFragDataIndex"));
        glIsProgram(program);
    }
    auto out = glGetFragDataIndex(program, name.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // arb_blend_func_extended
#endif // GL_ARB_blend_func_extended
#ifdef GL_ARB_buffer_storage
namespace arb_buffer_storage {
constexpr u32 dynamic_storage_bit = 0x0100;
constexpr u32 client_storage_bit = 0x0200;
constexpr u32 map_read_bit = 0x0001;
constexpr u32 map_write_bit = 0x0002;
constexpr u32 map_persistent_bit = 0x0040;
constexpr u32 map_coherent_bit = 0x0080;
constexpr u32 client_mapped_buffer_barrier_bit = 0x00004000;
constexpr u32 buffer_immutable_storage = 0x821F;
constexpr u32 buffer_storage_flags = 0x8220;
template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void buffer_storage(groups::buffer_storage_target target, span_const_byte const& data, groups::buffer_storage_mask flags)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBufferStorage)
                Throw(undefined_behavior(
                    "unloaded function BufferStorage"));
    }
    glBufferStorage(static_cast<GLenum>(target), data.size(), reinterpret_cast<const void *>(data.data()), static_cast<GLenum>(flags));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_buffer_storage
#endif // GL_ARB_buffer_storage
#ifdef GL_ARB_cl_event
namespace arb_cl_event {
constexpr u32 sync_cl_event_arb = 0x8240;
constexpr u32 sync_cl_event_complete_arb = 0x8241;
template<
    class span__cl_context,
    class span__cl_event
>
requires (
    semantic::concepts::Span<span__cl_context> &&
    std::is_same_v<std::decay_t<typename span__cl_context::value_type>, _cl_context> &&
    semantic::concepts::Span<span__cl_event> &&
    std::is_same_v<std::decay_t<typename span__cl_event::value_type>, _cl_event>)
STATICINLINE GLsync create_sync_from_c_levent_arb(span__cl_context const& context, span__cl_event const& event, GLbitfield flags)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreateSyncFromCLeventARB)
                Throw(undefined_behavior(
                    "unloaded function CreateSyncFromCLeventARB"));
    }
    auto out = glCreateSyncFromCLeventARB(reinterpret_cast<struct _cl_context *>(context.data()), reinterpret_cast<struct _cl_event *>(event.data()), flags);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // arb_cl_event
#endif // GL_ARB_cl_event
#ifdef GL_ARB_clear_buffer_object
namespace arb_clear_buffer_object {
template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void clear_buffer_data(groups::buffer_storage_target target, groups::sized_internal_format internalformat, groups::pixel_format format, groups::pixel_type type, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClearBufferData)
                Throw(undefined_behavior(
                    "unloaded function ClearBufferData"));
    }
    glClearBufferData(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void clear_buffer_sub_data(groups::buffer_target_arb target, groups::sized_internal_format internalformat, GLintptr offset, GLsizeiptr size, groups::pixel_format format, groups::pixel_type type, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClearBufferSubData)
                Throw(undefined_behavior(
                    "unloaded function ClearBufferSubData"));
    }
    glClearBufferSubData(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), offset, size, static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_clear_buffer_object
#endif // GL_ARB_clear_buffer_object
#ifdef GL_ARB_clear_texture
namespace arb_clear_texture {
constexpr u32 clear_texture = 0x9365;
template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void clear_tex_image(u32 texture, i32 level, groups::pixel_format format, groups::pixel_type type, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClearTexImage)
                Throw(undefined_behavior(
                    "unloaded function ClearTexImage"));
        glIsTexture(texture);
    }
    glClearTexImage(texture, level, static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void clear_tex_sub_image(u32 texture, i32 level, vec_3_i32 const& xoffset, vec_3_i32 const& width, groups::pixel_format format, groups::pixel_type type, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClearTexSubImage)
                Throw(undefined_behavior(
                    "unloaded function ClearTexSubImage"));
        glIsTexture(texture);
    }
    glClearTexSubImage(texture, level, xoffset.x(), xoffset.y(), xoffset.z(), width[0], width[1], width[2], static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_clear_texture
#endif // GL_ARB_clear_texture
#ifdef GL_ARB_clip_control
namespace arb_clip_control {
constexpr u32 lower_left = 0x8CA1;
constexpr u32 upper_left = 0x8CA2;
constexpr u32 clip_origin = 0x935C;
constexpr u32 clip_depth_mode = 0x935D;
constexpr u32 negative_one_to_one = 0x935E;
constexpr u32 zero_to_one = 0x935F;
STATICINLINE void clip_control(groups::clip_control_origin origin, groups::clip_control_depth depth)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClipControl)
                Throw(undefined_behavior(
                    "unloaded function ClipControl"));
    }
    glClipControl(static_cast<GLenum>(origin), static_cast<GLenum>(depth));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_clip_control
#endif // GL_ARB_clip_control
#ifdef GL_ARB_color_buffer_float
namespace arb_color_buffer_float {
constexpr u32 rgba_float_mode_arb = 0x8820;
constexpr u32 clamp_vertex_color_arb = 0x891A;
constexpr u32 clamp_fragment_color_arb = 0x891B;
constexpr u32 clamp_read_color_arb = 0x891C;
constexpr u32 fixed_only_arb = 0x891D;
STATICINLINE void clamp_color_arb(groups::clamp_color_target_arb target, groups::clamp_color_mode_arb clamp)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClampColorARB)
                Throw(undefined_behavior(
                    "unloaded function ClampColorARB"));
    }
    glClampColorARB(static_cast<GLenum>(target), static_cast<GLenum>(clamp));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_color_buffer_float
#endif // GL_ARB_color_buffer_float
#ifdef GL_ARB_compatibility
namespace arb_compatibility {
} // arb_compatibility
#endif // GL_ARB_compatibility
#ifdef GL_ARB_compressed_texture_pixel_storage
namespace arb_compressed_texture_pixel_storage {
constexpr u32 unpack_compressed_block_width = 0x9127;
constexpr u32 unpack_compressed_block_height = 0x9128;
constexpr u32 unpack_compressed_block_depth = 0x9129;
constexpr u32 unpack_compressed_block_size = 0x912A;
constexpr u32 pack_compressed_block_width = 0x912B;
constexpr u32 pack_compressed_block_height = 0x912C;
constexpr u32 pack_compressed_block_depth = 0x912D;
constexpr u32 pack_compressed_block_size = 0x912E;
} // arb_compressed_texture_pixel_storage
#endif // GL_ARB_compressed_texture_pixel_storage
#ifdef GL_ARB_compute_shader
namespace arb_compute_shader {
constexpr u32 compute_shader_bit = 0x00000020;
constexpr u32 max_compute_shared_memory_size = 0x8262;
constexpr u32 max_compute_uniform_components = 0x8263;
constexpr u32 max_compute_atomic_counter_buffers = 0x8264;
constexpr u32 max_compute_atomic_counters = 0x8265;
constexpr u32 max_combined_compute_uniform_components = 0x8266;
constexpr u32 compute_work_group_size = 0x8267;
constexpr u32 max_compute_work_group_invocations = 0x90EB;
constexpr u32 uniform_block_referenced_by_compute_shader = 0x90EC;
constexpr u32 atomic_counter_buffer_referenced_by_compute_shader = 0x90ED;
constexpr u32 dispatch_indirect_buffer = 0x90EE;
constexpr u32 dispatch_indirect_buffer_binding = 0x90EF;
constexpr u32 compute_shader = 0x91B9;
constexpr u32 max_compute_uniform_blocks = 0x91BB;
constexpr u32 max_compute_texture_image_units = 0x91BC;
constexpr u32 max_compute_image_uniforms = 0x91BD;
constexpr u32 max_compute_work_group_count = 0x91BE;
constexpr u32 max_compute_work_group_size = 0x91BF;
STATICINLINE void dispatch_compute(u32 num_groups_x, u32 num_groups_y, u32 num_groups_z)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDispatchCompute)
                Throw(undefined_behavior(
                    "unloaded function DispatchCompute"));
    }
    glDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void dispatch_compute_indirect(GLintptr indirect)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDispatchComputeIndirect)
                Throw(undefined_behavior(
                    "unloaded function DispatchComputeIndirect"));
    }
    glDispatchComputeIndirect(indirect);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_compute_shader
#endif // GL_ARB_compute_shader
#ifdef GL_ARB_compute_variable_group_size
namespace arb_compute_variable_group_size {
constexpr u32 max_compute_fixed_group_invocations_arb = 0x90EB;
constexpr u32 max_compute_fixed_group_size_arb = 0x91BF;
constexpr u32 max_compute_variable_group_invocations_arb = 0x9344;
constexpr u32 max_compute_variable_group_size_arb = 0x9345;
STATICINLINE void dispatch_compute_group_size_arb(u32 num_groups_x, u32 num_groups_y, u32 num_groups_z, u32 group_size_x, u32 group_size_y, u32 group_size_z)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDispatchComputeGroupSizeARB)
                Throw(undefined_behavior(
                    "unloaded function DispatchComputeGroupSizeARB"));
    }
    glDispatchComputeGroupSizeARB(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_compute_variable_group_size
#endif // GL_ARB_compute_variable_group_size
#ifdef GL_ARB_conditional_render_inverted
namespace arb_conditional_render_inverted {
constexpr u32 query_wait_inverted = 0x8E17;
constexpr u32 query_no_wait_inverted = 0x8E18;
constexpr u32 query_by_region_wait_inverted = 0x8E19;
constexpr u32 query_by_region_no_wait_inverted = 0x8E1A;
} // arb_conditional_render_inverted
#endif // GL_ARB_conditional_render_inverted
#ifdef GL_ARB_conservative_depth
namespace arb_conservative_depth {
} // arb_conservative_depth
#endif // GL_ARB_conservative_depth
#ifdef GL_ARB_copy_buffer
namespace arb_copy_buffer {
constexpr u32 copy_read_buffer = 0x8F36;
constexpr u32 copy_write_buffer = 0x8F37;
STATICINLINE void copy_buffer_sub_data(groups::copy_buffer_sub_data_target readTarget, groups::copy_buffer_sub_data_target writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCopyBufferSubData)
                Throw(undefined_behavior(
                    "unloaded function CopyBufferSubData"));
    }
    glCopyBufferSubData(static_cast<GLenum>(readTarget), static_cast<GLenum>(writeTarget), readOffset, writeOffset, size);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_copy_buffer
#endif // GL_ARB_copy_buffer
#ifdef GL_ARB_copy_image
namespace arb_copy_image {
STATICINLINE void copy_image_sub_data(u32 srcName, groups::copy_image_sub_data_target srcTarget, i32 srcLevel, i32 srcX, i32 srcY, i32 srcZ, u32 dstName, groups::copy_image_sub_data_target dstTarget, i32 dstLevel, i32 dstX, i32 dstY, i32 dstZ, i32 srcWidth, i32 srcHeight, i32 srcDepth)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCopyImageSubData)
                Throw(undefined_behavior(
                    "unloaded function CopyImageSubData"));
    }
    glCopyImageSubData(srcName, static_cast<GLenum>(srcTarget), srcLevel, srcX, srcY, srcZ, dstName, static_cast<GLenum>(dstTarget), dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_copy_image
#endif // GL_ARB_copy_image
#ifdef GL_ARB_cull_distance
namespace arb_cull_distance {
constexpr u32 max_cull_distances = 0x82F9;
constexpr u32 max_combined_clip_and_cull_distances = 0x82FA;
} // arb_cull_distance
#endif // GL_ARB_cull_distance
#ifdef GL_ARB_debug_output
namespace arb_debug_output {
constexpr u32 debug_output_synchronous_arb = 0x8242;
constexpr u32 debug_next_logged_message_length_arb = 0x8243;
constexpr u32 debug_callback_function_arb = 0x8244;
constexpr u32 debug_callback_user_param_arb = 0x8245;
constexpr u32 debug_source_api_arb = 0x8246;
constexpr u32 debug_source_window_system_arb = 0x8247;
constexpr u32 debug_source_shader_compiler_arb = 0x8248;
constexpr u32 debug_source_third_party_arb = 0x8249;
constexpr u32 debug_source_application_arb = 0x824A;
constexpr u32 debug_source_other_arb = 0x824B;
constexpr u32 debug_type_error_arb = 0x824C;
constexpr u32 debug_type_deprecated_behavior_arb = 0x824D;
constexpr u32 debug_type_undefined_behavior_arb = 0x824E;
constexpr u32 debug_type_portability_arb = 0x824F;
constexpr u32 debug_type_performance_arb = 0x8250;
constexpr u32 debug_type_other_arb = 0x8251;
constexpr u32 max_debug_message_length_arb = 0x9143;
constexpr u32 max_debug_logged_messages_arb = 0x9144;
constexpr u32 debug_logged_messages_arb = 0x9145;
constexpr u32 debug_severity_high_arb = 0x9146;
constexpr u32 debug_severity_medium_arb = 0x9147;
constexpr u32 debug_severity_low_arb = 0x9148;
template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void debug_message_callback_arb(GLDEBUGPROCARB callback, span_const_byte const& userParam)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDebugMessageCallbackARB)
                Throw(undefined_behavior(
                    "unloaded function DebugMessageCallbackARB"));
    }
    glDebugMessageCallbackARB(callback, reinterpret_cast<const void *>(userParam.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void debug_message_control_arb(groups::debug_source source, groups::debug_type type, groups::debug_severity severity, span_const_u32 const& ids, bool enabled)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDebugMessageControlARB)
                Throw(undefined_behavior(
                    "unloaded function DebugMessageControlARB"));
    }
    glDebugMessageControlARB(static_cast<GLenum>(source), static_cast<GLenum>(type), static_cast<GLenum>(severity), ids.size(), reinterpret_cast<const GLuint *>(ids.data()), enabled);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void debug_message_insert_arb(groups::debug_source source, groups::debug_type type, u32 id, groups::debug_severity severity, std::string_view const& buf)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDebugMessageInsertARB)
                Throw(undefined_behavior(
                    "unloaded function DebugMessageInsertARB"));
    }
    glDebugMessageInsertARB(static_cast<GLenum>(source), static_cast<GLenum>(type), id, static_cast<GLenum>(severity), buf.size(), buf.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLchar,
    class span_GLenum,
    class span_i32,
    class span_u32
>
requires (
    semantic::concepts::Span<span_GLenum> &&
    std::is_same_v<std::decay_t<typename span_GLenum::value_type>, GLenum> &&
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32> &&
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32> &&
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE GLuint get_debug_message_log_arb(span_GLenum sources, span_GLenum types, span_u32 ids, span_GLenum severities, span_i32 lengths, span_GLchar messageLog)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetDebugMessageLogARB)
                Throw(undefined_behavior(
                    "unloaded function GetDebugMessageLogARB"));
    }
    auto out = glGetDebugMessageLogARB(sources.size(), messageLog.size(), reinterpret_cast<GLenum *>(sources.data()), reinterpret_cast<GLenum *>(types.data()), reinterpret_cast<GLuint *>(ids.data()), reinterpret_cast<GLenum *>(severities.data()), reinterpret_cast<GLsizei *>(lengths.data()), messageLog.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // arb_debug_output
#endif // GL_ARB_debug_output
#ifdef GL_ARB_depth_buffer_float
namespace arb_depth_buffer_float {
constexpr u32 depth_component32f = 0x8CAC;
constexpr u32 depth32f_stencil8 = 0x8CAD;
constexpr u32 float_32_unsigned_int_24_8_rev = 0x8DAD;
} // arb_depth_buffer_float
#endif // GL_ARB_depth_buffer_float
#ifdef GL_ARB_depth_clamp
namespace arb_depth_clamp {
constexpr u32 depth_clamp = 0x864F;
} // arb_depth_clamp
#endif // GL_ARB_depth_clamp
#ifdef GL_ARB_depth_texture
namespace arb_depth_texture {
constexpr u32 depth_component16_arb = 0x81A5;
constexpr u32 depth_component24_arb = 0x81A6;
constexpr u32 depth_component32_arb = 0x81A7;
constexpr u32 texture_depth_size_arb = 0x884A;
constexpr u32 depth_texture_mode_arb = 0x884B;
} // arb_depth_texture
#endif // GL_ARB_depth_texture
#ifdef GL_ARB_derivative_control
namespace arb_derivative_control {
} // arb_derivative_control
#endif // GL_ARB_derivative_control
#ifdef GL_ARB_direct_state_access
namespace arb_direct_state_access {
constexpr u32 texture_target = 0x1006;
constexpr u32 texture_binding_1d = 0x8068;
constexpr u32 texture_binding_2d = 0x8069;
constexpr u32 texture_binding_3d = 0x806A;
constexpr u32 query_target = 0x82EA;
constexpr u32 texture_binding_rectangle = 0x84F6;
constexpr u32 texture_binding_cube_map = 0x8514;
constexpr u32 texture_binding_1d_array = 0x8C1C;
constexpr u32 texture_binding_2d_array = 0x8C1D;
constexpr u32 texture_binding_buffer = 0x8C2C;
constexpr u32 texture_binding_cube_map_array = 0x900A;
constexpr u32 texture_binding_2d_multisample = 0x9104;
constexpr u32 texture_binding_2d_multisample_array = 0x9105;
template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void create_transform_feedbacks(span_u32 ids)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreateTransformFeedbacks)
                Throw(undefined_behavior(
                    "unloaded function CreateTransformFeedbacks"));
    }
    glCreateTransformFeedbacks(ids.size(), reinterpret_cast<GLuint *>(ids.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i64
>
requires (
    semantic::concepts::Span<span_i64> &&
    std::is_same_v<std::decay_t<typename span_i64::value_type>, i64>)
STATICINLINE void get_transform_feedbacki64_v(u32 xfb, groups::transform_feedback_prop pname, u32 index, span_i64 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTransformFeedbacki64_v)
                Throw(undefined_behavior(
                    "unloaded function GetTransformFeedbacki64_v"));
        glIsTransformFeedback(xfb);
    }
    glGetTransformFeedbacki64_v(xfb, static_cast<GLenum>(pname), index, reinterpret_cast<GLint64 *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_transform_feedbacki_v(u32 xfb, groups::transform_feedback_prop pname, u32 index, span_i32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTransformFeedbacki_v)
                Throw(undefined_behavior(
                    "unloaded function GetTransformFeedbacki_v"));
        glIsTransformFeedback(xfb);
    }
    glGetTransformFeedbacki_v(xfb, static_cast<GLenum>(pname), index, reinterpret_cast<GLint *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_transform_feedbackiv(u32 xfb, groups::transform_feedback_prop pname, span_i32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTransformFeedbackiv)
                Throw(undefined_behavior(
                    "unloaded function GetTransformFeedbackiv"));
        glIsTransformFeedback(xfb);
    }
    glGetTransformFeedbackiv(xfb, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void transform_feedback_buffer_base(u32 xfb, u32 index, u32 buffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTransformFeedbackBufferBase)
                Throw(undefined_behavior(
                    "unloaded function TransformFeedbackBufferBase"));
        glIsTransformFeedback(xfb);
        glIsBuffer(buffer);
    }
    glTransformFeedbackBufferBase(xfb, index, buffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void transform_feedback_buffer_range(u32 xfb, u32 index, u32 buffer, GLintptr offset, GLsizeiptr size)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTransformFeedbackBufferRange)
                Throw(undefined_behavior(
                    "unloaded function TransformFeedbackBufferRange"));
        glIsTransformFeedback(xfb);
        glIsBuffer(buffer);
    }
    glTransformFeedbackBufferRange(xfb, index, buffer, offset, size);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void clear_named_buffer_data(u32 buffer, groups::sized_internal_format internalformat, groups::pixel_format format, groups::pixel_type type, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClearNamedBufferData)
                Throw(undefined_behavior(
                    "unloaded function ClearNamedBufferData"));
        glIsBuffer(buffer);
    }
    glClearNamedBufferData(buffer, static_cast<GLenum>(internalformat), static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void clear_named_buffer_sub_data(u32 buffer, groups::sized_internal_format internalformat, GLintptr offset, GLsizeiptr size, groups::pixel_format format, groups::pixel_type type, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClearNamedBufferSubData)
                Throw(undefined_behavior(
                    "unloaded function ClearNamedBufferSubData"));
        glIsBuffer(buffer);
    }
    glClearNamedBufferSubData(buffer, static_cast<GLenum>(internalformat), offset, size, static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void copy_named_buffer_sub_data(u32 readBuffer, u32 writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCopyNamedBufferSubData)
                Throw(undefined_behavior(
                    "unloaded function CopyNamedBufferSubData"));
    }
    glCopyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void create_buffers(span_u32 buffers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreateBuffers)
                Throw(undefined_behavior(
                    "unloaded function CreateBuffers"));
    }
    glCreateBuffers(buffers.size(), reinterpret_cast<GLuint *>(buffers.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void flush_mapped_named_buffer_range(u32 buffer, GLintptr offset, GLsizeiptr length)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFlushMappedNamedBufferRange)
                Throw(undefined_behavior(
                    "unloaded function FlushMappedNamedBufferRange"));
        glIsBuffer(buffer);
    }
    glFlushMappedNamedBufferRange(buffer, offset, length);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i64
>
requires (
    semantic::concepts::Span<span_i64> &&
    std::is_same_v<std::decay_t<typename span_i64::value_type>, i64>)
STATICINLINE void get_named_buffer_parameteri64v(u32 buffer, groups::buffer_prop_arb pname, span_i64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetNamedBufferParameteri64v)
                Throw(undefined_behavior(
                    "unloaded function GetNamedBufferParameteri64v"));
        glIsBuffer(buffer);
    }
    glGetNamedBufferParameteri64v(buffer, static_cast<GLenum>(pname), reinterpret_cast<GLint64 *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_named_buffer_parameter(u32 buffer, groups::buffer_prop_arb pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetNamedBufferParameteriv)
                Throw(undefined_behavior(
                    "unloaded function GetNamedBufferParameteriv"));
        glIsBuffer(buffer);
    }
    glGetNamedBufferParameteriv(buffer, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_named_buffer_pointerv(u32 buffer, groups::buffer_pointer_name_arb pname, span_byte params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetNamedBufferPointerv)
                Throw(undefined_behavior(
                    "unloaded function GetNamedBufferPointerv"));
        glIsBuffer(buffer);
    }
    glGetNamedBufferPointerv(buffer, static_cast<GLenum>(pname), reinterpret_cast<void **>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_named_buffer_sub_data(u32 buffer, GLintptr offset, GLsizeiptr size, span_byte data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetNamedBufferSubData)
                Throw(undefined_behavior(
                    "unloaded function GetNamedBufferSubData"));
        glIsBuffer(buffer);
    }
    glGetNamedBufferSubData(buffer, offset, size, reinterpret_cast<void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void * map_named_buffer(u32 buffer, groups::buffer_access_arb access)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMapNamedBuffer)
                Throw(undefined_behavior(
                    "unloaded function MapNamedBuffer"));
        glIsBuffer(buffer);
    }
    auto out = glMapNamedBuffer(buffer, static_cast<GLenum>(access));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void * map_named_buffer_range(u32 buffer, GLintptr offset, GLsizeiptr length, groups::map_buffer_access_mask access)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMapNamedBufferRange)
                Throw(undefined_behavior(
                    "unloaded function MapNamedBufferRange"));
        glIsBuffer(buffer);
    }
    auto out = glMapNamedBufferRange(buffer, offset, length, static_cast<GLenum>(access));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void named_buffer_data(u32 buffer, GLsizeiptr size, span_const_byte const& data, groups::vertex_buffer_object_usage usage)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedBufferData)
                Throw(undefined_behavior(
                    "unloaded function NamedBufferData"));
        glIsBuffer(buffer);
    }
    glNamedBufferData(buffer, size, reinterpret_cast<const void *>(data.data()), static_cast<GLenum>(usage));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void named_buffer_storage(u32 buffer, span_const_byte const& data, groups::buffer_storage_mask flags)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedBufferStorage)
                Throw(undefined_behavior(
                    "unloaded function NamedBufferStorage"));
        glIsBuffer(buffer);
    }
    glNamedBufferStorage(buffer, data.size(), reinterpret_cast<const void *>(data.data()), static_cast<GLenum>(flags));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void named_buffer_sub_data(u32 buffer, GLintptr offset, GLsizeiptr size, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedBufferSubData)
                Throw(undefined_behavior(
                    "unloaded function NamedBufferSubData"));
        glIsBuffer(buffer);
    }
    glNamedBufferSubData(buffer, offset, size, reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean unmap_named_buffer(u32 buffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUnmapNamedBuffer)
                Throw(undefined_behavior(
                    "unloaded function UnmapNamedBuffer"));
        glIsBuffer(buffer);
    }
    auto out = glUnmapNamedBuffer(buffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void blit_named_framebuffer(u32 readFramebuffer, u32 drawFramebuffer, i32 srcX0, i32 srcY0, i32 srcX1, i32 srcY1, i32 dstX0, i32 dstY0, i32 dstX1, i32 dstY1, groups::clear_buffer_mask mask, groups::blit_framebuffer_filter filter)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlitNamedFramebuffer)
                Throw(undefined_behavior(
                    "unloaded function BlitNamedFramebuffer"));
    }
    glBlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, static_cast<GLenum>(mask), static_cast<GLenum>(filter));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLenum check_named_framebuffer_status(u32 framebuffer, groups::framebuffer_target target)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCheckNamedFramebufferStatus)
                Throw(undefined_behavior(
                    "unloaded function CheckNamedFramebufferStatus"));
        glIsFramebuffer(framebuffer);
    }
    auto out = glCheckNamedFramebufferStatus(framebuffer, static_cast<GLenum>(target));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void clear_named_framebufferfi(u32 framebuffer, groups::buffer buffer, i32 drawbuffer, f32 depth, i32 stencil)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClearNamedFramebufferfi)
                Throw(undefined_behavior(
                    "unloaded function ClearNamedFramebufferfi"));
        glIsFramebuffer(framebuffer);
    }
    glClearNamedFramebufferfi(framebuffer, static_cast<GLenum>(buffer), drawbuffer, depth, stencil);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void clear_named_framebufferfv(u32 framebuffer, groups::buffer buffer, i32 drawbuffer, span_const_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClearNamedFramebufferfv)
                Throw(undefined_behavior(
                    "unloaded function ClearNamedFramebufferfv"));
        glIsFramebuffer(framebuffer);
    }
    glClearNamedFramebufferfv(framebuffer, static_cast<GLenum>(buffer), drawbuffer, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void clear_named_framebufferiv(u32 framebuffer, groups::buffer buffer, i32 drawbuffer, span_const_i32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClearNamedFramebufferiv)
                Throw(undefined_behavior(
                    "unloaded function ClearNamedFramebufferiv"));
        glIsFramebuffer(framebuffer);
    }
    glClearNamedFramebufferiv(framebuffer, static_cast<GLenum>(buffer), drawbuffer, reinterpret_cast<const GLint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void clear_named_framebufferuiv(u32 framebuffer, groups::buffer buffer, i32 drawbuffer, span_const_u32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClearNamedFramebufferuiv)
                Throw(undefined_behavior(
                    "unloaded function ClearNamedFramebufferuiv"));
        glIsFramebuffer(framebuffer);
    }
    glClearNamedFramebufferuiv(framebuffer, static_cast<GLenum>(buffer), drawbuffer, reinterpret_cast<const GLuint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void create_framebuffers(span_u32 framebuffers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreateFramebuffers)
                Throw(undefined_behavior(
                    "unloaded function CreateFramebuffers"));
    }
    glCreateFramebuffers(framebuffers.size(), reinterpret_cast<GLuint *>(framebuffers.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_named_framebuffer_attachment_parameter(u32 framebuffer, groups::framebuffer_attachment attachment, groups::framebuffer_attachment_parameter_name pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetNamedFramebufferAttachmentParameteriv)
                Throw(undefined_behavior(
                    "unloaded function GetNamedFramebufferAttachmentParameteriv"));
        glIsFramebuffer(framebuffer);
    }
    glGetNamedFramebufferAttachmentParameteriv(framebuffer, static_cast<GLenum>(attachment), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_named_framebuffer_parameter(u32 framebuffer, groups::get_framebuffer_parameter pname, span_i32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetNamedFramebufferParameteriv)
                Throw(undefined_behavior(
                    "unloaded function GetNamedFramebufferParameteriv"));
        glIsFramebuffer(framebuffer);
    }
    glGetNamedFramebufferParameteriv(framebuffer, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLenum
>
requires (
    semantic::concepts::Span<span_const_GLenum> &&
    std::is_same_v<std::decay_t<typename span_const_GLenum::value_type>, GLenum>)
STATICINLINE void invalidate_named_framebuffer_data(u32 framebuffer, i32 numAttachments, span_const_GLenum const& attachments)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glInvalidateNamedFramebufferData)
                Throw(undefined_behavior(
                    "unloaded function InvalidateNamedFramebufferData"));
        glIsFramebuffer(framebuffer);
    }
    glInvalidateNamedFramebufferData(framebuffer, numAttachments, reinterpret_cast<const GLenum *>(attachments.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLenum,
    class vec_2_i32
>
requires (
    semantic::concepts::Span<span_const_GLenum> &&
    std::is_same_v<std::decay_t<typename span_const_GLenum::value_type>, GLenum> &&
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void invalidate_named_framebuffer_sub_data(u32 framebuffer, i32 numAttachments, span_const_GLenum const& attachments, vec_2_i32 const& x, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glInvalidateNamedFramebufferSubData)
                Throw(undefined_behavior(
                    "unloaded function InvalidateNamedFramebufferSubData"));
        glIsFramebuffer(framebuffer);
    }
    glInvalidateNamedFramebufferSubData(framebuffer, numAttachments, reinterpret_cast<const GLenum *>(attachments.data()), x.x(), x.y(), width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void named_framebuffer_draw_buffer(u32 framebuffer, groups::color_buffer buf)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedFramebufferDrawBuffer)
                Throw(undefined_behavior(
                    "unloaded function NamedFramebufferDrawBuffer"));
        glIsFramebuffer(framebuffer);
    }
    glNamedFramebufferDrawBuffer(framebuffer, static_cast<GLenum>(buf));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLenum
>
requires (
    semantic::concepts::Span<span_const_GLenum> &&
    std::is_same_v<std::decay_t<typename span_const_GLenum::value_type>, GLenum>)
STATICINLINE void named_framebuffer_draw_buffers(u32 framebuffer, i32 n, span_const_GLenum const& bufs)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedFramebufferDrawBuffers)
                Throw(undefined_behavior(
                    "unloaded function NamedFramebufferDrawBuffers"));
        glIsFramebuffer(framebuffer);
    }
    glNamedFramebufferDrawBuffers(framebuffer, n, reinterpret_cast<const GLenum *>(bufs.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void named_framebuffer_parameter(u32 framebuffer, groups::framebuffer_parameter_name pname, i32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedFramebufferParameteri)
                Throw(undefined_behavior(
                    "unloaded function NamedFramebufferParameteri"));
        glIsFramebuffer(framebuffer);
    }
    glNamedFramebufferParameteri(framebuffer, static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void named_framebuffer_read_buffer(u32 framebuffer, groups::color_buffer src)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedFramebufferReadBuffer)
                Throw(undefined_behavior(
                    "unloaded function NamedFramebufferReadBuffer"));
        glIsFramebuffer(framebuffer);
    }
    glNamedFramebufferReadBuffer(framebuffer, static_cast<GLenum>(src));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void named_framebuffer_renderbuffer(u32 framebuffer, groups::framebuffer_attachment attachment, groups::renderbuffer_target renderbuffertarget, u32 renderbuffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedFramebufferRenderbuffer)
                Throw(undefined_behavior(
                    "unloaded function NamedFramebufferRenderbuffer"));
        glIsFramebuffer(framebuffer);
        glIsRenderbuffer(renderbuffer);
    }
    glNamedFramebufferRenderbuffer(framebuffer, static_cast<GLenum>(attachment), static_cast<GLenum>(renderbuffertarget), renderbuffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void named_framebuffer_texture(u32 framebuffer, groups::framebuffer_attachment attachment, u32 texture, i32 level)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedFramebufferTexture)
                Throw(undefined_behavior(
                    "unloaded function NamedFramebufferTexture"));
        glIsFramebuffer(framebuffer);
        glIsTexture(texture);
    }
    glNamedFramebufferTexture(framebuffer, static_cast<GLenum>(attachment), texture, level);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void named_framebuffer_texture_layer(u32 framebuffer, groups::framebuffer_attachment attachment, u32 texture, i32 level, i32 layer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedFramebufferTextureLayer)
                Throw(undefined_behavior(
                    "unloaded function NamedFramebufferTextureLayer"));
        glIsFramebuffer(framebuffer);
        glIsTexture(texture);
    }
    glNamedFramebufferTextureLayer(framebuffer, static_cast<GLenum>(attachment), texture, level, layer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void create_renderbuffers(span_u32 renderbuffers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreateRenderbuffers)
                Throw(undefined_behavior(
                    "unloaded function CreateRenderbuffers"));
    }
    glCreateRenderbuffers(renderbuffers.size(), reinterpret_cast<GLuint *>(renderbuffers.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_named_renderbuffer_parameter(u32 renderbuffer, groups::renderbuffer_parameter_name pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetNamedRenderbufferParameteriv)
                Throw(undefined_behavior(
                    "unloaded function GetNamedRenderbufferParameteriv"));
        glIsRenderbuffer(renderbuffer);
    }
    glGetNamedRenderbufferParameteriv(renderbuffer, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void named_renderbuffer_storage(u32 renderbuffer, groups::internal_format internalformat, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedRenderbufferStorage)
                Throw(undefined_behavior(
                    "unloaded function NamedRenderbufferStorage"));
        glIsRenderbuffer(renderbuffer);
    }
    glNamedRenderbufferStorage(renderbuffer, static_cast<GLenum>(internalformat), width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void named_renderbuffer_storage_multisample(u32 renderbuffer, i32 samples, groups::internal_format internalformat, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedRenderbufferStorageMultisample)
                Throw(undefined_behavior(
                    "unloaded function NamedRenderbufferStorageMultisample"));
        glIsRenderbuffer(renderbuffer);
    }
    glNamedRenderbufferStorageMultisample(renderbuffer, samples, static_cast<GLenum>(internalformat), width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void bind_texture_unit(u32 unit, u32 texture)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindTextureUnit)
                Throw(undefined_behavior(
                    "unloaded function BindTextureUnit"));
        glIsTexture(texture);
    }
    glBindTextureUnit(unit, texture);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void compressed_texture_sub_image_1d(u32 texture, i32 level, i32 xoffset, i32 width, groups::pixel_format format, i32 imageSize, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCompressedTextureSubImage1D)
                Throw(undefined_behavior(
                    "unloaded function CompressedTextureSubImage1D"));
        glIsTexture(texture);
    }
    glCompressedTextureSubImage1D(texture, level, xoffset, width, static_cast<GLenum>(format), imageSize, reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void compressed_texture_sub_image_2d(u32 texture, i32 level, vec_2_i32 const& xoffset, vec_2_i32 const& width, groups::pixel_format format, i32 imageSize, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCompressedTextureSubImage2D)
                Throw(undefined_behavior(
                    "unloaded function CompressedTextureSubImage2D"));
        glIsTexture(texture);
    }
    glCompressedTextureSubImage2D(texture, level, xoffset.x(), xoffset.y(), width[0], width[1], static_cast<GLenum>(format), imageSize, reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void compressed_texture_sub_image_3d(u32 texture, i32 level, vec_3_i32 const& xoffset, vec_3_i32 const& width, groups::pixel_format format, i32 imageSize, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCompressedTextureSubImage3D)
                Throw(undefined_behavior(
                    "unloaded function CompressedTextureSubImage3D"));
        glIsTexture(texture);
    }
    glCompressedTextureSubImage3D(texture, level, xoffset.x(), xoffset.y(), xoffset.z(), width[0], width[1], width[2], static_cast<GLenum>(format), imageSize, reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void copy_texture_sub_image_1d(u32 texture, i32 level, i32 xoffset, vec_2_i32 const& x, i32 width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCopyTextureSubImage1D)
                Throw(undefined_behavior(
                    "unloaded function CopyTextureSubImage1D"));
        glIsTexture(texture);
    }
    glCopyTextureSubImage1D(texture, level, xoffset, x.x(), x.y(), width);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void copy_texture_sub_image_2d(u32 texture, i32 level, vec_2_i32 const& xoffset, vec_2_i32 const& x, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCopyTextureSubImage2D)
                Throw(undefined_behavior(
                    "unloaded function CopyTextureSubImage2D"));
        glIsTexture(texture);
    }
    glCopyTextureSubImage2D(texture, level, xoffset.x(), xoffset.y(), x.x(), x.y(), width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32,
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3> &&
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void copy_texture_sub_image_3d(u32 texture, i32 level, vec_3_i32 const& xoffset, vec_2_i32 const& x, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCopyTextureSubImage3D)
                Throw(undefined_behavior(
                    "unloaded function CopyTextureSubImage3D"));
        glIsTexture(texture);
    }
    glCopyTextureSubImage3D(texture, level, xoffset.x(), xoffset.y(), xoffset.z(), x.x(), x.y(), width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void create_textures(GLenum target, span_u32 textures)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreateTextures)
                Throw(undefined_behavior(
                    "unloaded function CreateTextures"));
    }
    glCreateTextures(target, textures.size(), reinterpret_cast<GLuint *>(textures.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void generate_texture_mipmap(u32 texture)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenerateTextureMipmap)
                Throw(undefined_behavior(
                    "unloaded function GenerateTextureMipmap"));
        glIsTexture(texture);
    }
    glGenerateTextureMipmap(texture);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_compressed_texture_image(u32 texture, i32 level, i32 bufSize, span_byte pixels)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetCompressedTextureImage)
                Throw(undefined_behavior(
                    "unloaded function GetCompressedTextureImage"));
        glIsTexture(texture);
    }
    glGetCompressedTextureImage(texture, level, bufSize, reinterpret_cast<void *>(pixels.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_texture_image(u32 texture, i32 level, groups::pixel_format format, groups::pixel_type type, i32 bufSize, span_byte pixels)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTextureImage)
                Throw(undefined_behavior(
                    "unloaded function GetTextureImage"));
        glIsTexture(texture);
    }
    glGetTextureImage(texture, level, static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, reinterpret_cast<void *>(pixels.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_texture_level_parameter(u32 texture, i32 level, groups::get_texture_parameter pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTextureLevelParameterfv)
                Throw(undefined_behavior(
                    "unloaded function GetTextureLevelParameterfv"));
        glIsTexture(texture);
    }
    glGetTextureLevelParameterfv(texture, level, static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_texture_level_parameter(u32 texture, i32 level, groups::get_texture_parameter pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTextureLevelParameteriv)
                Throw(undefined_behavior(
                    "unloaded function GetTextureLevelParameteriv"));
        glIsTexture(texture);
    }
    glGetTextureLevelParameteriv(texture, level, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_texture_parameter_iiv(u32 texture, groups::get_texture_parameter pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTextureParameterIiv)
                Throw(undefined_behavior(
                    "unloaded function GetTextureParameterIiv"));
        glIsTexture(texture);
    }
    glGetTextureParameterIiv(texture, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_texture_parameter_iuiv(u32 texture, groups::get_texture_parameter pname, span_u32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTextureParameterIuiv)
                Throw(undefined_behavior(
                    "unloaded function GetTextureParameterIuiv"));
        glIsTexture(texture);
    }
    glGetTextureParameterIuiv(texture, static_cast<GLenum>(pname), reinterpret_cast<GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_texture_parameter(u32 texture, groups::get_texture_parameter pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTextureParameterfv)
                Throw(undefined_behavior(
                    "unloaded function GetTextureParameterfv"));
        glIsTexture(texture);
    }
    glGetTextureParameterfv(texture, static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_texture_parameter(u32 texture, groups::get_texture_parameter pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTextureParameteriv)
                Throw(undefined_behavior(
                    "unloaded function GetTextureParameteriv"));
        glIsTexture(texture);
    }
    glGetTextureParameteriv(texture, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void texture_buffer(u32 texture, groups::sized_internal_format internalformat, u32 buffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureBuffer)
                Throw(undefined_behavior(
                    "unloaded function TextureBuffer"));
        glIsTexture(texture);
        glIsBuffer(buffer);
    }
    glTextureBuffer(texture, static_cast<GLenum>(internalformat), buffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void texture_buffer_range(u32 texture, groups::sized_internal_format internalformat, u32 buffer, GLintptr offset, GLsizeiptr size)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureBufferRange)
                Throw(undefined_behavior(
                    "unloaded function TextureBufferRange"));
        glIsTexture(texture);
        glIsBuffer(buffer);
    }
    glTextureBufferRange(texture, static_cast<GLenum>(internalformat), buffer, offset, size);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void texture_parameter_iiv(u32 texture, groups::texture_parameter_name pname, span_const_i32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureParameterIiv)
                Throw(undefined_behavior(
                    "unloaded function TextureParameterIiv"));
        glIsTexture(texture);
    }
    glTextureParameterIiv(texture, static_cast<GLenum>(pname), reinterpret_cast<const GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void texture_parameter_iuiv(u32 texture, groups::texture_parameter_name pname, span_const_u32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureParameterIuiv)
                Throw(undefined_behavior(
                    "unloaded function TextureParameterIuiv"));
        glIsTexture(texture);
    }
    glTextureParameterIuiv(texture, static_cast<GLenum>(pname), reinterpret_cast<const GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void texture_parameter(u32 texture, groups::texture_parameter_name pname, f32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureParameterf)
                Throw(undefined_behavior(
                    "unloaded function TextureParameterf"));
        glIsTexture(texture);
    }
    glTextureParameterf(texture, static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void texture_parameter(u32 texture, groups::texture_parameter_name pname, span_const_f32 const& param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureParameterfv)
                Throw(undefined_behavior(
                    "unloaded function TextureParameterfv"));
        glIsTexture(texture);
    }
    glTextureParameterfv(texture, static_cast<GLenum>(pname), reinterpret_cast<const GLfloat *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void texture_parameter(u32 texture, groups::texture_parameter_name pname, i32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureParameteri)
                Throw(undefined_behavior(
                    "unloaded function TextureParameteri"));
        glIsTexture(texture);
    }
    glTextureParameteri(texture, static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void texture_parameter(u32 texture, groups::texture_parameter_name pname, span_const_i32 const& param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureParameteriv)
                Throw(undefined_behavior(
                    "unloaded function TextureParameteriv"));
        glIsTexture(texture);
    }
    glTextureParameteriv(texture, static_cast<GLenum>(pname), reinterpret_cast<const GLint *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void texture_storage_1d(u32 texture, i32 levels, groups::sized_internal_format internalformat, i32 width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureStorage1D)
                Throw(undefined_behavior(
                    "unloaded function TextureStorage1D"));
        glIsTexture(texture);
    }
    glTextureStorage1D(texture, levels, static_cast<GLenum>(internalformat), width);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void texture_storage_2d(u32 texture, i32 levels, groups::sized_internal_format internalformat, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureStorage2D)
                Throw(undefined_behavior(
                    "unloaded function TextureStorage2D"));
        glIsTexture(texture);
    }
    glTextureStorage2D(texture, levels, static_cast<GLenum>(internalformat), width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void texture_storage_2d_multisample(u32 texture, i32 samples, groups::sized_internal_format internalformat, vec_2_i32 const& width, bool fixedsamplelocations)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureStorage2DMultisample)
                Throw(undefined_behavior(
                    "unloaded function TextureStorage2DMultisample"));
        glIsTexture(texture);
    }
    glTextureStorage2DMultisample(texture, samples, static_cast<GLenum>(internalformat), width[0], width[1], fixedsamplelocations);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void texture_storage_3d(u32 texture, i32 levels, groups::sized_internal_format internalformat, vec_3_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureStorage3D)
                Throw(undefined_behavior(
                    "unloaded function TextureStorage3D"));
        glIsTexture(texture);
    }
    glTextureStorage3D(texture, levels, static_cast<GLenum>(internalformat), width[0], width[1], width[2]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void texture_storage_3d_multisample(u32 texture, i32 samples, groups::sized_internal_format internalformat, vec_3_i32 const& width, bool fixedsamplelocations)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureStorage3DMultisample)
                Throw(undefined_behavior(
                    "unloaded function TextureStorage3DMultisample"));
        glIsTexture(texture);
    }
    glTextureStorage3DMultisample(texture, samples, static_cast<GLenum>(internalformat), width[0], width[1], width[2], fixedsamplelocations);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void texture_sub_image_1d(u32 texture, i32 level, i32 xoffset, i32 width, groups::pixel_format format, groups::pixel_type type, span_const_byte const& pixels)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureSubImage1D)
                Throw(undefined_behavior(
                    "unloaded function TextureSubImage1D"));
        glIsTexture(texture);
    }
    glTextureSubImage1D(texture, level, xoffset, width, static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<const void *>(pixels.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void texture_sub_image_2d(u32 texture, i32 level, vec_2_i32 const& xoffset, vec_2_i32 const& width, groups::pixel_format format, groups::pixel_type type, span_const_byte const& pixels)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureSubImage2D)
                Throw(undefined_behavior(
                    "unloaded function TextureSubImage2D"));
        glIsTexture(texture);
    }
    glTextureSubImage2D(texture, level, xoffset.x(), xoffset.y(), width[0], width[1], static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<const void *>(pixels.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void texture_sub_image_3d(u32 texture, i32 level, vec_3_i32 const& xoffset, vec_3_i32 const& width, groups::pixel_format format, groups::pixel_type type, span_const_byte const& pixels)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureSubImage3D)
                Throw(undefined_behavior(
                    "unloaded function TextureSubImage3D"));
        glIsTexture(texture);
    }
    glTextureSubImage3D(texture, level, xoffset.x(), xoffset.y(), xoffset.z(), width[0], width[1], width[2], static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<const void *>(pixels.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void create_vertex_arrays(span_u32 arrays)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreateVertexArrays)
                Throw(undefined_behavior(
                    "unloaded function CreateVertexArrays"));
    }
    glCreateVertexArrays(arrays.size(), reinterpret_cast<GLuint *>(arrays.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void disable_vertex_array_attrib(u32 vaobj, u32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDisableVertexArrayAttrib)
                Throw(undefined_behavior(
                    "unloaded function DisableVertexArrayAttrib"));
        glIsVertexArray(vaobj);
    }
    glDisableVertexArrayAttrib(vaobj, index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void enable_vertex_array_attrib(u32 vaobj, u32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEnableVertexArrayAttrib)
                Throw(undefined_behavior(
                    "unloaded function EnableVertexArrayAttrib"));
        glIsVertexArray(vaobj);
    }
    glEnableVertexArrayAttrib(vaobj, index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i64
>
requires (
    semantic::concepts::Span<span_i64> &&
    std::is_same_v<std::decay_t<typename span_i64::value_type>, i64>)
STATICINLINE void get_vertex_array_indexed64iv(u32 vaobj, u32 index, groups::vertex_array_prop pname, span_i64 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexArrayIndexed64iv)
                Throw(undefined_behavior(
                    "unloaded function GetVertexArrayIndexed64iv"));
        glIsVertexArray(vaobj);
    }
    glGetVertexArrayIndexed64iv(vaobj, index, static_cast<GLenum>(pname), reinterpret_cast<GLint64 *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_vertex_array_indexediv(u32 vaobj, u32 index, groups::vertex_array_prop pname, span_i32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexArrayIndexediv)
                Throw(undefined_behavior(
                    "unloaded function GetVertexArrayIndexediv"));
        glIsVertexArray(vaobj);
    }
    glGetVertexArrayIndexediv(vaobj, index, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_vertex_arrayiv(u32 vaobj, groups::vertex_array_prop pname, span_i32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexArrayiv)
                Throw(undefined_behavior(
                    "unloaded function GetVertexArrayiv"));
        glIsVertexArray(vaobj);
    }
    glGetVertexArrayiv(vaobj, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_array_attrib_binding(u32 vaobj, u32 attribindex, u32 bindingindex)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexArrayAttribBinding)
                Throw(undefined_behavior(
                    "unloaded function VertexArrayAttribBinding"));
        glIsVertexArray(vaobj);
    }
    glVertexArrayAttribBinding(vaobj, attribindex, bindingindex);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_array_attrib_format(u32 vaobj, u32 attribindex, i32 size, groups::vertex_attrib_type type, bool normalized, u32 relativeoffset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexArrayAttribFormat)
                Throw(undefined_behavior(
                    "unloaded function VertexArrayAttribFormat"));
        glIsVertexArray(vaobj);
    }
    glVertexArrayAttribFormat(vaobj, attribindex, size, static_cast<GLenum>(type), normalized, relativeoffset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_array_attrib_i_format(u32 vaobj, u32 attribindex, i32 size, groups::vertex_attrib_int type, u32 relativeoffset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexArrayAttribIFormat)
                Throw(undefined_behavior(
                    "unloaded function VertexArrayAttribIFormat"));
        glIsVertexArray(vaobj);
    }
    glVertexArrayAttribIFormat(vaobj, attribindex, size, static_cast<GLenum>(type), relativeoffset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_array_attrib_l_format(u32 vaobj, u32 attribindex, i32 size, groups::vertex_attrib_long type, u32 relativeoffset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexArrayAttribLFormat)
                Throw(undefined_behavior(
                    "unloaded function VertexArrayAttribLFormat"));
        glIsVertexArray(vaobj);
    }
    glVertexArrayAttribLFormat(vaobj, attribindex, size, static_cast<GLenum>(type), relativeoffset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_array_binding_divisor(u32 vaobj, u32 bindingindex, u32 divisor)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexArrayBindingDivisor)
                Throw(undefined_behavior(
                    "unloaded function VertexArrayBindingDivisor"));
        glIsVertexArray(vaobj);
    }
    glVertexArrayBindingDivisor(vaobj, bindingindex, divisor);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_array_element_buffer(u32 vaobj, u32 buffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexArrayElementBuffer)
                Throw(undefined_behavior(
                    "unloaded function VertexArrayElementBuffer"));
        glIsVertexArray(vaobj);
        glIsBuffer(buffer);
    }
    glVertexArrayElementBuffer(vaobj, buffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_array_vertex_buffer(u32 vaobj, u32 bindingindex, u32 buffer, GLintptr offset, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexArrayVertexBuffer)
                Throw(undefined_behavior(
                    "unloaded function VertexArrayVertexBuffer"));
        glIsVertexArray(vaobj);
        glIsBuffer(buffer);
    }
    glVertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLintptr,
    class span_const_i32,
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32> &&
    semantic::concepts::Span<span_const_GLintptr> &&
    std::is_same_v<std::decay_t<typename span_const_GLintptr::value_type>, GLintptr> &&
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void vertex_array_vertex_buffers(u32 vaobj, u32 first, i32 count, span_const_u32 const& buffers, span_const_GLintptr const& offsets, span_const_i32 const& strides)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexArrayVertexBuffers)
                Throw(undefined_behavior(
                    "unloaded function VertexArrayVertexBuffers"));
        glIsVertexArray(vaobj);
    }
    glVertexArrayVertexBuffers(vaobj, first, count, reinterpret_cast<const GLuint *>(buffers.data()), reinterpret_cast<const GLintptr *>(offsets.data()), reinterpret_cast<const GLsizei *>(strides.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void create_samplers(span_u32 samplers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreateSamplers)
                Throw(undefined_behavior(
                    "unloaded function CreateSamplers"));
    }
    glCreateSamplers(samplers.size(), reinterpret_cast<GLuint *>(samplers.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void create_program_pipelines(span_u32 pipelines)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreateProgramPipelines)
                Throw(undefined_behavior(
                    "unloaded function CreateProgramPipelines"));
    }
    glCreateProgramPipelines(pipelines.size(), reinterpret_cast<GLuint *>(pipelines.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void create_queries(GLenum target, span_u32 ids)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreateQueries)
                Throw(undefined_behavior(
                    "unloaded function CreateQueries"));
    }
    glCreateQueries(target, ids.size(), reinterpret_cast<GLuint *>(ids.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void get_query_buffer_objecti64v(u32 id, u32 buffer, groups::query_object_parameter_name pname, GLintptr offset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetQueryBufferObjecti64v)
                Throw(undefined_behavior(
                    "unloaded function GetQueryBufferObjecti64v"));
        glIsBuffer(buffer);
    }
    glGetQueryBufferObjecti64v(id, buffer, static_cast<GLenum>(pname), offset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void get_query_buffer_objectiv(u32 id, u32 buffer, groups::query_object_parameter_name pname, GLintptr offset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetQueryBufferObjectiv)
                Throw(undefined_behavior(
                    "unloaded function GetQueryBufferObjectiv"));
        glIsBuffer(buffer);
    }
    glGetQueryBufferObjectiv(id, buffer, static_cast<GLenum>(pname), offset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void get_query_buffer_objectui64v(u32 id, u32 buffer, groups::query_object_parameter_name pname, GLintptr offset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetQueryBufferObjectui64v)
                Throw(undefined_behavior(
                    "unloaded function GetQueryBufferObjectui64v"));
        glIsBuffer(buffer);
    }
    glGetQueryBufferObjectui64v(id, buffer, static_cast<GLenum>(pname), offset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void get_query_buffer_objectuiv(u32 id, u32 buffer, groups::query_object_parameter_name pname, GLintptr offset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetQueryBufferObjectuiv)
                Throw(undefined_behavior(
                    "unloaded function GetQueryBufferObjectuiv"));
        glIsBuffer(buffer);
    }
    glGetQueryBufferObjectuiv(id, buffer, static_cast<GLenum>(pname), offset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_direct_state_access
#endif // GL_ARB_direct_state_access
#ifdef GL_ARB_draw_buffers
namespace arb_draw_buffers {
constexpr u32 max_draw_buffers_arb = 0x8824;
constexpr u32 draw_buffer0_arb = 0x8825;
constexpr u32 draw_buffer1_arb = 0x8826;
constexpr u32 draw_buffer2_arb = 0x8827;
constexpr u32 draw_buffer3_arb = 0x8828;
constexpr u32 draw_buffer4_arb = 0x8829;
constexpr u32 draw_buffer5_arb = 0x882A;
constexpr u32 draw_buffer6_arb = 0x882B;
constexpr u32 draw_buffer7_arb = 0x882C;
constexpr u32 draw_buffer8_arb = 0x882D;
constexpr u32 draw_buffer9_arb = 0x882E;
constexpr u32 draw_buffer10_arb = 0x882F;
constexpr u32 draw_buffer11_arb = 0x8830;
constexpr u32 draw_buffer12_arb = 0x8831;
constexpr u32 draw_buffer13_arb = 0x8832;
constexpr u32 draw_buffer14_arb = 0x8833;
constexpr u32 draw_buffer15_arb = 0x8834;
template<
    class span_const_GLenum
>
requires (
    semantic::concepts::Span<span_const_GLenum> &&
    std::is_same_v<std::decay_t<typename span_const_GLenum::value_type>, GLenum>)
STATICINLINE void draw_buffers_arb(span_const_GLenum const& bufs)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawBuffersARB)
                Throw(undefined_behavior(
                    "unloaded function DrawBuffersARB"));
    }
    glDrawBuffersARB(bufs.size(), reinterpret_cast<const GLenum *>(bufs.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_draw_buffers
#endif // GL_ARB_draw_buffers
#ifdef GL_ARB_draw_buffers_blend
namespace arb_draw_buffers_blend {
STATICINLINE void blend_equation_separatei_arb(u32 buf, groups::blend_equation_mode_ext modeRGB, groups::blend_equation_mode_ext modeAlpha)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendEquationSeparateiARB)
                Throw(undefined_behavior(
                    "unloaded function BlendEquationSeparateiARB"));
    }
    glBlendEquationSeparateiARB(buf, static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void blend_equationi_arb(u32 buf, groups::blend_equation_mode_ext mode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendEquationiARB)
                Throw(undefined_behavior(
                    "unloaded function BlendEquationiARB"));
    }
    glBlendEquationiARB(buf, static_cast<GLenum>(mode));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void blend_func_separatei_arb(u32 buf, groups::blending_factor srcRGB, groups::blending_factor dstRGB, groups::blending_factor srcAlpha, groups::blending_factor dstAlpha)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendFuncSeparateiARB)
                Throw(undefined_behavior(
                    "unloaded function BlendFuncSeparateiARB"));
    }
    glBlendFuncSeparateiARB(buf, static_cast<GLenum>(srcRGB), static_cast<GLenum>(dstRGB), static_cast<GLenum>(srcAlpha), static_cast<GLenum>(dstAlpha));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void blend_funci_arb(u32 buf, groups::blending_factor src, groups::blending_factor dst)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendFunciARB)
                Throw(undefined_behavior(
                    "unloaded function BlendFunciARB"));
    }
    glBlendFunciARB(buf, static_cast<GLenum>(src), static_cast<GLenum>(dst));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_draw_buffers_blend
#endif // GL_ARB_draw_buffers_blend
#ifdef GL_ARB_draw_elements_base_vertex
namespace arb_draw_elements_base_vertex {
STATICINLINE void draw_elements_base_vertex(groups::primitive_type mode, i32 count, groups::draw_elements_type type, ptroff indices, i32 basevertex)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawElementsBaseVertex)
                Throw(undefined_behavior(
                    "unloaded function DrawElementsBaseVertex"));
    }
    glDrawElementsBaseVertex(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), reinterpret_cast<const void*>(indices), basevertex);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void draw_elements_instanced_base_vertex(groups::primitive_type mode, i32 count, groups::draw_elements_type type, ptroff indices, i32 instancecount, i32 basevertex)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawElementsInstancedBaseVertex)
                Throw(undefined_behavior(
                    "unloaded function DrawElementsInstancedBaseVertex"));
    }
    glDrawElementsInstancedBaseVertex(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), reinterpret_cast<const void*>(indices), instancecount, basevertex);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void draw_range_elements_base_vertex(groups::primitive_type mode, u32 start, u32 end, i32 count, groups::draw_elements_type type, span_const_byte const& indices, i32 basevertex)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawRangeElementsBaseVertex)
                Throw(undefined_behavior(
                    "unloaded function DrawRangeElementsBaseVertex"));
    }
    glDrawRangeElementsBaseVertex(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), reinterpret_cast<const void *>(indices.data()), basevertex);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void multi_draw_elements_base_vertex(groups::primitive_type mode, span_const_i32 count, groups::draw_elements_type type, ptroff indices, span_const_i32 basevertex)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiDrawElementsBaseVertex)
                Throw(undefined_behavior(
                    "unloaded function MultiDrawElementsBaseVertex"));
    }
    GLsizei drawcount = count.size();
    detail::assert_equal(count.size(), drawcount);
    detail::assert_equal(basevertex.size(), drawcount);
    glMultiDrawElementsBaseVertex(static_cast<GLenum>(mode), count.data(), static_cast<GLenum>(type), reinterpret_cast<const void*>(indices), basevertex.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_draw_elements_base_vertex
#endif // GL_ARB_draw_elements_base_vertex
#ifdef GL_ARB_draw_indirect
namespace arb_draw_indirect {
constexpr u32 draw_indirect_buffer = 0x8F3F;
constexpr u32 draw_indirect_buffer_binding = 0x8F43;
STATICINLINE void draw_arrays_indirect(groups::primitive_type mode, ptroff indirect)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawArraysIndirect)
                Throw(undefined_behavior(
                    "unloaded function DrawArraysIndirect"));
    }
    glDrawArraysIndirect(static_cast<GLenum>(mode), reinterpret_cast<const void*>(indirect));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void draw_elements_indirect(groups::primitive_type mode, groups::draw_elements_type type, ptroff indirect)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawElementsIndirect)
                Throw(undefined_behavior(
                    "unloaded function DrawElementsIndirect"));
    }
    glDrawElementsIndirect(static_cast<GLenum>(mode), static_cast<GLenum>(type), reinterpret_cast<const void*>(indirect));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_draw_indirect
#endif // GL_ARB_draw_indirect
#ifdef GL_ARB_draw_instanced
namespace arb_draw_instanced {
STATICINLINE void draw_arrays_instanced_arb(groups::primitive_type mode, i32 first, i32 count, i32 primcount)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawArraysInstancedARB)
                Throw(undefined_behavior(
                    "unloaded function DrawArraysInstancedARB"));
    }
    glDrawArraysInstancedARB(static_cast<GLenum>(mode), first, count, primcount);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void draw_elements_instanced_arb(groups::primitive_type mode, i32 count, groups::draw_elements_type type, ptroff indices, i32 primcount)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawElementsInstancedARB)
                Throw(undefined_behavior(
                    "unloaded function DrawElementsInstancedARB"));
    }
    glDrawElementsInstancedARB(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), reinterpret_cast<const void*>(indices), primcount);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_draw_instanced
#endif // GL_ARB_draw_instanced
#ifdef GL_ARB_enhanced_layouts
namespace arb_enhanced_layouts {
constexpr u32 transform_feedback_buffer = 0x8C8E;
constexpr u32 location_component = 0x934A;
constexpr u32 transform_feedback_buffer_index = 0x934B;
constexpr u32 transform_feedback_buffer_stride = 0x934C;
} // arb_enhanced_layouts
#endif // GL_ARB_enhanced_layouts
#ifdef GL_ARB_explicit_attrib_location
namespace arb_explicit_attrib_location {
} // arb_explicit_attrib_location
#endif // GL_ARB_explicit_attrib_location
#ifdef GL_ARB_explicit_uniform_location
namespace arb_explicit_uniform_location {
constexpr u32 max_uniform_locations = 0x826E;
} // arb_explicit_uniform_location
#endif // GL_ARB_explicit_uniform_location
#ifdef GL_ARB_fragment_coord_conventions
namespace arb_fragment_coord_conventions {
} // arb_fragment_coord_conventions
#endif // GL_ARB_fragment_coord_conventions
#ifdef GL_ARB_fragment_layer_viewport
namespace arb_fragment_layer_viewport {
} // arb_fragment_layer_viewport
#endif // GL_ARB_fragment_layer_viewport
#ifdef GL_ARB_fragment_program
namespace arb_fragment_program {
constexpr u32 program_length_arb = 0x8627;
constexpr u32 program_string_arb = 0x8628;
constexpr u32 max_program_matrix_stack_depth_arb = 0x862E;
constexpr u32 max_program_matrices_arb = 0x862F;
constexpr u32 current_matrix_stack_depth_arb = 0x8640;
constexpr u32 current_matrix_arb = 0x8641;
constexpr u32 program_error_position_arb = 0x864B;
constexpr u32 program_binding_arb = 0x8677;
constexpr u32 fragment_program_arb = 0x8804;
constexpr u32 program_alu_instructions_arb = 0x8805;
constexpr u32 program_tex_instructions_arb = 0x8806;
constexpr u32 program_tex_indirections_arb = 0x8807;
constexpr u32 program_native_alu_instructions_arb = 0x8808;
constexpr u32 program_native_tex_instructions_arb = 0x8809;
constexpr u32 program_native_tex_indirections_arb = 0x880A;
constexpr u32 max_program_alu_instructions_arb = 0x880B;
constexpr u32 max_program_tex_instructions_arb = 0x880C;
constexpr u32 max_program_tex_indirections_arb = 0x880D;
constexpr u32 max_program_native_alu_instructions_arb = 0x880E;
constexpr u32 max_program_native_tex_instructions_arb = 0x880F;
constexpr u32 max_program_native_tex_indirections_arb = 0x8810;
constexpr u32 max_texture_coords_arb = 0x8871;
constexpr u32 max_texture_image_units_arb = 0x8872;
constexpr u32 program_error_string_arb = 0x8874;
constexpr u32 program_format_ascii_arb = 0x8875;
constexpr u32 program_format_arb = 0x8876;
constexpr u32 program_instructions_arb = 0x88A0;
constexpr u32 max_program_instructions_arb = 0x88A1;
constexpr u32 program_native_instructions_arb = 0x88A2;
constexpr u32 max_program_native_instructions_arb = 0x88A3;
constexpr u32 program_temporaries_arb = 0x88A4;
constexpr u32 max_program_temporaries_arb = 0x88A5;
constexpr u32 program_native_temporaries_arb = 0x88A6;
constexpr u32 max_program_native_temporaries_arb = 0x88A7;
constexpr u32 program_parameters_arb = 0x88A8;
constexpr u32 max_program_parameters_arb = 0x88A9;
constexpr u32 program_native_parameters_arb = 0x88AA;
constexpr u32 max_program_native_parameters_arb = 0x88AB;
constexpr u32 program_attribs_arb = 0x88AC;
constexpr u32 max_program_attribs_arb = 0x88AD;
constexpr u32 program_native_attribs_arb = 0x88AE;
constexpr u32 max_program_native_attribs_arb = 0x88AF;
constexpr u32 max_program_local_parameters_arb = 0x88B4;
constexpr u32 max_program_env_parameters_arb = 0x88B5;
constexpr u32 program_under_native_limits_arb = 0x88B6;
constexpr u32 transpose_current_matrix_arb = 0x88B7;
constexpr u32 matrix0_arb = 0x88C0;
constexpr u32 matrix1_arb = 0x88C1;
constexpr u32 matrix2_arb = 0x88C2;
constexpr u32 matrix3_arb = 0x88C3;
constexpr u32 matrix4_arb = 0x88C4;
constexpr u32 matrix5_arb = 0x88C5;
constexpr u32 matrix6_arb = 0x88C6;
constexpr u32 matrix7_arb = 0x88C7;
constexpr u32 matrix8_arb = 0x88C8;
constexpr u32 matrix9_arb = 0x88C9;
constexpr u32 matrix10_arb = 0x88CA;
constexpr u32 matrix11_arb = 0x88CB;
constexpr u32 matrix12_arb = 0x88CC;
constexpr u32 matrix13_arb = 0x88CD;
constexpr u32 matrix14_arb = 0x88CE;
constexpr u32 matrix15_arb = 0x88CF;
constexpr u32 matrix16_arb = 0x88D0;
constexpr u32 matrix17_arb = 0x88D1;
constexpr u32 matrix18_arb = 0x88D2;
constexpr u32 matrix19_arb = 0x88D3;
constexpr u32 matrix20_arb = 0x88D4;
constexpr u32 matrix21_arb = 0x88D5;
constexpr u32 matrix22_arb = 0x88D6;
constexpr u32 matrix23_arb = 0x88D7;
constexpr u32 matrix24_arb = 0x88D8;
constexpr u32 matrix25_arb = 0x88D9;
constexpr u32 matrix26_arb = 0x88DA;
constexpr u32 matrix27_arb = 0x88DB;
constexpr u32 matrix28_arb = 0x88DC;
constexpr u32 matrix29_arb = 0x88DD;
constexpr u32 matrix30_arb = 0x88DE;
constexpr u32 matrix31_arb = 0x88DF;
STATICINLINE void bind_program_arb(groups::program_target target, u32 program)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindProgramARB)
                Throw(undefined_behavior(
                    "unloaded function BindProgramARB"));
        glIsProgram(program);
    }
    glBindProgramARB(static_cast<GLenum>(target), program);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_programs_arb(span_const_u32 const& programs)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteProgramsARB)
                Throw(undefined_behavior(
                    "unloaded function DeleteProgramsARB"));
    }
    glDeleteProgramsARB(programs.size(), reinterpret_cast<const GLuint *>(programs.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void gen_programs_arb(span_u32 programs)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenProgramsARB)
                Throw(undefined_behavior(
                    "unloaded function GenProgramsARB"));
    }
    glGenProgramsARB(programs.size(), reinterpret_cast<GLuint *>(programs.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f64
>
requires (
    semantic::concepts::Span<span_f64> &&
    std::is_same_v<std::decay_t<typename span_f64::value_type>, f64>)
STATICINLINE void get_program_env_parameterdv_arb(groups::program_target target, u32 index, span_f64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramEnvParameterdvARB)
                Throw(undefined_behavior(
                    "unloaded function GetProgramEnvParameterdvARB"));
    }
    glGetProgramEnvParameterdvARB(static_cast<GLenum>(target), index, reinterpret_cast<GLdouble *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_program_env_parameterfv_arb(groups::program_target target, u32 index, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramEnvParameterfvARB)
                Throw(undefined_behavior(
                    "unloaded function GetProgramEnvParameterfvARB"));
    }
    glGetProgramEnvParameterfvARB(static_cast<GLenum>(target), index, reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f64
>
requires (
    semantic::concepts::Span<span_f64> &&
    std::is_same_v<std::decay_t<typename span_f64::value_type>, f64>)
STATICINLINE void get_program_local_parameterdv_arb(groups::program_target target, u32 index, span_f64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramLocalParameterdvARB)
                Throw(undefined_behavior(
                    "unloaded function GetProgramLocalParameterdvARB"));
    }
    glGetProgramLocalParameterdvARB(static_cast<GLenum>(target), index, reinterpret_cast<GLdouble *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_program_local_parameterfv_arb(groups::program_target target, u32 index, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramLocalParameterfvARB)
                Throw(undefined_behavior(
                    "unloaded function GetProgramLocalParameterfvARB"));
    }
    glGetProgramLocalParameterfvARB(static_cast<GLenum>(target), index, reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_program_string_arb(groups::program_target target, groups::program_string_property pname, span_byte string)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramStringARB)
                Throw(undefined_behavior(
                    "unloaded function GetProgramStringARB"));
    }
    glGetProgramStringARB(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<void *>(string.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void get_programiv_arb(groups::program_target target, groups::program_property_arb pname, i32& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramivARB)
                Throw(undefined_behavior(
                    "unloaded function GetProgramivARB"));
    }
    glGetProgramivARB(static_cast<GLenum>(target), static_cast<GLenum>(pname), &params);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_program_arb(u32 program)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsProgramARB)
                Throw(undefined_behavior(
                    "unloaded function IsProgramARB"));
        glIsProgram(program);
    }
    auto out = glIsProgramARB(program);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class vec_4_f64
>
requires (
    semantic::concepts::Vector<vec_4_f64, f64, 4>)
STATICINLINE void program_env_parameter4d_arb(groups::program_target target, u32 index, vec_4_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramEnvParameter4dARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramEnvParameter4dARB"));
    }
    glProgramEnvParameter4dARB(static_cast<GLenum>(target), index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f64
>
requires (
    semantic::concepts::Span<span_const_vec_4_f64> &&
    semantic::concepts::Vector<typename span_const_vec_4_f64::value_type, f64, 4>)
STATICINLINE void program_env_parameter4dv_arb(groups::program_target target, u32 index, span_const_vec_4_f64 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramEnvParameter4dvARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramEnvParameter4dvARB"));
    }
    glProgramEnvParameter4dvARB(static_cast<GLenum>(target), index, reinterpret_cast<const GLdouble *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f32
>
requires (
    semantic::concepts::Vector<vec_4_f32, f32, 4>)
STATICINLINE void program_env_parameter4f_arb(groups::program_target target, u32 index, vec_4_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramEnvParameter4fARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramEnvParameter4fARB"));
    }
    glProgramEnvParameter4fARB(static_cast<GLenum>(target), index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f32
>
requires (
    semantic::concepts::Span<span_const_vec_4_f32> &&
    semantic::concepts::Vector<typename span_const_vec_4_f32::value_type, f32, 4>)
STATICINLINE void program_env_parameter4fv_arb(groups::program_target target, u32 index, span_const_vec_4_f32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramEnvParameter4fvARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramEnvParameter4fvARB"));
    }
    glProgramEnvParameter4fvARB(static_cast<GLenum>(target), index, reinterpret_cast<const GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f64
>
requires (
    semantic::concepts::Vector<vec_4_f64, f64, 4>)
STATICINLINE void program_local_parameter4d_arb(groups::program_target target, u32 index, vec_4_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramLocalParameter4dARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramLocalParameter4dARB"));
    }
    glProgramLocalParameter4dARB(static_cast<GLenum>(target), index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f64
>
requires (
    semantic::concepts::Span<span_const_vec_4_f64> &&
    semantic::concepts::Vector<typename span_const_vec_4_f64::value_type, f64, 4>)
STATICINLINE void program_local_parameter4dv_arb(groups::program_target target, u32 index, span_const_vec_4_f64 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramLocalParameter4dvARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramLocalParameter4dvARB"));
    }
    glProgramLocalParameter4dvARB(static_cast<GLenum>(target), index, reinterpret_cast<const GLdouble *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f32
>
requires (
    semantic::concepts::Vector<vec_4_f32, f32, 4>)
STATICINLINE void program_local_parameter4f_arb(groups::program_target target, u32 index, vec_4_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramLocalParameter4fARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramLocalParameter4fARB"));
    }
    glProgramLocalParameter4fARB(static_cast<GLenum>(target), index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f32
>
requires (
    semantic::concepts::Span<span_const_vec_4_f32> &&
    semantic::concepts::Vector<typename span_const_vec_4_f32::value_type, f32, 4>)
STATICINLINE void program_local_parameter4fv_arb(groups::program_target target, u32 index, span_const_vec_4_f32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramLocalParameter4fvARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramLocalParameter4fvARB"));
    }
    glProgramLocalParameter4fvARB(static_cast<GLenum>(target), index, reinterpret_cast<const GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void program_string_arb(groups::program_target target, groups::program_format format, span_const_byte const& string)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramStringARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramStringARB"));
    }
    glProgramStringARB(static_cast<GLenum>(target), static_cast<GLenum>(format), string.size(), reinterpret_cast<const void *>(string.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_fragment_program
#endif // GL_ARB_fragment_program
#ifdef GL_ARB_fragment_program_shadow
namespace arb_fragment_program_shadow {
} // arb_fragment_program_shadow
#endif // GL_ARB_fragment_program_shadow
#ifdef GL_ARB_fragment_shader
namespace arb_fragment_shader {
constexpr u32 fragment_shader_arb = 0x8B30;
constexpr u32 max_fragment_uniform_components_arb = 0x8B49;
constexpr u32 fragment_shader_derivative_hint_arb = 0x8B8B;
} // arb_fragment_shader
#endif // GL_ARB_fragment_shader
#ifdef GL_ARB_fragment_shader_interlock
namespace arb_fragment_shader_interlock {
} // arb_fragment_shader_interlock
#endif // GL_ARB_fragment_shader_interlock
#ifdef GL_ARB_framebuffer_no_attachments
namespace arb_framebuffer_no_attachments {
constexpr u32 framebuffer_default_width = 0x9310;
constexpr u32 framebuffer_default_height = 0x9311;
constexpr u32 framebuffer_default_layers = 0x9312;
constexpr u32 framebuffer_default_samples = 0x9313;
constexpr u32 framebuffer_default_fixed_sample_locations = 0x9314;
constexpr u32 max_framebuffer_width = 0x9315;
constexpr u32 max_framebuffer_height = 0x9316;
constexpr u32 max_framebuffer_layers = 0x9317;
constexpr u32 max_framebuffer_samples = 0x9318;
STATICINLINE void framebuffer_parameter(groups::framebuffer_target target, groups::framebuffer_parameter_name pname, i32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferParameteri)
                Throw(undefined_behavior(
                    "unloaded function FramebufferParameteri"));
    }
    glFramebufferParameteri(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_framebuffer_parameter(groups::framebuffer_target target, groups::framebuffer_attachment_parameter_name pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetFramebufferParameteriv)
                Throw(undefined_behavior(
                    "unloaded function GetFramebufferParameteriv"));
    }
    glGetFramebufferParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_framebuffer_no_attachments
#endif // GL_ARB_framebuffer_no_attachments
#ifdef GL_ARB_framebuffer_object
namespace arb_framebuffer_object {
constexpr u32 invalid_framebuffer_operation = 0x0506;
constexpr u32 framebuffer_attachment_color_encoding = 0x8210;
constexpr u32 framebuffer_attachment_component_type = 0x8211;
constexpr u32 framebuffer_attachment_red_size = 0x8212;
constexpr u32 framebuffer_attachment_green_size = 0x8213;
constexpr u32 framebuffer_attachment_blue_size = 0x8214;
constexpr u32 framebuffer_attachment_alpha_size = 0x8215;
constexpr u32 framebuffer_attachment_depth_size = 0x8216;
constexpr u32 framebuffer_attachment_stencil_size = 0x8217;
constexpr u32 framebuffer_default = 0x8218;
constexpr u32 framebuffer_undefined = 0x8219;
constexpr u32 depth_stencil_attachment = 0x821A;
constexpr u32 index = 0x8222;
constexpr u32 max_renderbuffer_size = 0x84E8;
constexpr u32 depth_stencil = 0x84F9;
constexpr u32 unsigned_int_24_8 = 0x84FA;
constexpr u32 depth24_stencil8 = 0x88F0;
constexpr u32 texture_stencil_size = 0x88F1;
constexpr u32 unsigned_normalized = 0x8C17;
constexpr u32 draw_framebuffer_binding = 0x8CA6;
constexpr u32 framebuffer_binding = 0x8CA6;
constexpr u32 renderbuffer_binding = 0x8CA7;
constexpr u32 read_framebuffer = 0x8CA8;
constexpr u32 draw_framebuffer = 0x8CA9;
constexpr u32 read_framebuffer_binding = 0x8CAA;
constexpr u32 renderbuffer_samples = 0x8CAB;
constexpr u32 framebuffer_attachment_object_type = 0x8CD0;
constexpr u32 framebuffer_attachment_object_name = 0x8CD1;
constexpr u32 framebuffer_attachment_texture_level = 0x8CD2;
constexpr u32 framebuffer_attachment_texture_cube_map_face = 0x8CD3;
constexpr u32 framebuffer_attachment_texture_layer = 0x8CD4;
constexpr u32 framebuffer_complete = 0x8CD5;
constexpr u32 framebuffer_incomplete_attachment = 0x8CD6;
constexpr u32 framebuffer_incomplete_missing_attachment = 0x8CD7;
constexpr u32 framebuffer_incomplete_draw_buffer = 0x8CDB;
constexpr u32 framebuffer_incomplete_read_buffer = 0x8CDC;
constexpr u32 framebuffer_unsupported = 0x8CDD;
constexpr u32 max_color_attachments = 0x8CDF;
constexpr u32 color_attachment0 = 0x8CE0;
constexpr u32 color_attachment1 = 0x8CE1;
constexpr u32 color_attachment2 = 0x8CE2;
constexpr u32 color_attachment3 = 0x8CE3;
constexpr u32 color_attachment4 = 0x8CE4;
constexpr u32 color_attachment5 = 0x8CE5;
constexpr u32 color_attachment6 = 0x8CE6;
constexpr u32 color_attachment7 = 0x8CE7;
constexpr u32 color_attachment8 = 0x8CE8;
constexpr u32 color_attachment9 = 0x8CE9;
constexpr u32 color_attachment10 = 0x8CEA;
constexpr u32 color_attachment11 = 0x8CEB;
constexpr u32 color_attachment12 = 0x8CEC;
constexpr u32 color_attachment13 = 0x8CED;
constexpr u32 color_attachment14 = 0x8CEE;
constexpr u32 color_attachment15 = 0x8CEF;
constexpr u32 depth_attachment = 0x8D00;
constexpr u32 stencil_attachment = 0x8D20;
constexpr u32 framebuffer = 0x8D40;
constexpr u32 renderbuffer = 0x8D41;
constexpr u32 renderbuffer_width = 0x8D42;
constexpr u32 renderbuffer_height = 0x8D43;
constexpr u32 renderbuffer_internal_format = 0x8D44;
constexpr u32 stencil_index1 = 0x8D46;
constexpr u32 stencil_index4 = 0x8D47;
constexpr u32 stencil_index8 = 0x8D48;
constexpr u32 stencil_index16 = 0x8D49;
constexpr u32 renderbuffer_red_size = 0x8D50;
constexpr u32 renderbuffer_green_size = 0x8D51;
constexpr u32 renderbuffer_blue_size = 0x8D52;
constexpr u32 renderbuffer_alpha_size = 0x8D53;
constexpr u32 renderbuffer_depth_size = 0x8D54;
constexpr u32 renderbuffer_stencil_size = 0x8D55;
constexpr u32 framebuffer_incomplete_multisample = 0x8D56;
constexpr u32 max_samples = 0x8D57;
STATICINLINE void bind_framebuffer(groups::framebuffer_target target, u32 framebuffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindFramebuffer)
                Throw(undefined_behavior(
                    "unloaded function BindFramebuffer"));
        glIsFramebuffer(framebuffer);
    }
    glBindFramebuffer(static_cast<GLenum>(target), framebuffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void bind_renderbuffer(groups::renderbuffer_target target, u32 renderbuffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindRenderbuffer)
                Throw(undefined_behavior(
                    "unloaded function BindRenderbuffer"));
        glIsRenderbuffer(renderbuffer);
    }
    glBindRenderbuffer(static_cast<GLenum>(target), renderbuffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void blit_framebuffer(i32 srcX0, i32 srcY0, i32 srcX1, i32 srcY1, i32 dstX0, i32 dstY0, i32 dstX1, i32 dstY1, groups::clear_buffer_mask mask, groups::blit_framebuffer_filter filter)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlitFramebuffer)
                Throw(undefined_behavior(
                    "unloaded function BlitFramebuffer"));
    }
    glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, static_cast<GLenum>(mask), static_cast<GLenum>(filter));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLenum check_framebuffer_status(groups::framebuffer_target target)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCheckFramebufferStatus)
                Throw(undefined_behavior(
                    "unloaded function CheckFramebufferStatus"));
    }
    auto out = glCheckFramebufferStatus(static_cast<GLenum>(target));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_framebuffers(span_const_u32 const& framebuffers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteFramebuffers)
                Throw(undefined_behavior(
                    "unloaded function DeleteFramebuffers"));
    }
    glDeleteFramebuffers(framebuffers.size(), reinterpret_cast<const GLuint *>(framebuffers.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_renderbuffers(span_const_u32 const& renderbuffers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteRenderbuffers)
                Throw(undefined_behavior(
                    "unloaded function DeleteRenderbuffers"));
    }
    glDeleteRenderbuffers(renderbuffers.size(), reinterpret_cast<const GLuint *>(renderbuffers.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void framebuffer_renderbuffer(groups::framebuffer_target target, groups::framebuffer_attachment attachment, groups::renderbuffer_target renderbuffertarget, u32 renderbuffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferRenderbuffer)
                Throw(undefined_behavior(
                    "unloaded function FramebufferRenderbuffer"));
        glIsRenderbuffer(renderbuffer);
    }
    glFramebufferRenderbuffer(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(renderbuffertarget), renderbuffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void framebuffer_texture_1d(groups::framebuffer_target target, groups::framebuffer_attachment attachment, groups::texture_target textarget, u32 texture, i32 level)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferTexture1D)
                Throw(undefined_behavior(
                    "unloaded function FramebufferTexture1D"));
        glIsTexture(texture);
    }
    glFramebufferTexture1D(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void framebuffer_texture_2d(groups::framebuffer_target target, groups::framebuffer_attachment attachment, groups::texture_target textarget, u32 texture, i32 level)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferTexture2D)
                Throw(undefined_behavior(
                    "unloaded function FramebufferTexture2D"));
        glIsTexture(texture);
    }
    glFramebufferTexture2D(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void framebuffer_texture_3d(groups::framebuffer_target target, groups::framebuffer_attachment attachment, groups::texture_target textarget, u32 texture, i32 level, i32 zoffset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferTexture3D)
                Throw(undefined_behavior(
                    "unloaded function FramebufferTexture3D"));
        glIsTexture(texture);
    }
    glFramebufferTexture3D(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level, zoffset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void framebuffer_texture_layer(groups::framebuffer_target target, groups::framebuffer_attachment attachment, u32 texture, i32 level, i32 layer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferTextureLayer)
                Throw(undefined_behavior(
                    "unloaded function FramebufferTextureLayer"));
        glIsTexture(texture);
    }
    glFramebufferTextureLayer(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, layer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void gen_framebuffers(span_u32 framebuffers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenFramebuffers)
                Throw(undefined_behavior(
                    "unloaded function GenFramebuffers"));
    }
    glGenFramebuffers(framebuffers.size(), reinterpret_cast<GLuint *>(framebuffers.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void gen_renderbuffers(span_u32 renderbuffers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenRenderbuffers)
                Throw(undefined_behavior(
                    "unloaded function GenRenderbuffers"));
    }
    glGenRenderbuffers(renderbuffers.size(), reinterpret_cast<GLuint *>(renderbuffers.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void generate_mipmap(GLenum target)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenerateMipmap)
                Throw(undefined_behavior(
                    "unloaded function GenerateMipmap"));
    }
    glGenerateMipmap(target);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_framebuffer_attachment_parameter(groups::framebuffer_target target, groups::framebuffer_attachment attachment, groups::framebuffer_attachment_parameter_name pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetFramebufferAttachmentParameteriv)
                Throw(undefined_behavior(
                    "unloaded function GetFramebufferAttachmentParameteriv"));
    }
    glGetFramebufferAttachmentParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_renderbuffer_parameter(groups::renderbuffer_target target, groups::renderbuffer_parameter_name pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetRenderbufferParameteriv)
                Throw(undefined_behavior(
                    "unloaded function GetRenderbufferParameteriv"));
    }
    glGetRenderbufferParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_framebuffer(u32 framebuffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsFramebuffer)
                Throw(undefined_behavior(
                    "unloaded function IsFramebuffer"));
        glIsFramebuffer(framebuffer);
    }
    auto out = glIsFramebuffer(framebuffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLboolean is_renderbuffer(u32 renderbuffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsRenderbuffer)
                Throw(undefined_behavior(
                    "unloaded function IsRenderbuffer"));
        glIsRenderbuffer(renderbuffer);
    }
    auto out = glIsRenderbuffer(renderbuffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void renderbuffer_storage(groups::renderbuffer_target target, groups::internal_format internalformat, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glRenderbufferStorage)
                Throw(undefined_behavior(
                    "unloaded function RenderbufferStorage"));
    }
    glRenderbufferStorage(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void renderbuffer_storage_multisample(groups::renderbuffer_target target, i32 samples, groups::internal_format internalformat, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glRenderbufferStorageMultisample)
                Throw(undefined_behavior(
                    "unloaded function RenderbufferStorageMultisample"));
    }
    glRenderbufferStorageMultisample(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_framebuffer_object
#endif // GL_ARB_framebuffer_object
#ifdef GL_ARB_framebuffer_sRGB
namespace arb_framebuffer_srgb {
constexpr u32 framebuffer_srgb = 0x8DB9;
} // arb_framebuffer_srgb
#endif // GL_ARB_framebuffer_sRGB
#ifdef GL_ARB_geometry_shader4
namespace arb_geometry_shader4 {
constexpr u32 lines_adjacency_arb = 0x000A;
constexpr u32 line_strip_adjacency_arb = 0x000B;
constexpr u32 triangles_adjacency_arb = 0x000C;
constexpr u32 triangle_strip_adjacency_arb = 0x000D;
constexpr u32 program_point_size_arb = 0x8642;
constexpr u32 max_varying_components = 0x8B4B;
constexpr u32 max_geometry_texture_image_units_arb = 0x8C29;
constexpr u32 framebuffer_attachment_texture_layer = 0x8CD4;
constexpr u32 framebuffer_attachment_layered_arb = 0x8DA7;
constexpr u32 framebuffer_incomplete_layer_targets_arb = 0x8DA8;
constexpr u32 framebuffer_incomplete_layer_count_arb = 0x8DA9;
constexpr u32 geometry_shader_arb = 0x8DD9;
constexpr u32 geometry_vertices_out_arb = 0x8DDA;
constexpr u32 geometry_input_type_arb = 0x8DDB;
constexpr u32 geometry_output_type_arb = 0x8DDC;
constexpr u32 max_geometry_varying_components_arb = 0x8DDD;
constexpr u32 max_vertex_varying_components_arb = 0x8DDE;
constexpr u32 max_geometry_uniform_components_arb = 0x8DDF;
constexpr u32 max_geometry_output_vertices_arb = 0x8DE0;
constexpr u32 max_geometry_total_output_components_arb = 0x8DE1;
STATICINLINE void framebuffer_texture_arb(groups::framebuffer_target target, groups::framebuffer_attachment attachment, u32 texture, i32 level)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferTextureARB)
                Throw(undefined_behavior(
                    "unloaded function FramebufferTextureARB"));
        glIsTexture(texture);
    }
    glFramebufferTextureARB(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void framebuffer_texture_face_arb(groups::framebuffer_target target, groups::framebuffer_attachment attachment, u32 texture, i32 level, groups::texture_target face)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferTextureFaceARB)
                Throw(undefined_behavior(
                    "unloaded function FramebufferTextureFaceARB"));
        glIsTexture(texture);
    }
    glFramebufferTextureFaceARB(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, static_cast<GLenum>(face));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void framebuffer_texture_layer_arb(groups::framebuffer_target target, groups::framebuffer_attachment attachment, u32 texture, i32 level, i32 layer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferTextureLayerARB)
                Throw(undefined_behavior(
                    "unloaded function FramebufferTextureLayerARB"));
        glIsTexture(texture);
    }
    glFramebufferTextureLayerARB(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, layer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void program_parameteri_arb(u32 program, groups::program_parameter_prop pname, i32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramParameteriARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramParameteriARB"));
        glIsProgram(program);
    }
    glProgramParameteriARB(program, static_cast<GLenum>(pname), value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_geometry_shader4
#endif // GL_ARB_geometry_shader4
#ifdef GL_ARB_get_program_binary
namespace arb_get_program_binary {
constexpr u32 program_binary_retrievable_hint = 0x8257;
constexpr u32 program_binary_length = 0x8741;
constexpr u32 num_program_binary_formats = 0x87FE;
constexpr u32 program_binary_formats = 0x87FF;
template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_program_binary(u32 program, i32& length, GLenum& binaryFormat, span_byte binary)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramBinary)
                Throw(undefined_behavior(
                    "unloaded function GetProgramBinary"));
        glIsProgram(program);
    }
    glGetProgramBinary(program, binary.size(), &length, &binaryFormat, reinterpret_cast<void *>(binary.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void program_binary(u32 program, GLenum binaryFormat, span_const_byte const& binary, i32 length)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramBinary)
                Throw(undefined_behavior(
                    "unloaded function ProgramBinary"));
        glIsProgram(program);
    }
    glProgramBinary(program, binaryFormat, reinterpret_cast<const void *>(binary.data()), length);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void program_parameter(u32 program, groups::program_parameter_prop pname, i32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramParameteri)
                Throw(undefined_behavior(
                    "unloaded function ProgramParameteri"));
        glIsProgram(program);
    }
    glProgramParameteri(program, static_cast<GLenum>(pname), value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_get_program_binary
#endif // GL_ARB_get_program_binary
#ifdef GL_ARB_get_texture_sub_image
namespace arb_get_texture_sub_image {
template<
    class span_byte,
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3> &&
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_compressed_texture_sub_image(u32 texture, i32 level, vec_3_i32 const& xoffset, vec_3_i32 const& width, i32 bufSize, span_byte pixels)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetCompressedTextureSubImage)
                Throw(undefined_behavior(
                    "unloaded function GetCompressedTextureSubImage"));
        glIsTexture(texture);
    }
    glGetCompressedTextureSubImage(texture, level, xoffset.x(), xoffset.y(), xoffset.z(), width[0], width[1], width[2], bufSize, reinterpret_cast<void *>(pixels.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte,
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3> &&
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_texture_sub_image(u32 texture, i32 level, vec_3_i32 const& xoffset, vec_3_i32 const& width, groups::pixel_format format, groups::pixel_type type, i32 bufSize, span_byte pixels)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTextureSubImage)
                Throw(undefined_behavior(
                    "unloaded function GetTextureSubImage"));
        glIsTexture(texture);
    }
    glGetTextureSubImage(texture, level, xoffset.x(), xoffset.y(), xoffset.z(), width[0], width[1], width[2], static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, reinterpret_cast<void *>(pixels.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_get_texture_sub_image
#endif // GL_ARB_get_texture_sub_image
#ifdef GL_ARB_gl_spirv
namespace arb_gl_spirv {
constexpr u32 shader_binary_format_spir_v_arb = 0x9551;
constexpr u32 spir_v_binary_arb = 0x9552;
template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void specialize_shader_arb(u32 shader, std::string_view const& pEntryPoint, u32 numSpecializationConstants, span_const_u32 const& pConstantIndex, span_const_u32 const& pConstantValue)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSpecializeShaderARB)
                Throw(undefined_behavior(
                    "unloaded function SpecializeShaderARB"));
        glIsShader(shader);
    }
    glSpecializeShaderARB(shader, pEntryPoint.data(), numSpecializationConstants, reinterpret_cast<const GLuint *>(pConstantIndex.data()), reinterpret_cast<const GLuint *>(pConstantValue.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_gl_spirv
#endif // GL_ARB_gl_spirv
#ifdef GL_ARB_gpu_shader5
namespace arb_gpu_shader5 {
constexpr u32 geometry_shader_invocations = 0x887F;
constexpr u32 max_geometry_shader_invocations = 0x8E5A;
constexpr u32 min_fragment_interpolation_offset = 0x8E5B;
constexpr u32 max_fragment_interpolation_offset = 0x8E5C;
constexpr u32 fragment_interpolation_offset_bits = 0x8E5D;
constexpr u32 max_vertex_streams = 0x8E71;
} // arb_gpu_shader5
#endif // GL_ARB_gpu_shader5
#ifdef GL_ARB_gpu_shader_fp64
namespace arb_gpu_shader_fp64 {
constexpr u32 double = 0x140A;
constexpr u32 double_mat2 = 0x8F46;
constexpr u32 double_mat3 = 0x8F47;
constexpr u32 double_mat4 = 0x8F48;
constexpr u32 double_mat2x3 = 0x8F49;
constexpr u32 double_mat2x4 = 0x8F4A;
constexpr u32 double_mat3x2 = 0x8F4B;
constexpr u32 double_mat3x4 = 0x8F4C;
constexpr u32 double_mat4x2 = 0x8F4D;
constexpr u32 double_mat4x3 = 0x8F4E;
constexpr u32 double_vec2 = 0x8FFC;
constexpr u32 double_vec3 = 0x8FFD;
constexpr u32 double_vec4 = 0x8FFE;
template<
    class span_f64
>
requires (
    semantic::concepts::Span<span_f64> &&
    std::is_same_v<std::decay_t<typename span_f64::value_type>, f64>)
STATICINLINE void get_uniformdv(u32 program, i32 location, span_f64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetUniformdv)
                Throw(undefined_behavior(
                    "unloaded function GetUniformdv"));
        glIsProgram(program);
    }
    glGetUniformdv(program, location, reinterpret_cast<GLdouble *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void uniform(i32 location, f64 x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1d)
                Throw(undefined_behavior(
                    "unloaded function Uniform1d"));
    }
    glUniform1d(location, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f64
>
requires (
    semantic::concepts::Span<span_const_f64> &&
    std::is_same_v<std::decay_t<typename span_const_f64::value_type>, f64>)
STATICINLINE void uniform(i32 location, i32 count, span_const_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1dv)
                Throw(undefined_behavior(
                    "unloaded function Uniform1dv"));
    }
    glUniform1dv(location, count, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_f64
>
requires (
    semantic::concepts::Vector<vec_2_f64, f64, 2>)
STATICINLINE void uniform(i32 location, vec_2_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2d)
                Throw(undefined_behavior(
                    "unloaded function Uniform2d"));
    }
    glUniform2d(location, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_f64
>
requires (
    semantic::concepts::Span<span_const_vec_2_f64> &&
    semantic::concepts::Vector<typename span_const_vec_2_f64::value_type, f64, 2>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_2_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2dv)
                Throw(undefined_behavior(
                    "unloaded function Uniform2dv"));
    }
    glUniform2dv(location, count, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f64
>
requires (
    semantic::concepts::Vector<vec_3_f64, f64, 3>)
STATICINLINE void uniform(i32 location, vec_3_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3d)
                Throw(undefined_behavior(
                    "unloaded function Uniform3d"));
    }
    glUniform3d(location, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_f64
>
requires (
    semantic::concepts::Span<span_const_vec_3_f64> &&
    semantic::concepts::Vector<typename span_const_vec_3_f64::value_type, f64, 3>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_3_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3dv)
                Throw(undefined_behavior(
                    "unloaded function Uniform3dv"));
    }
    glUniform3dv(location, count, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f64
>
requires (
    semantic::concepts::Vector<vec_4_f64, f64, 4>)
STATICINLINE void uniform(i32 location, vec_4_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4d)
                Throw(undefined_behavior(
                    "unloaded function Uniform4d"));
    }
    glUniform4d(location, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f64
>
requires (
    semantic::concepts::Span<span_const_vec_4_f64> &&
    semantic::concepts::Vector<typename span_const_vec_4_f64::value_type, f64, 4>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_4_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4dv)
                Throw(undefined_behavior(
                    "unloaded function Uniform4dv"));
    }
    glUniform4dv(location, count, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_2x2_f64
>
requires (
    semantic::concepts::Span<span_const_mat_2x2_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_2x2_f64::value_type, f64, 2, 2>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_2x2_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix2dv)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix2dv"));
    }
    glUniformMatrix2dv(location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_2x3_f64
>
requires (
    semantic::concepts::Span<span_const_mat_2x3_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_2x3_f64::value_type, f64, 2, 3>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_2x3_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix2x3dv)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix2x3dv"));
    }
    glUniformMatrix2x3dv(location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_2x4_f64
>
requires (
    semantic::concepts::Span<span_const_mat_2x4_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_2x4_f64::value_type, f64, 2, 4>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_2x4_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix2x4dv)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix2x4dv"));
    }
    glUniformMatrix2x4dv(location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x3_f64
>
requires (
    semantic::concepts::Span<span_const_mat_3x3_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_3x3_f64::value_type, f64, 3, 3>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_3x3_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix3dv)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix3dv"));
    }
    glUniformMatrix3dv(location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x2_f64
>
requires (
    semantic::concepts::Span<span_const_mat_3x2_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_3x2_f64::value_type, f64, 3, 2>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_3x2_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix3x2dv)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix3x2dv"));
    }
    glUniformMatrix3x2dv(location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x4_f64
>
requires (
    semantic::concepts::Span<span_const_mat_3x4_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_3x4_f64::value_type, f64, 3, 4>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_3x4_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix3x4dv)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix3x4dv"));
    }
    glUniformMatrix3x4dv(location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_4x4_f64
>
requires (
    semantic::concepts::Span<span_const_mat_4x4_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_4x4_f64::value_type, f64, 4, 4>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_4x4_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix4dv)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix4dv"));
    }
    glUniformMatrix4dv(location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_4x2_f64
>
requires (
    semantic::concepts::Span<span_const_mat_4x2_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_4x2_f64::value_type, f64, 4, 2>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_4x2_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix4x2dv)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix4x2dv"));
    }
    glUniformMatrix4x2dv(location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_4x3_f64
>
requires (
    semantic::concepts::Span<span_const_mat_4x3_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_4x3_f64::value_type, f64, 4, 3>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_4x3_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix4x3dv)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix4x3dv"));
    }
    glUniformMatrix4x3dv(location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_gpu_shader_fp64
#endif // GL_ARB_gpu_shader_fp64
#ifdef GL_ARB_gpu_shader_int64
namespace arb_gpu_shader_int64 {
constexpr u32 int64_arb = 0x140E;
constexpr u32 unsigned_int64_arb = 0x140F;
constexpr u32 int64_vec2_arb = 0x8FE9;
constexpr u32 int64_vec3_arb = 0x8FEA;
constexpr u32 int64_vec4_arb = 0x8FEB;
constexpr u32 unsigned_int64_vec2_arb = 0x8FF5;
constexpr u32 unsigned_int64_vec3_arb = 0x8FF6;
constexpr u32 unsigned_int64_vec4_arb = 0x8FF7;
template<
    class span_i64
>
requires (
    semantic::concepts::Span<span_i64> &&
    std::is_same_v<std::decay_t<typename span_i64::value_type>, i64>)
STATICINLINE void get_uniformi64v_arb(u32 program, i32 location, span_i64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetUniformi64vARB)
                Throw(undefined_behavior(
                    "unloaded function GetUniformi64vARB"));
        glIsProgram(program);
    }
    glGetUniformi64vARB(program, location, reinterpret_cast<GLint64 *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u64
>
requires (
    semantic::concepts::Span<span_u64> &&
    std::is_same_v<std::decay_t<typename span_u64::value_type>, u64>)
STATICINLINE void get_uniformui64v_arb(u32 program, i32 location, span_u64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetUniformui64vARB)
                Throw(undefined_behavior(
                    "unloaded function GetUniformui64vARB"));
        glIsProgram(program);
    }
    glGetUniformui64vARB(program, location, reinterpret_cast<GLuint64 *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i64
>
requires (
    semantic::concepts::Span<span_i64> &&
    std::is_same_v<std::decay_t<typename span_i64::value_type>, i64>)
STATICINLINE void getn_uniformi64v_arb(u32 program, i32 location, i32 bufSize, span_i64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnUniformi64vARB)
                Throw(undefined_behavior(
                    "unloaded function GetnUniformi64vARB"));
        glIsProgram(program);
    }
    glGetnUniformi64vARB(program, location, bufSize, reinterpret_cast<GLint64 *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u64
>
requires (
    semantic::concepts::Span<span_u64> &&
    std::is_same_v<std::decay_t<typename span_u64::value_type>, u64>)
STATICINLINE void getn_uniformui64v_arb(u32 program, i32 location, i32 bufSize, span_u64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnUniformui64vARB)
                Throw(undefined_behavior(
                    "unloaded function GetnUniformui64vARB"));
        glIsProgram(program);
    }
    glGetnUniformui64vARB(program, location, bufSize, reinterpret_cast<GLuint64 *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void program_uniform(u32 program, i32 location, i64 x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1i64ARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1i64ARB"));
        glIsProgram(program);
    }
    glProgramUniform1i64ARB(program, location, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i64
>
requires (
    semantic::concepts::Span<span_const_i64> &&
    std::is_same_v<std::decay_t<typename span_const_i64::value_type>, i64>)
STATICINLINE void program_uniform(u32 program, i32 location, span_const_i64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1i64vARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1i64vARB"));
        glIsProgram(program);
    }
    glProgramUniform1i64vARB(program, location, value.size(), reinterpret_cast<const GLint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void program_uniform(u32 program, i32 location, u64 x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1ui64ARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1ui64ARB"));
        glIsProgram(program);
    }
    glProgramUniform1ui64ARB(program, location, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u64
>
requires (
    semantic::concepts::Span<span_const_u64> &&
    std::is_same_v<std::decay_t<typename span_const_u64::value_type>, u64>)
STATICINLINE void program_uniform(u32 program, i32 location, span_const_u64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1ui64vARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1ui64vARB"));
        glIsProgram(program);
    }
    glProgramUniform1ui64vARB(program, location, value.size(), reinterpret_cast<const GLuint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i64
>
requires (
    semantic::concepts::Vector<vec_2_i64, i64, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_2_i64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2i64ARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2i64ARB"));
        glIsProgram(program);
    }
    glProgramUniform2i64ARB(program, location, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_i64
>
requires (
    semantic::concepts::Span<span_const_vec_2_i64> &&
    semantic::concepts::Vector<typename span_const_vec_2_i64::value_type, i64, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_2_i64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2i64vARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2i64vARB"));
        glIsProgram(program);
    }
    glProgramUniform2i64vARB(program, location, count, reinterpret_cast<const GLint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_u64
>
requires (
    semantic::concepts::Vector<vec_2_u64, u64, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_2_u64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2ui64ARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2ui64ARB"));
        glIsProgram(program);
    }
    glProgramUniform2ui64ARB(program, location, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_u64
>
requires (
    semantic::concepts::Span<span_const_vec_2_u64> &&
    semantic::concepts::Vector<typename span_const_vec_2_u64::value_type, u64, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_2_u64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2ui64vARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2ui64vARB"));
        glIsProgram(program);
    }
    glProgramUniform2ui64vARB(program, location, count, reinterpret_cast<const GLuint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i64
>
requires (
    semantic::concepts::Vector<vec_3_i64, i64, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_3_i64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3i64ARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3i64ARB"));
        glIsProgram(program);
    }
    glProgramUniform3i64ARB(program, location, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_i64
>
requires (
    semantic::concepts::Span<span_const_vec_3_i64> &&
    semantic::concepts::Vector<typename span_const_vec_3_i64::value_type, i64, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_3_i64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3i64vARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3i64vARB"));
        glIsProgram(program);
    }
    glProgramUniform3i64vARB(program, location, count, reinterpret_cast<const GLint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_u64
>
requires (
    semantic::concepts::Vector<vec_3_u64, u64, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_3_u64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3ui64ARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3ui64ARB"));
        glIsProgram(program);
    }
    glProgramUniform3ui64ARB(program, location, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_u64
>
requires (
    semantic::concepts::Span<span_const_vec_3_u64> &&
    semantic::concepts::Vector<typename span_const_vec_3_u64::value_type, u64, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_3_u64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3ui64vARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3ui64vARB"));
        glIsProgram(program);
    }
    glProgramUniform3ui64vARB(program, location, count, reinterpret_cast<const GLuint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_i64
>
requires (
    semantic::concepts::Vector<vec_4_i64, i64, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_4_i64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4i64ARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4i64ARB"));
        glIsProgram(program);
    }
    glProgramUniform4i64ARB(program, location, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_i64
>
requires (
    semantic::concepts::Span<span_const_vec_4_i64> &&
    semantic::concepts::Vector<typename span_const_vec_4_i64::value_type, i64, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_4_i64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4i64vARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4i64vARB"));
        glIsProgram(program);
    }
    glProgramUniform4i64vARB(program, location, count, reinterpret_cast<const GLint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_u64
>
requires (
    semantic::concepts::Vector<vec_4_u64, u64, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_4_u64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4ui64ARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4ui64ARB"));
        glIsProgram(program);
    }
    glProgramUniform4ui64ARB(program, location, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u64
>
requires (
    semantic::concepts::Span<span_const_vec_4_u64> &&
    semantic::concepts::Vector<typename span_const_vec_4_u64::value_type, u64, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_4_u64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4ui64vARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4ui64vARB"));
        glIsProgram(program);
    }
    glProgramUniform4ui64vARB(program, location, count, reinterpret_cast<const GLuint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void uniform(i32 location, i64 x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1i64ARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform1i64ARB"));
    }
    glUniform1i64ARB(location, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i64
>
requires (
    semantic::concepts::Span<span_const_i64> &&
    std::is_same_v<std::decay_t<typename span_const_i64::value_type>, i64>)
STATICINLINE void uniform(i32 location, i32 count, span_const_i64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1i64vARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform1i64vARB"));
    }
    glUniform1i64vARB(location, count, reinterpret_cast<const GLint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void uniform(i32 location, u64 x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1ui64ARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform1ui64ARB"));
    }
    glUniform1ui64ARB(location, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u64
>
requires (
    semantic::concepts::Span<span_const_u64> &&
    std::is_same_v<std::decay_t<typename span_const_u64::value_type>, u64>)
STATICINLINE void uniform(i32 location, i32 count, span_const_u64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1ui64vARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform1ui64vARB"));
    }
    glUniform1ui64vARB(location, count, reinterpret_cast<const GLuint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i64
>
requires (
    semantic::concepts::Vector<vec_2_i64, i64, 2>)
STATICINLINE void uniform(i32 location, vec_2_i64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2i64ARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform2i64ARB"));
    }
    glUniform2i64ARB(location, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_i64
>
requires (
    semantic::concepts::Span<span_const_vec_2_i64> &&
    semantic::concepts::Vector<typename span_const_vec_2_i64::value_type, i64, 2>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_2_i64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2i64vARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform2i64vARB"));
    }
    glUniform2i64vARB(location, count, reinterpret_cast<const GLint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_u64
>
requires (
    semantic::concepts::Vector<vec_2_u64, u64, 2>)
STATICINLINE void uniform(i32 location, vec_2_u64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2ui64ARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform2ui64ARB"));
    }
    glUniform2ui64ARB(location, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_u64
>
requires (
    semantic::concepts::Span<span_const_vec_2_u64> &&
    semantic::concepts::Vector<typename span_const_vec_2_u64::value_type, u64, 2>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_2_u64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2ui64vARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform2ui64vARB"));
    }
    glUniform2ui64vARB(location, count, reinterpret_cast<const GLuint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i64
>
requires (
    semantic::concepts::Vector<vec_3_i64, i64, 3>)
STATICINLINE void uniform(i32 location, vec_3_i64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3i64ARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform3i64ARB"));
    }
    glUniform3i64ARB(location, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_i64
>
requires (
    semantic::concepts::Span<span_const_vec_3_i64> &&
    semantic::concepts::Vector<typename span_const_vec_3_i64::value_type, i64, 3>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_3_i64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3i64vARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform3i64vARB"));
    }
    glUniform3i64vARB(location, count, reinterpret_cast<const GLint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_u64
>
requires (
    semantic::concepts::Vector<vec_3_u64, u64, 3>)
STATICINLINE void uniform(i32 location, vec_3_u64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3ui64ARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform3ui64ARB"));
    }
    glUniform3ui64ARB(location, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_u64
>
requires (
    semantic::concepts::Span<span_const_vec_3_u64> &&
    semantic::concepts::Vector<typename span_const_vec_3_u64::value_type, u64, 3>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_3_u64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3ui64vARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform3ui64vARB"));
    }
    glUniform3ui64vARB(location, count, reinterpret_cast<const GLuint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_i64
>
requires (
    semantic::concepts::Vector<vec_4_i64, i64, 4>)
STATICINLINE void uniform(i32 location, vec_4_i64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4i64ARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform4i64ARB"));
    }
    glUniform4i64ARB(location, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_i64
>
requires (
    semantic::concepts::Span<span_const_vec_4_i64> &&
    semantic::concepts::Vector<typename span_const_vec_4_i64::value_type, i64, 4>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_4_i64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4i64vARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform4i64vARB"));
    }
    glUniform4i64vARB(location, count, reinterpret_cast<const GLint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_u64
>
requires (
    semantic::concepts::Vector<vec_4_u64, u64, 4>)
STATICINLINE void uniform(i32 location, vec_4_u64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4ui64ARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform4ui64ARB"));
    }
    glUniform4ui64ARB(location, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u64
>
requires (
    semantic::concepts::Span<span_const_vec_4_u64> &&
    semantic::concepts::Vector<typename span_const_vec_4_u64::value_type, u64, 4>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_4_u64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4ui64vARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform4ui64vARB"));
    }
    glUniform4ui64vARB(location, count, reinterpret_cast<const GLuint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_gpu_shader_int64
#endif // GL_ARB_gpu_shader_int64
#ifdef GL_ARB_half_float_pixel
namespace arb_half_float_pixel {
constexpr u32 half_float_arb = 0x140B;
} // arb_half_float_pixel
#endif // GL_ARB_half_float_pixel
#ifdef GL_ARB_half_float_vertex
namespace arb_half_float_vertex {
constexpr u32 half_float = 0x140B;
} // arb_half_float_vertex
#endif // GL_ARB_half_float_vertex
#ifdef GL_ARB_imaging
namespace arb_imaging {
constexpr u32 constant_color = 0x8001;
constexpr u32 one_minus_constant_color = 0x8002;
constexpr u32 constant_alpha = 0x8003;
constexpr u32 one_minus_constant_alpha = 0x8004;
constexpr u32 blend_color = 0x8005;
constexpr u32 func_add = 0x8006;
constexpr u32 min = 0x8007;
constexpr u32 max = 0x8008;
constexpr u32 blend_equation = 0x8009;
constexpr u32 func_subtract = 0x800A;
constexpr u32 func_reverse_subtract = 0x800B;
constexpr u32 convolution_1d = 0x8010;
constexpr u32 convolution_2d = 0x8011;
constexpr u32 separable_2d = 0x8012;
constexpr u32 convolution_border_mode = 0x8013;
constexpr u32 convolution_filter_scale = 0x8014;
constexpr u32 convolution_filter_bias = 0x8015;
constexpr u32 reduce = 0x8016;
constexpr u32 convolution_format = 0x8017;
constexpr u32 convolution_width = 0x8018;
constexpr u32 convolution_height = 0x8019;
constexpr u32 max_convolution_width = 0x801A;
constexpr u32 max_convolution_height = 0x801B;
constexpr u32 post_convolution_red_scale = 0x801C;
constexpr u32 post_convolution_green_scale = 0x801D;
constexpr u32 post_convolution_blue_scale = 0x801E;
constexpr u32 post_convolution_alpha_scale = 0x801F;
constexpr u32 post_convolution_red_bias = 0x8020;
constexpr u32 post_convolution_green_bias = 0x8021;
constexpr u32 post_convolution_blue_bias = 0x8022;
constexpr u32 post_convolution_alpha_bias = 0x8023;
constexpr u32 histogram = 0x8024;
constexpr u32 proxy_histogram = 0x8025;
constexpr u32 histogram_width = 0x8026;
constexpr u32 histogram_format = 0x8027;
constexpr u32 histogram_red_size = 0x8028;
constexpr u32 histogram_green_size = 0x8029;
constexpr u32 histogram_blue_size = 0x802A;
constexpr u32 histogram_alpha_size = 0x802B;
constexpr u32 histogram_luminance_size = 0x802C;
constexpr u32 histogram_sink = 0x802D;
constexpr u32 minmax = 0x802E;
constexpr u32 minmax_format = 0x802F;
constexpr u32 minmax_sink = 0x8030;
constexpr u32 table_too_large = 0x8031;
constexpr u32 color_matrix = 0x80B1;
constexpr u32 color_matrix_stack_depth = 0x80B2;
constexpr u32 max_color_matrix_stack_depth = 0x80B3;
constexpr u32 post_color_matrix_red_scale = 0x80B4;
constexpr u32 post_color_matrix_green_scale = 0x80B5;
constexpr u32 post_color_matrix_blue_scale = 0x80B6;
constexpr u32 post_color_matrix_alpha_scale = 0x80B7;
constexpr u32 post_color_matrix_red_bias = 0x80B8;
constexpr u32 post_color_matrix_green_bias = 0x80B9;
constexpr u32 post_color_matrix_blue_bias = 0x80BA;
constexpr u32 post_color_matrix_alpha_bias = 0x80BB;
constexpr u32 color_table = 0x80D0;
constexpr u32 post_convolution_color_table = 0x80D1;
constexpr u32 post_color_matrix_color_table = 0x80D2;
constexpr u32 proxy_color_table = 0x80D3;
constexpr u32 proxy_post_convolution_color_table = 0x80D4;
constexpr u32 proxy_post_color_matrix_color_table = 0x80D5;
constexpr u32 color_table_scale = 0x80D6;
constexpr u32 color_table_bias = 0x80D7;
constexpr u32 color_table_format = 0x80D8;
constexpr u32 color_table_width = 0x80D9;
constexpr u32 color_table_red_size = 0x80DA;
constexpr u32 color_table_green_size = 0x80DB;
constexpr u32 color_table_blue_size = 0x80DC;
constexpr u32 color_table_alpha_size = 0x80DD;
constexpr u32 color_table_luminance_size = 0x80DE;
constexpr u32 color_table_intensity_size = 0x80DF;
constexpr u32 constant_border = 0x8151;
constexpr u32 replicate_border = 0x8153;
constexpr u32 convolution_border_color = 0x8154;
template<
    class vec_4_f32
>
requires (
    semantic::concepts::Vector<vec_4_f32, f32, 4>)
STATICINLINE void blend_color(vec_4_f32 const& red)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendColor)
                Throw(undefined_behavior(
                    "unloaded function BlendColor"));
    }
    glBlendColor(red.x(), red.y(), red.z(), red.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void blend_equation(groups::blend_equation_mode_ext mode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendEquation)
                Throw(undefined_behavior(
                    "unloaded function BlendEquation"));
    }
    glBlendEquation(static_cast<GLenum>(mode));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void color_sub_table(groups::color_table_target target, i32 start, i32 count, groups::pixel_format format, groups::pixel_type type, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColorSubTable)
                Throw(undefined_behavior(
                    "unloaded function ColorSubTable"));
    }
    glColorSubTable(static_cast<GLenum>(target), start, count, static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void color_table(groups::color_table_target target, groups::internal_format internalformat, i32 width, groups::pixel_format format, groups::pixel_type type, span_const_byte const& table)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColorTable)
                Throw(undefined_behavior(
                    "unloaded function ColorTable"));
    }
    glColorTable(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<const void *>(table.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void color_table_parameter(groups::color_table_target target, groups::color_table_parameter_prop_sgi pname, span_const_f32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColorTableParameterfv)
                Throw(undefined_behavior(
                    "unloaded function ColorTableParameterfv"));
    }
    glColorTableParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<const GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void color_table_parameter(groups::color_table_target target, groups::color_table_parameter_prop_sgi pname, span_const_i32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColorTableParameteriv)
                Throw(undefined_behavior(
                    "unloaded function ColorTableParameteriv"));
    }
    glColorTableParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<const GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void convolution_filter_1d(groups::convolution_target target, groups::internal_format internalformat, i32 width, groups::pixel_format format, groups::pixel_type type, span_const_byte const& image)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glConvolutionFilter1D)
                Throw(undefined_behavior(
                    "unloaded function ConvolutionFilter1D"));
    }
    glConvolutionFilter1D(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<const void *>(image.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void convolution_filter_2d(groups::convolution_target target, groups::internal_format internalformat, vec_2_i32 const& width, groups::pixel_format format, groups::pixel_type type, span_const_byte const& image)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glConvolutionFilter2D)
                Throw(undefined_behavior(
                    "unloaded function ConvolutionFilter2D"));
    }
    glConvolutionFilter2D(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width[0], width[1], static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<const void *>(image.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void convolution_parameter(groups::convolution_target target, groups::convolution_parameter_ext pname, f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glConvolutionParameterf)
                Throw(undefined_behavior(
                    "unloaded function ConvolutionParameterf"));
    }
    glConvolutionParameterf(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void convolution_parameter(groups::convolution_target target, groups::convolution_parameter_ext pname, span_const_f32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glConvolutionParameterfv)
                Throw(undefined_behavior(
                    "unloaded function ConvolutionParameterfv"));
    }
    glConvolutionParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<const GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void convolution_parameter(groups::convolution_target target, groups::convolution_parameter_ext pname, i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glConvolutionParameteri)
                Throw(undefined_behavior(
                    "unloaded function ConvolutionParameteri"));
    }
    glConvolutionParameteri(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void convolution_parameter(groups::convolution_target target, groups::convolution_parameter_ext pname, span_const_i32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glConvolutionParameteriv)
                Throw(undefined_behavior(
                    "unloaded function ConvolutionParameteriv"));
    }
    glConvolutionParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<const GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void copy_color_sub_table(groups::color_table_target target, i32 start, vec_2_i32 const& x, i32 width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCopyColorSubTable)
                Throw(undefined_behavior(
                    "unloaded function CopyColorSubTable"));
    }
    glCopyColorSubTable(static_cast<GLenum>(target), start, x.x(), x.y(), width);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void copy_color_table(groups::color_table_target target, groups::internal_format internalformat, vec_2_i32 const& x, i32 width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCopyColorTable)
                Throw(undefined_behavior(
                    "unloaded function CopyColorTable"));
    }
    glCopyColorTable(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), x.x(), x.y(), width);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void copy_convolution_filter_1d(groups::convolution_target target, groups::internal_format internalformat, vec_2_i32 const& x, i32 width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCopyConvolutionFilter1D)
                Throw(undefined_behavior(
                    "unloaded function CopyConvolutionFilter1D"));
    }
    glCopyConvolutionFilter1D(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), x.x(), x.y(), width);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void copy_convolution_filter_2d(groups::convolution_target target, groups::internal_format internalformat, vec_2_i32 const& x, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCopyConvolutionFilter2D)
                Throw(undefined_behavior(
                    "unloaded function CopyConvolutionFilter2D"));
    }
    glCopyConvolutionFilter2D(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), x.x(), x.y(), width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_color_table(groups::color_table_target target, groups::pixel_format format, groups::pixel_type type, span_byte table)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetColorTable)
                Throw(undefined_behavior(
                    "unloaded function GetColorTable"));
    }
    glGetColorTable(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<void *>(table.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_color_table_parameter(groups::color_table_target target, groups::get_color_table_parameter_prop_sgi pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetColorTableParameterfv)
                Throw(undefined_behavior(
                    "unloaded function GetColorTableParameterfv"));
    }
    glGetColorTableParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_color_table_parameter(groups::color_table_target target, groups::get_color_table_parameter_prop_sgi pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetColorTableParameteriv)
                Throw(undefined_behavior(
                    "unloaded function GetColorTableParameteriv"));
    }
    glGetColorTableParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_convolution_filter(groups::convolution_target target, groups::pixel_format format, groups::pixel_type type, span_byte image)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetConvolutionFilter)
                Throw(undefined_behavior(
                    "unloaded function GetConvolutionFilter"));
    }
    glGetConvolutionFilter(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<void *>(image.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_convolution_parameter(groups::convolution_target target, groups::convolution_parameter_ext pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetConvolutionParameterfv)
                Throw(undefined_behavior(
                    "unloaded function GetConvolutionParameterfv"));
    }
    glGetConvolutionParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_convolution_parameter(groups::convolution_target target, groups::convolution_parameter_ext pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetConvolutionParameteriv)
                Throw(undefined_behavior(
                    "unloaded function GetConvolutionParameteriv"));
    }
    glGetConvolutionParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_histogram(groups::histogram_target_ext target, bool reset, groups::pixel_format format, groups::pixel_type type, span_byte values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetHistogram)
                Throw(undefined_behavior(
                    "unloaded function GetHistogram"));
    }
    glGetHistogram(static_cast<GLenum>(target), reset, static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<void *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_histogram_parameter(groups::histogram_target_ext target, groups::get_histogram_parameter_prop_ext pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetHistogramParameterfv)
                Throw(undefined_behavior(
                    "unloaded function GetHistogramParameterfv"));
    }
    glGetHistogramParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_histogram_parameter(groups::histogram_target_ext target, groups::get_histogram_parameter_prop_ext pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetHistogramParameteriv)
                Throw(undefined_behavior(
                    "unloaded function GetHistogramParameteriv"));
    }
    glGetHistogramParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_minmax(groups::minmax_target_ext target, bool reset, groups::pixel_format format, groups::pixel_type type, span_byte values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetMinmax)
                Throw(undefined_behavior(
                    "unloaded function GetMinmax"));
    }
    glGetMinmax(static_cast<GLenum>(target), reset, static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<void *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_minmax_parameter(groups::minmax_target_ext target, groups::get_minmax_parameter_prop_ext pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetMinmaxParameterfv)
                Throw(undefined_behavior(
                    "unloaded function GetMinmaxParameterfv"));
    }
    glGetMinmaxParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_minmax_parameter(groups::minmax_target_ext target, groups::get_minmax_parameter_prop_ext pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetMinmaxParameteriv)
                Throw(undefined_behavior(
                    "unloaded function GetMinmaxParameteriv"));
    }
    glGetMinmaxParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_separable_filter(groups::separable_target_ext target, groups::pixel_format format, groups::pixel_type type, span_byte row, span_byte column, span_byte span)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetSeparableFilter)
                Throw(undefined_behavior(
                    "unloaded function GetSeparableFilter"));
    }
    glGetSeparableFilter(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<void *>(row.data()), reinterpret_cast<void *>(column.data()), reinterpret_cast<void *>(span.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void histogram(groups::histogram_target_ext target, i32 width, groups::internal_format internalformat, bool sink)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glHistogram)
                Throw(undefined_behavior(
                    "unloaded function Histogram"));
    }
    glHistogram(static_cast<GLenum>(target), width, static_cast<GLenum>(internalformat), sink);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void minmax(groups::minmax_target_ext target, groups::internal_format internalformat, bool sink)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMinmax)
                Throw(undefined_behavior(
                    "unloaded function Minmax"));
    }
    glMinmax(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), sink);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void reset_histogram(groups::histogram_target_ext target)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glResetHistogram)
                Throw(undefined_behavior(
                    "unloaded function ResetHistogram"));
    }
    glResetHistogram(static_cast<GLenum>(target));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void reset_minmax(groups::minmax_target_ext target)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glResetMinmax)
                Throw(undefined_behavior(
                    "unloaded function ResetMinmax"));
    }
    glResetMinmax(static_cast<GLenum>(target));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void separable_filter_2d(groups::separable_target_ext target, groups::internal_format internalformat, vec_2_i32 const& width, groups::pixel_format format, groups::pixel_type type, span_const_byte const& row, span_const_byte const& column)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSeparableFilter2D)
                Throw(undefined_behavior(
                    "unloaded function SeparableFilter2D"));
    }
    glSeparableFilter2D(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width[0], width[1], static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<const void *>(row.data()), reinterpret_cast<const void *>(column.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_imaging
#endif // GL_ARB_imaging
#ifdef GL_ARB_indirect_parameters
namespace arb_indirect_parameters {
constexpr u32 parameter_buffer_arb = 0x80EE;
constexpr u32 parameter_buffer_binding_arb = 0x80EF;
STATICINLINE void multi_draw_arrays_indirect_count_arb(groups::primitive_type mode, ptroff indirect, GLintptr drawcount, i32 maxdrawcount, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiDrawArraysIndirectCountARB)
                Throw(undefined_behavior(
                    "unloaded function MultiDrawArraysIndirectCountARB"));
    }
    glMultiDrawArraysIndirectCountARB(static_cast<GLenum>(mode), reinterpret_cast<const void*>(indirect), drawcount, maxdrawcount, stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_draw_elements_indirect_count_arb(groups::primitive_type mode, groups::draw_elements_type type, ptroff indirect, GLintptr drawcount, i32 maxdrawcount, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiDrawElementsIndirectCountARB)
                Throw(undefined_behavior(
                    "unloaded function MultiDrawElementsIndirectCountARB"));
    }
    glMultiDrawElementsIndirectCountARB(static_cast<GLenum>(mode), static_cast<GLenum>(type), reinterpret_cast<const void*>(indirect), drawcount, maxdrawcount, stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_indirect_parameters
#endif // GL_ARB_indirect_parameters
#ifdef GL_ARB_instanced_arrays
namespace arb_instanced_arrays {
constexpr u32 vertex_attrib_array_divisor_arb = 0x88FE;
STATICINLINE void vertex_attrib_divisor_arb(u32 index, u32 divisor)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribDivisorARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribDivisorARB"));
    }
    glVertexAttribDivisorARB(index, divisor);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_instanced_arrays
#endif // GL_ARB_instanced_arrays
#ifdef GL_ARB_internalformat_query
namespace arb_internalformat_query {
constexpr u32 num_sample_counts = 0x9380;
template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_internalformativ(groups::texture_target target, groups::internal_format internalformat, groups::internal_format_prop pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetInternalformativ)
                Throw(undefined_behavior(
                    "unloaded function GetInternalformativ"));
    }
    glGetInternalformativ(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), static_cast<GLenum>(pname), params.size(), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_internalformat_query
#endif // GL_ARB_internalformat_query
#ifdef GL_ARB_internalformat_query2
namespace arb_internalformat_query2 {
constexpr u32 texture_1d = 0x0DE0;
constexpr u32 texture_2d = 0x0DE1;
constexpr u32 texture_3d = 0x806F;
constexpr u32 samples = 0x80A9;
constexpr u32 internalformat_supported = 0x826F;
constexpr u32 internalformat_preferred = 0x8270;
constexpr u32 internalformat_red_size = 0x8271;
constexpr u32 internalformat_green_size = 0x8272;
constexpr u32 internalformat_blue_size = 0x8273;
constexpr u32 internalformat_alpha_size = 0x8274;
constexpr u32 internalformat_depth_size = 0x8275;
constexpr u32 internalformat_stencil_size = 0x8276;
constexpr u32 internalformat_shared_size = 0x8277;
constexpr u32 internalformat_red_type = 0x8278;
constexpr u32 internalformat_green_type = 0x8279;
constexpr u32 internalformat_blue_type = 0x827A;
constexpr u32 internalformat_alpha_type = 0x827B;
constexpr u32 internalformat_depth_type = 0x827C;
constexpr u32 internalformat_stencil_type = 0x827D;
constexpr u32 max_width = 0x827E;
constexpr u32 max_height = 0x827F;
constexpr u32 max_depth = 0x8280;
constexpr u32 max_layers = 0x8281;
constexpr u32 max_combined_dimensions = 0x8282;
constexpr u32 color_components = 0x8283;
constexpr u32 depth_components = 0x8284;
constexpr u32 stencil_components = 0x8285;
constexpr u32 color_renderable = 0x8286;
constexpr u32 depth_renderable = 0x8287;
constexpr u32 stencil_renderable = 0x8288;
constexpr u32 framebuffer_renderable = 0x8289;
constexpr u32 framebuffer_renderable_layered = 0x828A;
constexpr u32 framebuffer_blend = 0x828B;
constexpr u32 read_pixels = 0x828C;
constexpr u32 read_pixels_format = 0x828D;
constexpr u32 read_pixels_type = 0x828E;
constexpr u32 texture_image_format = 0x828F;
constexpr u32 texture_image_type = 0x8290;
constexpr u32 get_texture_image_format = 0x8291;
constexpr u32 get_texture_image_type = 0x8292;
constexpr u32 mipmap = 0x8293;
constexpr u32 manual_generate_mipmap = 0x8294;
constexpr u32 auto_generate_mipmap = 0x8295;
constexpr u32 color_encoding = 0x8296;
constexpr u32 srgb_read = 0x8297;
constexpr u32 srgb_write = 0x8298;
constexpr u32 srgb_decode_arb = 0x8299;
constexpr u32 filter = 0x829A;
constexpr u32 vertex_texture = 0x829B;
constexpr u32 tess_control_texture = 0x829C;
constexpr u32 tess_evaluation_texture = 0x829D;
constexpr u32 geometry_texture = 0x829E;
constexpr u32 fragment_texture = 0x829F;
constexpr u32 compute_texture = 0x82A0;
constexpr u32 texture_shadow = 0x82A1;
constexpr u32 texture_gather = 0x82A2;
constexpr u32 texture_gather_shadow = 0x82A3;
constexpr u32 shader_image_load = 0x82A4;
constexpr u32 shader_image_store = 0x82A5;
constexpr u32 shader_image_atomic = 0x82A6;
constexpr u32 image_texel_size = 0x82A7;
constexpr u32 image_compatibility_class = 0x82A8;
constexpr u32 image_pixel_format = 0x82A9;
constexpr u32 image_pixel_type = 0x82AA;
constexpr u32 simultaneous_texture_and_depth_test = 0x82AC;
constexpr u32 simultaneous_texture_and_stencil_test = 0x82AD;
constexpr u32 simultaneous_texture_and_depth_write = 0x82AE;
constexpr u32 simultaneous_texture_and_stencil_write = 0x82AF;
constexpr u32 texture_compressed_block_width = 0x82B1;
constexpr u32 texture_compressed_block_height = 0x82B2;
constexpr u32 texture_compressed_block_size = 0x82B3;
constexpr u32 clear_buffer = 0x82B4;
constexpr u32 texture_view = 0x82B5;
constexpr u32 view_compatibility_class = 0x82B6;
constexpr u32 full_support = 0x82B7;
constexpr u32 caveat_support = 0x82B8;
constexpr u32 image_class_4_x_32 = 0x82B9;
constexpr u32 image_class_2_x_32 = 0x82BA;
constexpr u32 image_class_1_x_32 = 0x82BB;
constexpr u32 image_class_4_x_16 = 0x82BC;
constexpr u32 image_class_2_x_16 = 0x82BD;
constexpr u32 image_class_1_x_16 = 0x82BE;
constexpr u32 image_class_4_x_8 = 0x82BF;
constexpr u32 image_class_2_x_8 = 0x82C0;
constexpr u32 image_class_1_x_8 = 0x82C1;
constexpr u32 image_class_11_11_10 = 0x82C2;
constexpr u32 image_class_10_10_10_2 = 0x82C3;
constexpr u32 view_class_128_bits = 0x82C4;
constexpr u32 view_class_96_bits = 0x82C5;
constexpr u32 view_class_64_bits = 0x82C6;
constexpr u32 view_class_48_bits = 0x82C7;
constexpr u32 view_class_32_bits = 0x82C8;
constexpr u32 view_class_24_bits = 0x82C9;
constexpr u32 view_class_16_bits = 0x82CA;
constexpr u32 view_class_8_bits = 0x82CB;
constexpr u32 view_class_s3tc_dxt1_rgb = 0x82CC;
constexpr u32 view_class_s3tc_dxt1_rgba = 0x82CD;
constexpr u32 view_class_s3tc_dxt3_rgba = 0x82CE;
constexpr u32 view_class_s3tc_dxt5_rgba = 0x82CF;
constexpr u32 view_class_rgtc1_red = 0x82D0;
constexpr u32 view_class_rgtc2_rg = 0x82D1;
constexpr u32 view_class_bptc_unorm = 0x82D2;
constexpr u32 view_class_bptc_float = 0x82D3;
constexpr u32 texture_rectangle = 0x84F5;
constexpr u32 texture_cube_map = 0x8513;
constexpr u32 texture_compressed = 0x86A1;
constexpr u32 texture_1d_array = 0x8C18;
constexpr u32 texture_2d_array = 0x8C1A;
constexpr u32 texture_buffer = 0x8C2A;
constexpr u32 renderbuffer = 0x8D41;
constexpr u32 texture_cube_map_array = 0x9009;
constexpr u32 image_format_compatibility_type = 0x90C7;
constexpr u32 texture_2d_multisample = 0x9100;
constexpr u32 texture_2d_multisample_array = 0x9102;
constexpr u32 num_sample_counts = 0x9380;
constexpr u32 view_class_eac_r11 = 0x9383;
constexpr u32 view_class_eac_rg11 = 0x9384;
constexpr u32 view_class_etc2_rgb = 0x9385;
constexpr u32 view_class_etc2_rgba = 0x9386;
constexpr u32 view_class_etc2_eac_rgba = 0x9387;
constexpr u32 view_class_astc_4x4_rgba = 0x9388;
constexpr u32 view_class_astc_5x4_rgba = 0x9389;
constexpr u32 view_class_astc_5x5_rgba = 0x938A;
constexpr u32 view_class_astc_6x5_rgba = 0x938B;
constexpr u32 view_class_astc_6x6_rgba = 0x938C;
constexpr u32 view_class_astc_8x5_rgba = 0x938D;
constexpr u32 view_class_astc_8x6_rgba = 0x938E;
constexpr u32 view_class_astc_8x8_rgba = 0x938F;
constexpr u32 view_class_astc_10x5_rgba = 0x9390;
constexpr u32 view_class_astc_10x6_rgba = 0x9391;
constexpr u32 view_class_astc_10x8_rgba = 0x9392;
constexpr u32 view_class_astc_10x10_rgba = 0x9393;
constexpr u32 view_class_astc_12x10_rgba = 0x9394;
constexpr u32 view_class_astc_12x12_rgba = 0x9395;
template<
    class span_i64
>
requires (
    semantic::concepts::Span<span_i64> &&
    std::is_same_v<std::decay_t<typename span_i64::value_type>, i64>)
STATICINLINE void get_internalformati64v(groups::texture_target target, groups::internal_format internalformat, groups::internal_format_prop pname, span_i64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetInternalformati64v)
                Throw(undefined_behavior(
                    "unloaded function GetInternalformati64v"));
    }
    glGetInternalformati64v(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), static_cast<GLenum>(pname), params.size(), reinterpret_cast<GLint64 *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_internalformat_query2
#endif // GL_ARB_internalformat_query2
#ifdef GL_ARB_invalidate_subdata
namespace arb_invalidate_subdata {
STATICINLINE void invalidate_buffer_data(u32 buffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glInvalidateBufferData)
                Throw(undefined_behavior(
                    "unloaded function InvalidateBufferData"));
        glIsBuffer(buffer);
    }
    glInvalidateBufferData(buffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void invalidate_buffer_sub_data(u32 buffer, GLintptr offset, GLsizeiptr length)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glInvalidateBufferSubData)
                Throw(undefined_behavior(
                    "unloaded function InvalidateBufferSubData"));
        glIsBuffer(buffer);
    }
    glInvalidateBufferSubData(buffer, offset, length);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLenum
>
requires (
    semantic::concepts::Span<span_const_GLenum> &&
    std::is_same_v<std::decay_t<typename span_const_GLenum::value_type>, GLenum>)
STATICINLINE void invalidate_framebuffer(groups::framebuffer_target target, span_const_GLenum const& attachments)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glInvalidateFramebuffer)
                Throw(undefined_behavior(
                    "unloaded function InvalidateFramebuffer"));
    }
    glInvalidateFramebuffer(static_cast<GLenum>(target), attachments.size(), reinterpret_cast<const GLenum *>(attachments.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLenum,
    class vec_2_i32
>
requires (
    semantic::concepts::Span<span_const_GLenum> &&
    std::is_same_v<std::decay_t<typename span_const_GLenum::value_type>, GLenum> &&
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void invalidate_sub_framebuffer(groups::framebuffer_target target, span_const_GLenum const& attachments, vec_2_i32 const& x, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glInvalidateSubFramebuffer)
                Throw(undefined_behavior(
                    "unloaded function InvalidateSubFramebuffer"));
    }
    glInvalidateSubFramebuffer(static_cast<GLenum>(target), attachments.size(), reinterpret_cast<const GLenum *>(attachments.data()), x.x(), x.y(), width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void invalidate_tex_image(u32 texture, i32 level)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glInvalidateTexImage)
                Throw(undefined_behavior(
                    "unloaded function InvalidateTexImage"));
        glIsTexture(texture);
    }
    glInvalidateTexImage(texture, level);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void invalidate_tex_sub_image(u32 texture, i32 level, vec_3_i32 const& xoffset, vec_3_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glInvalidateTexSubImage)
                Throw(undefined_behavior(
                    "unloaded function InvalidateTexSubImage"));
        glIsTexture(texture);
    }
    glInvalidateTexSubImage(texture, level, xoffset.x(), xoffset.y(), xoffset.z(), width[0], width[1], width[2]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_invalidate_subdata
#endif // GL_ARB_invalidate_subdata
#ifdef GL_ARB_map_buffer_alignment
namespace arb_map_buffer_alignment {
constexpr u32 min_map_buffer_alignment = 0x90BC;
} // arb_map_buffer_alignment
#endif // GL_ARB_map_buffer_alignment
#ifdef GL_ARB_map_buffer_range
namespace arb_map_buffer_range {
constexpr u32 map_read_bit = 0x0001;
constexpr u32 map_write_bit = 0x0002;
constexpr u32 map_invalidate_range_bit = 0x0004;
constexpr u32 map_invalidate_buffer_bit = 0x0008;
constexpr u32 map_flush_explicit_bit = 0x0010;
constexpr u32 map_unsynchronized_bit = 0x0020;
STATICINLINE void flush_mapped_buffer_range(groups::buffer_target_arb target, GLintptr offset, GLsizeiptr length)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFlushMappedBufferRange)
                Throw(undefined_behavior(
                    "unloaded function FlushMappedBufferRange"));
    }
    glFlushMappedBufferRange(static_cast<GLenum>(target), offset, length);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void * map_buffer_range(groups::buffer_target_arb target, GLintptr offset, GLsizeiptr length, groups::map_buffer_access_mask access)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMapBufferRange)
                Throw(undefined_behavior(
                    "unloaded function MapBufferRange"));
    }
    auto out = glMapBufferRange(static_cast<GLenum>(target), offset, length, static_cast<GLenum>(access));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // arb_map_buffer_range
#endif // GL_ARB_map_buffer_range
#ifdef GL_ARB_matrix_palette
namespace arb_matrix_palette {
constexpr u32 matrix_palette_arb = 0x8840;
constexpr u32 max_matrix_palette_stack_depth_arb = 0x8841;
constexpr u32 max_palette_matrices_arb = 0x8842;
constexpr u32 current_palette_matrix_arb = 0x8843;
constexpr u32 matrix_index_array_arb = 0x8844;
constexpr u32 current_matrix_index_arb = 0x8845;
constexpr u32 matrix_index_array_size_arb = 0x8846;
constexpr u32 matrix_index_array_type_arb = 0x8847;
constexpr u32 matrix_index_array_stride_arb = 0x8848;
constexpr u32 matrix_index_array_pointer_arb = 0x8849;
STATICINLINE void current_palette_matrix_arb(i32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCurrentPaletteMatrixARB)
                Throw(undefined_behavior(
                    "unloaded function CurrentPaletteMatrixARB"));
    }
    glCurrentPaletteMatrixARB(index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void matrix_index_pointer_arb(i32 size, groups::matrix_index_pointer_type_arb type, i32 stride, span_const_byte const& pointer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixIndexPointerARB)
                Throw(undefined_behavior(
                    "unloaded function MatrixIndexPointerARB"));
    }
    glMatrixIndexPointerARB(size, static_cast<GLenum>(type), stride, reinterpret_cast<const void *>(pointer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u8
>
requires (
    semantic::concepts::Span<span_const_u8> &&
    std::is_same_v<std::decay_t<typename span_const_u8::value_type>, u8>)
STATICINLINE void matrix_indexubv_arb(span_const_u8 const& indices)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixIndexubvARB)
                Throw(undefined_behavior(
                    "unloaded function MatrixIndexubvARB"));
    }
    glMatrixIndexubvARB(indices.size(), reinterpret_cast<const GLubyte *>(indices.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void matrix_indexuiv_arb(span_const_u32 const& indices)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixIndexuivARB)
                Throw(undefined_behavior(
                    "unloaded function MatrixIndexuivARB"));
    }
    glMatrixIndexuivARB(indices.size(), reinterpret_cast<const GLuint *>(indices.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u16
>
requires (
    semantic::concepts::Span<span_const_u16> &&
    std::is_same_v<std::decay_t<typename span_const_u16::value_type>, u16>)
STATICINLINE void matrix_indexusv_arb(span_const_u16 const& indices)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixIndexusvARB)
                Throw(undefined_behavior(
                    "unloaded function MatrixIndexusvARB"));
    }
    glMatrixIndexusvARB(indices.size(), reinterpret_cast<const GLushort *>(indices.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_matrix_palette
#endif // GL_ARB_matrix_palette
#ifdef GL_ARB_multi_bind
namespace arb_multi_bind {
template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void bind_buffers_base(groups::buffer_target_arb target, u32 first, span_const_u32 const& buffers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindBuffersBase)
                Throw(undefined_behavior(
                    "unloaded function BindBuffersBase"));
    }
    glBindBuffersBase(static_cast<GLenum>(target), first, buffers.size(), reinterpret_cast<const GLuint *>(buffers.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLintptr,
    class span_const_GLsizeiptr,
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32> &&
    semantic::concepts::Span<span_const_GLintptr> &&
    std::is_same_v<std::decay_t<typename span_const_GLintptr::value_type>, GLintptr> &&
    semantic::concepts::Span<span_const_GLsizeiptr> &&
    std::is_same_v<std::decay_t<typename span_const_GLsizeiptr::value_type>, GLsizeiptr>)
STATICINLINE void bind_buffers_range(groups::buffer_target_arb target, u32 first, span_const_u32 const& buffers, span_const_GLintptr const& offsets, span_const_GLsizeiptr const& sizes)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindBuffersRange)
                Throw(undefined_behavior(
                    "unloaded function BindBuffersRange"));
    }
    glBindBuffersRange(static_cast<GLenum>(target), first, buffers.size(), reinterpret_cast<const GLuint *>(buffers.data()), reinterpret_cast<const GLintptr *>(offsets.data()), reinterpret_cast<const GLsizeiptr *>(sizes.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void bind_image_textures(u32 first, span_const_u32 const& textures)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindImageTextures)
                Throw(undefined_behavior(
                    "unloaded function BindImageTextures"));
    }
    glBindImageTextures(first, textures.size(), reinterpret_cast<const GLuint *>(textures.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void bind_samplers(u32 first, span_const_u32 const& samplers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindSamplers)
                Throw(undefined_behavior(
                    "unloaded function BindSamplers"));
    }
    glBindSamplers(first, samplers.size(), reinterpret_cast<const GLuint *>(samplers.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void bind_textures(u32 first, span_const_u32 const& textures)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindTextures)
                Throw(undefined_behavior(
                    "unloaded function BindTextures"));
    }
    glBindTextures(first, textures.size(), reinterpret_cast<const GLuint *>(textures.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLintptr,
    class span_const_i32,
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32> &&
    semantic::concepts::Span<span_const_GLintptr> &&
    std::is_same_v<std::decay_t<typename span_const_GLintptr::value_type>, GLintptr> &&
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void bind_vertex_buffers(u32 first, span_const_u32 const& buffers, span_const_GLintptr const& offsets, span_const_i32 const& strides)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindVertexBuffers)
                Throw(undefined_behavior(
                    "unloaded function BindVertexBuffers"));
    }
    glBindVertexBuffers(first, buffers.size(), reinterpret_cast<const GLuint *>(buffers.data()), reinterpret_cast<const GLintptr *>(offsets.data()), reinterpret_cast<const GLsizei *>(strides.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_multi_bind
#endif // GL_ARB_multi_bind
#ifdef GL_ARB_multi_draw_indirect
namespace arb_multi_draw_indirect {
STATICINLINE void multi_draw_arrays_indirect(groups::primitive_type mode, ptroff indirect, i32 drawcount, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiDrawArraysIndirect)
                Throw(undefined_behavior(
                    "unloaded function MultiDrawArraysIndirect"));
    }
    glMultiDrawArraysIndirect(static_cast<GLenum>(mode), reinterpret_cast<const void*>(indirect), drawcount, stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_draw_elements_indirect(groups::primitive_type mode, groups::draw_elements_type type, ptroff indirect, i32 drawcount, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiDrawElementsIndirect)
                Throw(undefined_behavior(
                    "unloaded function MultiDrawElementsIndirect"));
    }
    glMultiDrawElementsIndirect(static_cast<GLenum>(mode), static_cast<GLenum>(type), reinterpret_cast<const void*>(indirect), drawcount, stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_multi_draw_indirect
#endif // GL_ARB_multi_draw_indirect
#ifdef GL_ARB_multisample
namespace arb_multisample {
constexpr u32 multisample_bit_arb = 0x20000000;
constexpr u32 multisample_arb = 0x809D;
constexpr u32 sample_alpha_to_coverage_arb = 0x809E;
constexpr u32 sample_alpha_to_one_arb = 0x809F;
constexpr u32 sample_coverage_arb = 0x80A0;
constexpr u32 sample_buffers_arb = 0x80A8;
constexpr u32 samples_arb = 0x80A9;
constexpr u32 sample_coverage_value_arb = 0x80AA;
constexpr u32 sample_coverage_invert_arb = 0x80AB;
STATICINLINE void sample_coverage_arb(f32 value, bool invert)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSampleCoverageARB)
                Throw(undefined_behavior(
                    "unloaded function SampleCoverageARB"));
    }
    glSampleCoverageARB(value, invert);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_multisample
#endif // GL_ARB_multisample
#ifdef GL_ARB_multitexture
namespace arb_multitexture {
constexpr u32 texture0_arb = 0x84C0;
constexpr u32 texture1_arb = 0x84C1;
constexpr u32 texture2_arb = 0x84C2;
constexpr u32 texture3_arb = 0x84C3;
constexpr u32 texture4_arb = 0x84C4;
constexpr u32 texture5_arb = 0x84C5;
constexpr u32 texture6_arb = 0x84C6;
constexpr u32 texture7_arb = 0x84C7;
constexpr u32 texture8_arb = 0x84C8;
constexpr u32 texture9_arb = 0x84C9;
constexpr u32 texture10_arb = 0x84CA;
constexpr u32 texture11_arb = 0x84CB;
constexpr u32 texture12_arb = 0x84CC;
constexpr u32 texture13_arb = 0x84CD;
constexpr u32 texture14_arb = 0x84CE;
constexpr u32 texture15_arb = 0x84CF;
constexpr u32 texture16_arb = 0x84D0;
constexpr u32 texture17_arb = 0x84D1;
constexpr u32 texture18_arb = 0x84D2;
constexpr u32 texture19_arb = 0x84D3;
constexpr u32 texture20_arb = 0x84D4;
constexpr u32 texture21_arb = 0x84D5;
constexpr u32 texture22_arb = 0x84D6;
constexpr u32 texture23_arb = 0x84D7;
constexpr u32 texture24_arb = 0x84D8;
constexpr u32 texture25_arb = 0x84D9;
constexpr u32 texture26_arb = 0x84DA;
constexpr u32 texture27_arb = 0x84DB;
constexpr u32 texture28_arb = 0x84DC;
constexpr u32 texture29_arb = 0x84DD;
constexpr u32 texture30_arb = 0x84DE;
constexpr u32 texture31_arb = 0x84DF;
constexpr u32 active_texture_arb = 0x84E0;
constexpr u32 client_active_texture_arb = 0x84E1;
constexpr u32 max_texture_units_arb = 0x84E2;
STATICINLINE void active_texture_arb(groups::texture_unit texture)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glActiveTextureARB)
                Throw(undefined_behavior(
                    "unloaded function ActiveTextureARB"));
    }
    glActiveTextureARB(static_cast<GLenum>(texture));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void client_active_texture_arb(groups::texture_unit texture)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClientActiveTextureARB)
                Throw(undefined_behavior(
                    "unloaded function ClientActiveTextureARB"));
    }
    glClientActiveTextureARB(static_cast<GLenum>(texture));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord1d_arb(groups::texture_unit target, f64 s)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord1dARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord1dARB"));
    }
    glMultiTexCoord1dARB(static_cast<GLenum>(target), s);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f64
>
requires (
    semantic::concepts::Span<span_const_f64> &&
    std::is_same_v<std::decay_t<typename span_const_f64::value_type>, f64>)
STATICINLINE void multi_tex_coord1dv_arb(groups::texture_unit target, span_const_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord1dvARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord1dvARB"));
    }
    glMultiTexCoord1dvARB(static_cast<GLenum>(target), reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord1f_arb(groups::texture_unit target, f32 s)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord1fARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord1fARB"));
    }
    glMultiTexCoord1fARB(static_cast<GLenum>(target), s);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void multi_tex_coord1fv_arb(groups::texture_unit target, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord1fvARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord1fvARB"));
    }
    glMultiTexCoord1fvARB(static_cast<GLenum>(target), reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord1i_arb(groups::texture_unit target, i32 s)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord1iARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord1iARB"));
    }
    glMultiTexCoord1iARB(static_cast<GLenum>(target), s);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void multi_tex_coord1iv_arb(groups::texture_unit target, span_const_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord1ivARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord1ivARB"));
    }
    glMultiTexCoord1ivARB(static_cast<GLenum>(target), reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord1s_arb(groups::texture_unit target, i16 s)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord1sARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord1sARB"));
    }
    glMultiTexCoord1sARB(static_cast<GLenum>(target), s);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i16
>
requires (
    semantic::concepts::Span<span_const_i16> &&
    std::is_same_v<std::decay_t<typename span_const_i16::value_type>, i16>)
STATICINLINE void multi_tex_coord1sv_arb(groups::texture_unit target, span_const_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord1svARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord1svARB"));
    }
    glMultiTexCoord1svARB(static_cast<GLenum>(target), reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord2d_arb(groups::texture_unit target, f64 s, f64 t)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord2dARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord2dARB"));
    }
    glMultiTexCoord2dARB(static_cast<GLenum>(target), s, t);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_f64
>
requires (
    semantic::concepts::Span<span_const_vec_2_f64> &&
    semantic::concepts::Vector<typename span_const_vec_2_f64::value_type, f64, 2>)
STATICINLINE void multi_tex_coord2dv_arb(groups::texture_unit target, span_const_vec_2_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord2dvARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord2dvARB"));
    }
    glMultiTexCoord2dvARB(static_cast<GLenum>(target), reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord2f_arb(groups::texture_unit target, f32 s, f32 t)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord2fARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord2fARB"));
    }
    glMultiTexCoord2fARB(static_cast<GLenum>(target), s, t);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_f32
>
requires (
    semantic::concepts::Span<span_const_vec_2_f32> &&
    semantic::concepts::Vector<typename span_const_vec_2_f32::value_type, f32, 2>)
STATICINLINE void multi_tex_coord2fv_arb(groups::texture_unit target, span_const_vec_2_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord2fvARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord2fvARB"));
    }
    glMultiTexCoord2fvARB(static_cast<GLenum>(target), reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord2i_arb(groups::texture_unit target, i32 s, i32 t)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord2iARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord2iARB"));
    }
    glMultiTexCoord2iARB(static_cast<GLenum>(target), s, t);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_i32
>
requires (
    semantic::concepts::Span<span_const_vec_2_i32> &&
    semantic::concepts::Vector<typename span_const_vec_2_i32::value_type, i32, 2>)
STATICINLINE void multi_tex_coord2iv_arb(groups::texture_unit target, span_const_vec_2_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord2ivARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord2ivARB"));
    }
    glMultiTexCoord2ivARB(static_cast<GLenum>(target), reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord2s_arb(groups::texture_unit target, i16 s, i16 t)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord2sARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord2sARB"));
    }
    glMultiTexCoord2sARB(static_cast<GLenum>(target), s, t);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_i16
>
requires (
    semantic::concepts::Span<span_const_vec_2_i16> &&
    semantic::concepts::Vector<typename span_const_vec_2_i16::value_type, i16, 2>)
STATICINLINE void multi_tex_coord2sv_arb(groups::texture_unit target, span_const_vec_2_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord2svARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord2svARB"));
    }
    glMultiTexCoord2svARB(static_cast<GLenum>(target), reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord3d_arb(groups::texture_unit target, f64 s, f64 t, f64 r)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord3dARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord3dARB"));
    }
    glMultiTexCoord3dARB(static_cast<GLenum>(target), s, t, r);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_f64
>
requires (
    semantic::concepts::Span<span_const_vec_3_f64> &&
    semantic::concepts::Vector<typename span_const_vec_3_f64::value_type, f64, 3>)
STATICINLINE void multi_tex_coord3dv_arb(groups::texture_unit target, span_const_vec_3_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord3dvARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord3dvARB"));
    }
    glMultiTexCoord3dvARB(static_cast<GLenum>(target), reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord3f_arb(groups::texture_unit target, f32 s, f32 t, f32 r)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord3fARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord3fARB"));
    }
    glMultiTexCoord3fARB(static_cast<GLenum>(target), s, t, r);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_f32
>
requires (
    semantic::concepts::Span<span_const_vec_3_f32> &&
    semantic::concepts::Vector<typename span_const_vec_3_f32::value_type, f32, 3>)
STATICINLINE void multi_tex_coord3fv_arb(groups::texture_unit target, span_const_vec_3_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord3fvARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord3fvARB"));
    }
    glMultiTexCoord3fvARB(static_cast<GLenum>(target), reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord3i_arb(groups::texture_unit target, i32 s, i32 t, i32 r)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord3iARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord3iARB"));
    }
    glMultiTexCoord3iARB(static_cast<GLenum>(target), s, t, r);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_i32
>
requires (
    semantic::concepts::Span<span_const_vec_3_i32> &&
    semantic::concepts::Vector<typename span_const_vec_3_i32::value_type, i32, 3>)
STATICINLINE void multi_tex_coord3iv_arb(groups::texture_unit target, span_const_vec_3_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord3ivARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord3ivARB"));
    }
    glMultiTexCoord3ivARB(static_cast<GLenum>(target), reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord3s_arb(groups::texture_unit target, i16 s, i16 t, i16 r)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord3sARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord3sARB"));
    }
    glMultiTexCoord3sARB(static_cast<GLenum>(target), s, t, r);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_i16
>
requires (
    semantic::concepts::Span<span_const_vec_3_i16> &&
    semantic::concepts::Vector<typename span_const_vec_3_i16::value_type, i16, 3>)
STATICINLINE void multi_tex_coord3sv_arb(groups::texture_unit target, span_const_vec_3_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord3svARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord3svARB"));
    }
    glMultiTexCoord3svARB(static_cast<GLenum>(target), reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord4d_arb(groups::texture_unit target, f64 s, f64 t, f64 r, f64 q)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord4dARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord4dARB"));
    }
    glMultiTexCoord4dARB(static_cast<GLenum>(target), s, t, r, q);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f64
>
requires (
    semantic::concepts::Span<span_const_vec_4_f64> &&
    semantic::concepts::Vector<typename span_const_vec_4_f64::value_type, f64, 4>)
STATICINLINE void multi_tex_coord4dv_arb(groups::texture_unit target, span_const_vec_4_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord4dvARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord4dvARB"));
    }
    glMultiTexCoord4dvARB(static_cast<GLenum>(target), reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord4f_arb(groups::texture_unit target, f32 s, f32 t, f32 r, f32 q)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord4fARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord4fARB"));
    }
    glMultiTexCoord4fARB(static_cast<GLenum>(target), s, t, r, q);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f32
>
requires (
    semantic::concepts::Span<span_const_vec_4_f32> &&
    semantic::concepts::Vector<typename span_const_vec_4_f32::value_type, f32, 4>)
STATICINLINE void multi_tex_coord4fv_arb(groups::texture_unit target, span_const_vec_4_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord4fvARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord4fvARB"));
    }
    glMultiTexCoord4fvARB(static_cast<GLenum>(target), reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord4i_arb(groups::texture_unit target, i32 s, i32 t, i32 r, i32 q)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord4iARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord4iARB"));
    }
    glMultiTexCoord4iARB(static_cast<GLenum>(target), s, t, r, q);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_i32
>
requires (
    semantic::concepts::Span<span_const_vec_4_i32> &&
    semantic::concepts::Vector<typename span_const_vec_4_i32::value_type, i32, 4>)
STATICINLINE void multi_tex_coord4iv_arb(groups::texture_unit target, span_const_vec_4_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord4ivARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord4ivARB"));
    }
    glMultiTexCoord4ivARB(static_cast<GLenum>(target), reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord4s_arb(groups::texture_unit target, i16 s, i16 t, i16 r, i16 q)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord4sARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord4sARB"));
    }
    glMultiTexCoord4sARB(static_cast<GLenum>(target), s, t, r, q);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_i16
>
requires (
    semantic::concepts::Span<span_const_vec_4_i16> &&
    semantic::concepts::Vector<typename span_const_vec_4_i16::value_type, i16, 4>)
STATICINLINE void multi_tex_coord4sv_arb(groups::texture_unit target, span_const_vec_4_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord4svARB)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord4svARB"));
    }
    glMultiTexCoord4svARB(static_cast<GLenum>(target), reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_multitexture
#endif // GL_ARB_multitexture
#ifdef GL_ARB_occlusion_query
namespace arb_occlusion_query {
constexpr u32 query_counter_bits_arb = 0x8864;
constexpr u32 current_query_arb = 0x8865;
constexpr u32 query_result_arb = 0x8866;
constexpr u32 query_result_available_arb = 0x8867;
constexpr u32 samples_passed_arb = 0x8914;
STATICINLINE void begin_query_arb(groups::query_target target, u32 id)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBeginQueryARB)
                Throw(undefined_behavior(
                    "unloaded function BeginQueryARB"));
    }
    glBeginQueryARB(static_cast<GLenum>(target), id);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_queries_arb(span_const_u32 const& ids)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteQueriesARB)
                Throw(undefined_behavior(
                    "unloaded function DeleteQueriesARB"));
    }
    glDeleteQueriesARB(ids.size(), reinterpret_cast<const GLuint *>(ids.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void end_query_arb(groups::query_target target)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEndQueryARB)
                Throw(undefined_behavior(
                    "unloaded function EndQueryARB"));
    }
    glEndQueryARB(static_cast<GLenum>(target));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void gen_queries_arb(span_u32 ids)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenQueriesARB)
                Throw(undefined_behavior(
                    "unloaded function GenQueriesARB"));
    }
    glGenQueriesARB(ids.size(), reinterpret_cast<GLuint *>(ids.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_query_objectiv_arb(u32 id, groups::query_object_parameter_name pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetQueryObjectivARB)
                Throw(undefined_behavior(
                    "unloaded function GetQueryObjectivARB"));
    }
    glGetQueryObjectivARB(id, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_query_objectuiv_arb(u32 id, groups::query_object_parameter_name pname, span_u32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetQueryObjectuivARB)
                Throw(undefined_behavior(
                    "unloaded function GetQueryObjectuivARB"));
    }
    glGetQueryObjectuivARB(id, static_cast<GLenum>(pname), reinterpret_cast<GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_queryiv_arb(groups::query_target target, groups::query_parameter_name pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetQueryivARB)
                Throw(undefined_behavior(
                    "unloaded function GetQueryivARB"));
    }
    glGetQueryivARB(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_query_arb(u32 id)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsQueryARB)
                Throw(undefined_behavior(
                    "unloaded function IsQueryARB"));
    }
    auto out = glIsQueryARB(id);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // arb_occlusion_query
#endif // GL_ARB_occlusion_query
#ifdef GL_ARB_occlusion_query2
namespace arb_occlusion_query2 {
constexpr u32 any_samples_passed = 0x8C2F;
} // arb_occlusion_query2
#endif // GL_ARB_occlusion_query2
#ifdef GL_ARB_parallel_shader_compile
namespace arb_parallel_shader_compile {
constexpr u32 max_shader_compiler_threads_arb = 0x91B0;
constexpr u32 completion_status_arb = 0x91B1;
STATICINLINE void max_shader_compiler_threads_arb(u32 count)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMaxShaderCompilerThreadsARB)
                Throw(undefined_behavior(
                    "unloaded function MaxShaderCompilerThreadsARB"));
    }
    glMaxShaderCompilerThreadsARB(count);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_parallel_shader_compile
#endif // GL_ARB_parallel_shader_compile
#ifdef GL_ARB_pipeline_statistics_query
namespace arb_pipeline_statistics_query {
constexpr u32 vertices_submitted_arb = 0x82EE;
constexpr u32 primitives_submitted_arb = 0x82EF;
constexpr u32 vertex_shader_invocations_arb = 0x82F0;
constexpr u32 tess_control_shader_patches_arb = 0x82F1;
constexpr u32 tess_evaluation_shader_invocations_arb = 0x82F2;
constexpr u32 geometry_shader_primitives_emitted_arb = 0x82F3;
constexpr u32 fragment_shader_invocations_arb = 0x82F4;
constexpr u32 compute_shader_invocations_arb = 0x82F5;
constexpr u32 clipping_input_primitives_arb = 0x82F6;
constexpr u32 clipping_output_primitives_arb = 0x82F7;
constexpr u32 geometry_shader_invocations = 0x887F;
} // arb_pipeline_statistics_query
#endif // GL_ARB_pipeline_statistics_query
#ifdef GL_ARB_pixel_buffer_object
namespace arb_pixel_buffer_object {
constexpr u32 pixel_pack_buffer_arb = 0x88EB;
constexpr u32 pixel_unpack_buffer_arb = 0x88EC;
constexpr u32 pixel_pack_buffer_binding_arb = 0x88ED;
constexpr u32 pixel_unpack_buffer_binding_arb = 0x88EF;
} // arb_pixel_buffer_object
#endif // GL_ARB_pixel_buffer_object
#ifdef GL_ARB_point_parameters
namespace arb_point_parameters {
constexpr u32 point_size_min_arb = 0x8126;
constexpr u32 point_size_max_arb = 0x8127;
constexpr u32 point_fade_threshold_size_arb = 0x8128;
constexpr u32 point_distance_attenuation_arb = 0x8129;
STATICINLINE void point_parameterf_arb(groups::point_parameter_name_arb pname, f32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPointParameterfARB)
                Throw(undefined_behavior(
                    "unloaded function PointParameterfARB"));
    }
    glPointParameterfARB(static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void point_parameterfv_arb(groups::point_parameter_name_arb pname, span_const_f32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPointParameterfvARB)
                Throw(undefined_behavior(
                    "unloaded function PointParameterfvARB"));
    }
    glPointParameterfvARB(static_cast<GLenum>(pname), reinterpret_cast<const GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_point_parameters
#endif // GL_ARB_point_parameters
#ifdef GL_ARB_point_sprite
namespace arb_point_sprite {
constexpr u32 point_sprite_arb = 0x8861;
constexpr u32 coord_replace_arb = 0x8862;
} // arb_point_sprite
#endif // GL_ARB_point_sprite
#ifdef GL_ARB_polygon_offset_clamp
namespace arb_polygon_offset_clamp {
constexpr u32 polygon_offset_clamp = 0x8E1B;
STATICINLINE void polygon_offset_clamp(f32 factor, f32 units, f32 clamp)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPolygonOffsetClamp)
                Throw(undefined_behavior(
                    "unloaded function PolygonOffsetClamp"));
    }
    glPolygonOffsetClamp(factor, units, clamp);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_polygon_offset_clamp
#endif // GL_ARB_polygon_offset_clamp
#ifdef GL_ARB_post_depth_coverage
namespace arb_post_depth_coverage {
} // arb_post_depth_coverage
#endif // GL_ARB_post_depth_coverage
#ifdef GL_ARB_program_interface_query
namespace arb_program_interface_query {
constexpr u32 num_compatible_subroutines = 0x8E4A;
constexpr u32 compatible_subroutines = 0x8E4B;
constexpr u32 atomic_counter_buffer = 0x92C0;
constexpr u32 uniform = 0x92E1;
constexpr u32 uniform_block = 0x92E2;
constexpr u32 program_input = 0x92E3;
constexpr u32 program_output = 0x92E4;
constexpr u32 buffer_variable = 0x92E5;
constexpr u32 shader_storage_block = 0x92E6;
constexpr u32 is_per_patch = 0x92E7;
constexpr u32 vertex_subroutine = 0x92E8;
constexpr u32 tess_control_subroutine = 0x92E9;
constexpr u32 tess_evaluation_subroutine = 0x92EA;
constexpr u32 geometry_subroutine = 0x92EB;
constexpr u32 fragment_subroutine = 0x92EC;
constexpr u32 compute_subroutine = 0x92ED;
constexpr u32 vertex_subroutine_uniform = 0x92EE;
constexpr u32 tess_control_subroutine_uniform = 0x92EF;
constexpr u32 tess_evaluation_subroutine_uniform = 0x92F0;
constexpr u32 geometry_subroutine_uniform = 0x92F1;
constexpr u32 fragment_subroutine_uniform = 0x92F2;
constexpr u32 compute_subroutine_uniform = 0x92F3;
constexpr u32 transform_feedback_varying = 0x92F4;
constexpr u32 active_resources = 0x92F5;
constexpr u32 max_name_length = 0x92F6;
constexpr u32 max_num_active_variables = 0x92F7;
constexpr u32 max_num_compatible_subroutines = 0x92F8;
constexpr u32 name_length = 0x92F9;
constexpr u32 type = 0x92FA;
constexpr u32 array_size = 0x92FB;
constexpr u32 offset = 0x92FC;
constexpr u32 block_index = 0x92FD;
constexpr u32 array_stride = 0x92FE;
constexpr u32 matrix_stride = 0x92FF;
constexpr u32 is_row_major = 0x9300;
constexpr u32 atomic_counter_buffer_index = 0x9301;
constexpr u32 buffer_binding = 0x9302;
constexpr u32 buffer_data_size = 0x9303;
constexpr u32 num_active_variables = 0x9304;
constexpr u32 active_variables = 0x9305;
constexpr u32 referenced_by_vertex_shader = 0x9306;
constexpr u32 referenced_by_tess_control_shader = 0x9307;
constexpr u32 referenced_by_tess_evaluation_shader = 0x9308;
constexpr u32 referenced_by_geometry_shader = 0x9309;
constexpr u32 referenced_by_fragment_shader = 0x930A;
constexpr u32 referenced_by_compute_shader = 0x930B;
constexpr u32 top_level_array_size = 0x930C;
constexpr u32 top_level_array_stride = 0x930D;
constexpr u32 location = 0x930E;
constexpr u32 location_index = 0x930F;
template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_program_interfaceiv(u32 program, groups::program_interface programInterface, groups::program_interface_prop pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramInterfaceiv)
                Throw(undefined_behavior(
                    "unloaded function GetProgramInterfaceiv"));
        glIsProgram(program);
    }
    glGetProgramInterfaceiv(program, static_cast<GLenum>(programInterface), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLuint get_program_resource_index(u32 program, groups::program_interface programInterface, std::string_view const& name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramResourceIndex)
                Throw(undefined_behavior(
                    "unloaded function GetProgramResourceIndex"));
        glIsProgram(program);
    }
    auto out = glGetProgramResourceIndex(program, static_cast<GLenum>(programInterface), name.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLint get_program_resource_location(u32 program, groups::program_interface programInterface, std::string_view const& name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramResourceLocation)
                Throw(undefined_behavior(
                    "unloaded function GetProgramResourceLocation"));
        glIsProgram(program);
    }
    auto out = glGetProgramResourceLocation(program, static_cast<GLenum>(programInterface), name.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLint get_program_resource_location_index(u32 program, groups::program_interface programInterface, std::string_view const& name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramResourceLocationIndex)
                Throw(undefined_behavior(
                    "unloaded function GetProgramResourceLocationIndex"));
        glIsProgram(program);
    }
    auto out = glGetProgramResourceLocationIndex(program, static_cast<GLenum>(programInterface), name.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_GLchar
>
requires (
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE void get_program_resource_name(u32 program, groups::program_interface programInterface, u32 index, i32& length, span_GLchar name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramResourceName)
                Throw(undefined_behavior(
                    "unloaded function GetProgramResourceName"));
        glIsProgram(program);
    }
    glGetProgramResourceName(program, static_cast<GLenum>(programInterface), index, name.size(), &length, name.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLenum,
    class span_i32
>
requires (
    semantic::concepts::Span<span_const_GLenum> &&
    std::is_same_v<std::decay_t<typename span_const_GLenum::value_type>, GLenum> &&
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_program_resourceiv(u32 program, groups::program_interface programInterface, u32 index, span_const_GLenum const& props, i32& length, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramResourceiv)
                Throw(undefined_behavior(
                    "unloaded function GetProgramResourceiv"));
        glIsProgram(program);
    }
    glGetProgramResourceiv(program, static_cast<GLenum>(programInterface), index, props.size(), reinterpret_cast<const GLenum *>(props.data()), params.size(), &length, reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_program_interface_query
#endif // GL_ARB_program_interface_query
#ifdef GL_ARB_provoking_vertex
namespace arb_provoking_vertex {
constexpr u32 quads_follow_provoking_vertex_convention = 0x8E4C;
constexpr u32 first_vertex_convention = 0x8E4D;
constexpr u32 last_vertex_convention = 0x8E4E;
constexpr u32 provoking_vertex = 0x8E4F;
STATICINLINE void provoking_vertex(groups::vertex_provoking_mode mode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProvokingVertex)
                Throw(undefined_behavior(
                    "unloaded function ProvokingVertex"));
    }
    glProvokingVertex(static_cast<GLenum>(mode));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_provoking_vertex
#endif // GL_ARB_provoking_vertex
#ifdef GL_ARB_query_buffer_object
namespace arb_query_buffer_object {
constexpr u32 query_buffer_barrier_bit = 0x00008000;
constexpr u32 query_buffer = 0x9192;
constexpr u32 query_buffer_binding = 0x9193;
constexpr u32 query_result_no_wait = 0x9194;
} // arb_query_buffer_object
#endif // GL_ARB_query_buffer_object
#ifdef GL_ARB_robust_buffer_access_behavior
namespace arb_robust_buffer_access_behavior {
} // arb_robust_buffer_access_behavior
#endif // GL_ARB_robust_buffer_access_behavior
#ifdef GL_ARB_robustness
namespace arb_robustness {
constexpr u32 context_flag_robust_access_bit_arb = 0x00000004;
constexpr u32 no_error = 0;
constexpr u32 lose_context_on_reset_arb = 0x8252;
constexpr u32 guilty_context_reset_arb = 0x8253;
constexpr u32 innocent_context_reset_arb = 0x8254;
constexpr u32 unknown_context_reset_arb = 0x8255;
constexpr u32 reset_notification_strategy_arb = 0x8256;
constexpr u32 no_reset_notification_arb = 0x8261;
STATICINLINE GLenum get_graphics_reset_status_arb()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetGraphicsResetStatusARB)
                Throw(undefined_behavior(
                    "unloaded function GetGraphicsResetStatusARB"));
    }
    auto out = glGetGraphicsResetStatusARB();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void getn_compressed_tex_image_arb(groups::texture_target target, i32 lod, span_byte img)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnCompressedTexImageARB)
                Throw(undefined_behavior(
                    "unloaded function GetnCompressedTexImageARB"));
    }
    glGetnCompressedTexImageARB(static_cast<GLenum>(target), lod, img.size(), reinterpret_cast<void *>(img.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void getn_tex_image_arb(groups::texture_target target, i32 level, groups::pixel_format format, groups::pixel_type type, span_byte img)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnTexImageARB)
                Throw(undefined_behavior(
                    "unloaded function GetnTexImageARB"));
    }
    glGetnTexImageARB(static_cast<GLenum>(target), level, static_cast<GLenum>(format), static_cast<GLenum>(type), img.size(), reinterpret_cast<void *>(img.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f64
>
requires (
    semantic::concepts::Span<span_f64> &&
    std::is_same_v<std::decay_t<typename span_f64::value_type>, f64>)
STATICINLINE void getn_uniformdv_arb(u32 program, i32 location, i32 bufSize, span_f64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnUniformdvARB)
                Throw(undefined_behavior(
                    "unloaded function GetnUniformdvARB"));
        glIsProgram(program);
    }
    glGetnUniformdvARB(program, location, bufSize, reinterpret_cast<GLdouble *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void getn_uniformfv_arb(u32 program, i32 location, i32 bufSize, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnUniformfvARB)
                Throw(undefined_behavior(
                    "unloaded function GetnUniformfvARB"));
        glIsProgram(program);
    }
    glGetnUniformfvARB(program, location, bufSize, reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void getn_uniformiv_arb(u32 program, i32 location, i32 bufSize, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnUniformivARB)
                Throw(undefined_behavior(
                    "unloaded function GetnUniformivARB"));
        glIsProgram(program);
    }
    glGetnUniformivARB(program, location, bufSize, reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void getn_uniformuiv_arb(u32 program, i32 location, i32 bufSize, span_u32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnUniformuivARB)
                Throw(undefined_behavior(
                    "unloaded function GetnUniformuivARB"));
        glIsProgram(program);
    }
    glGetnUniformuivARB(program, location, bufSize, reinterpret_cast<GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte,
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2> &&
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void readn_pixels_arb(vec_2_i32 const& x, vec_2_i32 const& width, groups::pixel_format format, groups::pixel_type type, span_byte data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glReadnPixelsARB)
                Throw(undefined_behavior(
                    "unloaded function ReadnPixelsARB"));
    }
    glReadnPixelsARB(x.x(), x.y(), width[0], width[1], static_cast<GLenum>(format), static_cast<GLenum>(type), data.size(), reinterpret_cast<void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void getn_color_table_arb(groups::color_table_target target, groups::pixel_format format, groups::pixel_type type, span_byte table)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnColorTableARB)
                Throw(undefined_behavior(
                    "unloaded function GetnColorTableARB"));
    }
    glGetnColorTableARB(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), table.size(), reinterpret_cast<void *>(table.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void getn_convolution_filter_arb(groups::convolution_target target, groups::pixel_format format, groups::pixel_type type, span_byte image)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnConvolutionFilterARB)
                Throw(undefined_behavior(
                    "unloaded function GetnConvolutionFilterARB"));
    }
    glGetnConvolutionFilterARB(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), image.size(), reinterpret_cast<void *>(image.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void getn_histogram_arb(groups::histogram_target_ext target, bool reset, groups::pixel_format format, groups::pixel_type type, span_byte values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnHistogramARB)
                Throw(undefined_behavior(
                    "unloaded function GetnHistogramARB"));
    }
    glGetnHistogramARB(static_cast<GLenum>(target), reset, static_cast<GLenum>(format), static_cast<GLenum>(type), values.size(), reinterpret_cast<void *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f64
>
requires (
    semantic::concepts::Span<span_f64> &&
    std::is_same_v<std::decay_t<typename span_f64::value_type>, f64>)
STATICINLINE void getn_mapdv_arb(groups::map_target target, groups::map_query query, i32 bufSize, span_f64 v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnMapdvARB)
                Throw(undefined_behavior(
                    "unloaded function GetnMapdvARB"));
    }
    glGetnMapdvARB(static_cast<GLenum>(target), static_cast<GLenum>(query), bufSize, reinterpret_cast<GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void getn_mapfv_arb(groups::map_target target, groups::map_query query, span_f32 v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnMapfvARB)
                Throw(undefined_behavior(
                    "unloaded function GetnMapfvARB"));
    }
    glGetnMapfvARB(static_cast<GLenum>(target), static_cast<GLenum>(query), v.size(), reinterpret_cast<GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void getn_mapiv_arb(groups::map_target target, groups::map_query query, span_i32 v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnMapivARB)
                Throw(undefined_behavior(
                    "unloaded function GetnMapivARB"));
    }
    glGetnMapivARB(static_cast<GLenum>(target), static_cast<GLenum>(query), v.size(), reinterpret_cast<GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void getn_minmax_arb(groups::minmax_target_ext target, bool reset, groups::pixel_format format, groups::pixel_type type, span_byte values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnMinmaxARB)
                Throw(undefined_behavior(
                    "unloaded function GetnMinmaxARB"));
    }
    glGetnMinmaxARB(static_cast<GLenum>(target), reset, static_cast<GLenum>(format), static_cast<GLenum>(type), values.size(), reinterpret_cast<void *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void getn_pixel_mapfv_arb(groups::pixel_map map, i32 bufSize, span_f32 values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnPixelMapfvARB)
                Throw(undefined_behavior(
                    "unloaded function GetnPixelMapfvARB"));
    }
    glGetnPixelMapfvARB(static_cast<GLenum>(map), bufSize, reinterpret_cast<GLfloat *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void getn_pixel_mapuiv_arb(groups::pixel_map map, span_u32 values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnPixelMapuivARB)
                Throw(undefined_behavior(
                    "unloaded function GetnPixelMapuivARB"));
    }
    glGetnPixelMapuivARB(static_cast<GLenum>(map), values.size(), reinterpret_cast<GLuint *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u16
>
requires (
    semantic::concepts::Span<span_u16> &&
    std::is_same_v<std::decay_t<typename span_u16::value_type>, u16>)
STATICINLINE void getn_pixel_mapusv_arb(groups::pixel_map map, span_u16 values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnPixelMapusvARB)
                Throw(undefined_behavior(
                    "unloaded function GetnPixelMapusvARB"));
    }
    glGetnPixelMapusvARB(static_cast<GLenum>(map), values.size(), reinterpret_cast<GLushort *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u8
>
requires (
    semantic::concepts::Span<span_u8> &&
    std::is_same_v<std::decay_t<typename span_u8::value_type>, u8>)
STATICINLINE void getn_polygon_stipple_arb(span_u8 pattern)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnPolygonStippleARB)
                Throw(undefined_behavior(
                    "unloaded function GetnPolygonStippleARB"));
    }
    glGetnPolygonStippleARB(pattern.size(), reinterpret_cast<GLubyte *>(pattern.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void getn_separable_filter_arb(groups::separable_target_ext target, groups::pixel_format format, groups::pixel_type type, span_byte row, span_byte column, span_byte span)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnSeparableFilterARB)
                Throw(undefined_behavior(
                    "unloaded function GetnSeparableFilterARB"));
    }
    glGetnSeparableFilterARB(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), row.size(), reinterpret_cast<void *>(row.data()), column.size(), reinterpret_cast<void *>(column.data()), reinterpret_cast<void *>(span.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_robustness
#endif // GL_ARB_robustness
#ifdef GL_ARB_robustness_isolation
namespace arb_robustness_isolation {
} // arb_robustness_isolation
#endif // GL_ARB_robustness_isolation
#ifdef GL_ARB_sample_locations
namespace arb_sample_locations {
constexpr u32 sample_location_arb = 0x8E50;
constexpr u32 sample_location_subpixel_bits_arb = 0x933D;
constexpr u32 sample_location_pixel_grid_width_arb = 0x933E;
constexpr u32 sample_location_pixel_grid_height_arb = 0x933F;
constexpr u32 programmable_sample_location_table_size_arb = 0x9340;
constexpr u32 programmable_sample_location_arb = 0x9341;
constexpr u32 framebuffer_programmable_sample_locations_arb = 0x9342;
constexpr u32 framebuffer_sample_location_pixel_grid_arb = 0x9343;
STATICINLINE void evaluate_depth_values_arb()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEvaluateDepthValuesARB)
                Throw(undefined_behavior(
                    "unloaded function EvaluateDepthValuesARB"));
    }
    glEvaluateDepthValuesARB();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void framebuffer_sample_locationsfv_arb(groups::framebuffer_target target, u32 start, i32 count, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferSampleLocationsfvARB)
                Throw(undefined_behavior(
                    "unloaded function FramebufferSampleLocationsfvARB"));
    }
    glFramebufferSampleLocationsfvARB(static_cast<GLenum>(target), start, count, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void named_framebuffer_sample_locationsfv_arb(u32 framebuffer, u32 start, i32 count, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedFramebufferSampleLocationsfvARB)
                Throw(undefined_behavior(
                    "unloaded function NamedFramebufferSampleLocationsfvARB"));
        glIsFramebuffer(framebuffer);
    }
    glNamedFramebufferSampleLocationsfvARB(framebuffer, start, count, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_sample_locations
#endif // GL_ARB_sample_locations
#ifdef GL_ARB_sample_shading
namespace arb_sample_shading {
constexpr u32 sample_shading_arb = 0x8C36;
constexpr u32 min_sample_shading_value_arb = 0x8C37;
STATICINLINE void min_sample_shading_arb(f32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMinSampleShadingARB)
                Throw(undefined_behavior(
                    "unloaded function MinSampleShadingARB"));
    }
    glMinSampleShadingARB(value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_sample_shading
#endif // GL_ARB_sample_shading
#ifdef GL_ARB_sampler_objects
namespace arb_sampler_objects {
constexpr u32 sampler_binding = 0x8919;
STATICINLINE void bind_sampler(u32 unit, u32 sampler)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindSampler)
                Throw(undefined_behavior(
                    "unloaded function BindSampler"));
        glIsSampler(sampler);
    }
    glBindSampler(unit, sampler);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_samplers(span_const_u32 const& samplers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteSamplers)
                Throw(undefined_behavior(
                    "unloaded function DeleteSamplers"));
    }
    glDeleteSamplers(samplers.size(), reinterpret_cast<const GLuint *>(samplers.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void gen_samplers(span_u32 samplers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenSamplers)
                Throw(undefined_behavior(
                    "unloaded function GenSamplers"));
    }
    glGenSamplers(samplers.size(), reinterpret_cast<GLuint *>(samplers.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_sampler_parameter_iiv(u32 sampler, groups::sampler_parameter_i pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetSamplerParameterIiv)
                Throw(undefined_behavior(
                    "unloaded function GetSamplerParameterIiv"));
        glIsSampler(sampler);
    }
    glGetSamplerParameterIiv(sampler, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_sampler_parameter_iuiv(u32 sampler, groups::sampler_parameter_i pname, span_u32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetSamplerParameterIuiv)
                Throw(undefined_behavior(
                    "unloaded function GetSamplerParameterIuiv"));
        glIsSampler(sampler);
    }
    glGetSamplerParameterIuiv(sampler, static_cast<GLenum>(pname), reinterpret_cast<GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_sampler_parameter(u32 sampler, groups::sampler_parameter_f pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetSamplerParameterfv)
                Throw(undefined_behavior(
                    "unloaded function GetSamplerParameterfv"));
        glIsSampler(sampler);
    }
    glGetSamplerParameterfv(sampler, static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_sampler_parameter(u32 sampler, groups::sampler_parameter_i pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetSamplerParameteriv)
                Throw(undefined_behavior(
                    "unloaded function GetSamplerParameteriv"));
        glIsSampler(sampler);
    }
    glGetSamplerParameteriv(sampler, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_sampler(u32 sampler)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsSampler)
                Throw(undefined_behavior(
                    "unloaded function IsSampler"));
        glIsSampler(sampler);
    }
    auto out = glIsSampler(sampler);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void sampler_parameter_iiv(u32 sampler, groups::sampler_parameter_i pname, span_const_i32 const& param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSamplerParameterIiv)
                Throw(undefined_behavior(
                    "unloaded function SamplerParameterIiv"));
        glIsSampler(sampler);
    }
    glSamplerParameterIiv(sampler, static_cast<GLenum>(pname), reinterpret_cast<const GLint *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void sampler_parameter_iuiv(u32 sampler, groups::sampler_parameter_i pname, span_const_u32 const& param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSamplerParameterIuiv)
                Throw(undefined_behavior(
                    "unloaded function SamplerParameterIuiv"));
        glIsSampler(sampler);
    }
    glSamplerParameterIuiv(sampler, static_cast<GLenum>(pname), reinterpret_cast<const GLuint *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void sampler_parameter(u32 sampler, groups::sampler_parameter_f pname, f32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSamplerParameterf)
                Throw(undefined_behavior(
                    "unloaded function SamplerParameterf"));
        glIsSampler(sampler);
    }
    glSamplerParameterf(sampler, static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void sampler_parameter(u32 sampler, groups::sampler_parameter_f pname, span_const_f32 const& param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSamplerParameterfv)
                Throw(undefined_behavior(
                    "unloaded function SamplerParameterfv"));
        glIsSampler(sampler);
    }
    glSamplerParameterfv(sampler, static_cast<GLenum>(pname), reinterpret_cast<const GLfloat *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void sampler_parameter(u32 sampler, groups::sampler_parameter_i pname, i32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSamplerParameteri)
                Throw(undefined_behavior(
                    "unloaded function SamplerParameteri"));
        glIsSampler(sampler);
    }
    glSamplerParameteri(sampler, static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void sampler_parameter(u32 sampler, groups::sampler_parameter_i pname, span_const_i32 const& param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSamplerParameteriv)
                Throw(undefined_behavior(
                    "unloaded function SamplerParameteriv"));
        glIsSampler(sampler);
    }
    glSamplerParameteriv(sampler, static_cast<GLenum>(pname), reinterpret_cast<const GLint *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_sampler_objects
#endif // GL_ARB_sampler_objects
#ifdef GL_ARB_seamless_cube_map
namespace arb_seamless_cube_map {
constexpr u32 texture_cube_map_seamless = 0x884F;
} // arb_seamless_cube_map
#endif // GL_ARB_seamless_cube_map
#ifdef GL_ARB_seamless_cubemap_per_texture
namespace arb_seamless_cubemap_per_texture {
constexpr u32 texture_cube_map_seamless = 0x884F;
} // arb_seamless_cubemap_per_texture
#endif // GL_ARB_seamless_cubemap_per_texture
#ifdef GL_ARB_separate_shader_objects
namespace arb_separate_shader_objects {
constexpr u32 vertex_shader_bit = 0x00000001;
constexpr u32 fragment_shader_bit = 0x00000002;
constexpr u32 geometry_shader_bit = 0x00000004;
constexpr u32 tess_control_shader_bit = 0x00000008;
constexpr u32 tess_evaluation_shader_bit = 0x00000010;
constexpr u32 all_shader_bits = 0xFFFFFFFF;
constexpr u32 program_separable = 0x8258;
constexpr u32 active_program = 0x8259;
constexpr u32 program_pipeline_binding = 0x825A;
STATICINLINE void active_shader_program(u32 pipeline, u32 program)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glActiveShaderProgram)
                Throw(undefined_behavior(
                    "unloaded function ActiveShaderProgram"));
        glIsProgramPipeline(pipeline);
        glIsProgram(program);
    }
    glActiveShaderProgram(pipeline, program);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void bind_program_pipeline(u32 pipeline)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindProgramPipeline)
                Throw(undefined_behavior(
                    "unloaded function BindProgramPipeline"));
        glIsProgramPipeline(pipeline);
    }
    glBindProgramPipeline(pipeline);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLuint create_shader_programv(GLenum type, std::vector<std::string_view> strings)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreateShaderProgramv)
                Throw(undefined_behavior(
                    "unloaded function CreateShaderProgramv"));
    }
    auto [strings_lens, strings_cstr, strings_store] = detail::transform_strings(strings);
    auto out = glCreateShaderProgramv(type, strings_cstr.size(), strings_cstr.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_program_pipelines(span_const_u32 const& pipelines)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteProgramPipelines)
                Throw(undefined_behavior(
                    "unloaded function DeleteProgramPipelines"));
    }
    glDeleteProgramPipelines(pipelines.size(), reinterpret_cast<const GLuint *>(pipelines.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void gen_program_pipelines(span_u32 pipelines)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenProgramPipelines)
                Throw(undefined_behavior(
                    "unloaded function GenProgramPipelines"));
    }
    glGenProgramPipelines(pipelines.size(), reinterpret_cast<GLuint *>(pipelines.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLchar
>
requires (
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE void get_program_pipeline_info_log(u32 pipeline, i32& length, span_GLchar infoLog)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramPipelineInfoLog)
                Throw(undefined_behavior(
                    "unloaded function GetProgramPipelineInfoLog"));
        glIsProgramPipeline(pipeline);
    }
    glGetProgramPipelineInfoLog(pipeline, infoLog.size(), &length, infoLog.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_program_pipelineiv(u32 pipeline, groups::pipeline_parameter_name pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramPipelineiv)
                Throw(undefined_behavior(
                    "unloaded function GetProgramPipelineiv"));
        glIsProgramPipeline(pipeline);
    }
    glGetProgramPipelineiv(pipeline, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_program_pipeline(u32 pipeline)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsProgramPipeline)
                Throw(undefined_behavior(
                    "unloaded function IsProgramPipeline"));
        glIsProgramPipeline(pipeline);
    }
    auto out = glIsProgramPipeline(pipeline);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void program_parameter(u32 program, groups::program_parameter_prop pname, i32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramParameteri)
                Throw(undefined_behavior(
                    "unloaded function ProgramParameteri"));
        glIsProgram(program);
    }
    glProgramParameteri(program, static_cast<GLenum>(pname), value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void program_uniform(u32 program, i32 location, f64 v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1d)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1d"));
        glIsProgram(program);
    }
    glProgramUniform1d(program, location, v0);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f64
>
requires (
    semantic::concepts::Span<span_const_f64> &&
    std::is_same_v<std::decay_t<typename span_const_f64::value_type>, f64>)
STATICINLINE void program_uniform(u32 program, i32 location, span_const_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1dv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1dv"));
        glIsProgram(program);
    }
    glProgramUniform1dv(program, location, value.size(), reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void program_uniform(u32 program, i32 location, f32 v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1f)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1f"));
        glIsProgram(program);
    }
    glProgramUniform1f(program, location, v0);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void program_uniform(u32 program, i32 location, span_const_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1fv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1fv"));
        glIsProgram(program);
    }
    glProgramUniform1fv(program, location, value.size(), reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void program_uniform(u32 program, i32 location, i32 v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1i)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1i"));
        glIsProgram(program);
    }
    glProgramUniform1i(program, location, v0);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void program_uniform(u32 program, i32 location, span_const_i32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1iv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1iv"));
        glIsProgram(program);
    }
    glProgramUniform1iv(program, location, value.size(), reinterpret_cast<const GLint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void program_uniform(u32 program, i32 location, u32 v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1ui)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1ui"));
        glIsProgram(program);
    }
    glProgramUniform1ui(program, location, v0);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void program_uniform(u32 program, i32 location, span_const_u32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1uiv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1uiv"));
        glIsProgram(program);
    }
    glProgramUniform1uiv(program, location, value.size(), reinterpret_cast<const GLuint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_f64
>
requires (
    semantic::concepts::Vector<vec_2_f64, f64, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_2_f64 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2d)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2d"));
        glIsProgram(program);
    }
    glProgramUniform2d(program, location, v0.x(), v0.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_f64
>
requires (
    semantic::concepts::Span<span_const_vec_2_f64> &&
    semantic::concepts::Vector<typename span_const_vec_2_f64::value_type, f64, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_2_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2dv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2dv"));
        glIsProgram(program);
    }
    glProgramUniform2dv(program, location, count, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_f32
>
requires (
    semantic::concepts::Vector<vec_2_f32, f32, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_2_f32 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2f)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2f"));
        glIsProgram(program);
    }
    glProgramUniform2f(program, location, v0.x(), v0.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_f32
>
requires (
    semantic::concepts::Span<span_const_vec_2_f32> &&
    semantic::concepts::Vector<typename span_const_vec_2_f32::value_type, f32, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_2_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2fv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2fv"));
        glIsProgram(program);
    }
    glProgramUniform2fv(program, location, count, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_2_i32 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2i)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2i"));
        glIsProgram(program);
    }
    glProgramUniform2i(program, location, v0.x(), v0.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_i32
>
requires (
    semantic::concepts::Span<span_const_vec_2_i32> &&
    semantic::concepts::Vector<typename span_const_vec_2_i32::value_type, i32, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_2_i32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2iv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2iv"));
        glIsProgram(program);
    }
    glProgramUniform2iv(program, location, count, reinterpret_cast<const GLint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_u32
>
requires (
    semantic::concepts::Vector<vec_2_u32, u32, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_2_u32 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2ui)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2ui"));
        glIsProgram(program);
    }
    glProgramUniform2ui(program, location, v0.x(), v0.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_u32
>
requires (
    semantic::concepts::Span<span_const_vec_2_u32> &&
    semantic::concepts::Vector<typename span_const_vec_2_u32::value_type, u32, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_2_u32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2uiv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2uiv"));
        glIsProgram(program);
    }
    glProgramUniform2uiv(program, location, count, reinterpret_cast<const GLuint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f64
>
requires (
    semantic::concepts::Vector<vec_3_f64, f64, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_3_f64 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3d)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3d"));
        glIsProgram(program);
    }
    glProgramUniform3d(program, location, v0.x(), v0.y(), v0.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_f64
>
requires (
    semantic::concepts::Span<span_const_vec_3_f64> &&
    semantic::concepts::Vector<typename span_const_vec_3_f64::value_type, f64, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_3_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3dv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3dv"));
        glIsProgram(program);
    }
    glProgramUniform3dv(program, location, count, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f32
>
requires (
    semantic::concepts::Vector<vec_3_f32, f32, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_3_f32 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3f)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3f"));
        glIsProgram(program);
    }
    glProgramUniform3f(program, location, v0.x(), v0.y(), v0.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_f32
>
requires (
    semantic::concepts::Span<span_const_vec_3_f32> &&
    semantic::concepts::Vector<typename span_const_vec_3_f32::value_type, f32, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_3_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3fv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3fv"));
        glIsProgram(program);
    }
    glProgramUniform3fv(program, location, count, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_3_i32 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3i)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3i"));
        glIsProgram(program);
    }
    glProgramUniform3i(program, location, v0.x(), v0.y(), v0.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_i32
>
requires (
    semantic::concepts::Span<span_const_vec_3_i32> &&
    semantic::concepts::Vector<typename span_const_vec_3_i32::value_type, i32, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_3_i32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3iv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3iv"));
        glIsProgram(program);
    }
    glProgramUniform3iv(program, location, count, reinterpret_cast<const GLint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_u32
>
requires (
    semantic::concepts::Vector<vec_3_u32, u32, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_3_u32 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3ui)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3ui"));
        glIsProgram(program);
    }
    glProgramUniform3ui(program, location, v0.x(), v0.y(), v0.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_u32
>
requires (
    semantic::concepts::Span<span_const_vec_3_u32> &&
    semantic::concepts::Vector<typename span_const_vec_3_u32::value_type, u32, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_3_u32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3uiv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3uiv"));
        glIsProgram(program);
    }
    glProgramUniform3uiv(program, location, count, reinterpret_cast<const GLuint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f64
>
requires (
    semantic::concepts::Vector<vec_4_f64, f64, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_4_f64 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4d)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4d"));
        glIsProgram(program);
    }
    glProgramUniform4d(program, location, v0.x(), v0.y(), v0.z(), v0.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f64
>
requires (
    semantic::concepts::Span<span_const_vec_4_f64> &&
    semantic::concepts::Vector<typename span_const_vec_4_f64::value_type, f64, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_4_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4dv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4dv"));
        glIsProgram(program);
    }
    glProgramUniform4dv(program, location, count, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f32
>
requires (
    semantic::concepts::Vector<vec_4_f32, f32, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_4_f32 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4f)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4f"));
        glIsProgram(program);
    }
    glProgramUniform4f(program, location, v0.x(), v0.y(), v0.z(), v0.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f32
>
requires (
    semantic::concepts::Span<span_const_vec_4_f32> &&
    semantic::concepts::Vector<typename span_const_vec_4_f32::value_type, f32, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_4_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4fv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4fv"));
        glIsProgram(program);
    }
    glProgramUniform4fv(program, location, count, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_i32
>
requires (
    semantic::concepts::Vector<vec_4_i32, i32, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_4_i32 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4i)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4i"));
        glIsProgram(program);
    }
    glProgramUniform4i(program, location, v0.x(), v0.y(), v0.z(), v0.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_i32
>
requires (
    semantic::concepts::Span<span_const_vec_4_i32> &&
    semantic::concepts::Vector<typename span_const_vec_4_i32::value_type, i32, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_4_i32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4iv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4iv"));
        glIsProgram(program);
    }
    glProgramUniform4iv(program, location, count, reinterpret_cast<const GLint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_u32
>
requires (
    semantic::concepts::Vector<vec_4_u32, u32, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_4_u32 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4ui)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4ui"));
        glIsProgram(program);
    }
    glProgramUniform4ui(program, location, v0.x(), v0.y(), v0.z(), v0.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u32
>
requires (
    semantic::concepts::Span<span_const_vec_4_u32> &&
    semantic::concepts::Vector<typename span_const_vec_4_u32::value_type, u32, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_4_u32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4uiv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4uiv"));
        glIsProgram(program);
    }
    glProgramUniform4uiv(program, location, count, reinterpret_cast<const GLuint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_2x2_f64
>
requires (
    semantic::concepts::Span<span_const_mat_2x2_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_2x2_f64::value_type, f64, 2, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_2x2_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix2dv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix2dv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix2dv(program, location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_2x2_f32
>
requires (
    semantic::concepts::Span<span_const_mat_2x2_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_2x2_f32::value_type, f32, 2, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_2x2_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix2fv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix2fv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix2fv(program, location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_2x3_f64
>
requires (
    semantic::concepts::Span<span_const_mat_2x3_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_2x3_f64::value_type, f64, 2, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_2x3_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix2x3dv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix2x3dv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix2x3dv(program, location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_2x3_f32
>
requires (
    semantic::concepts::Span<span_const_mat_2x3_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_2x3_f32::value_type, f32, 2, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_2x3_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix2x3fv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix2x3fv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix2x3fv(program, location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_2x4_f64
>
requires (
    semantic::concepts::Span<span_const_mat_2x4_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_2x4_f64::value_type, f64, 2, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_2x4_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix2x4dv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix2x4dv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix2x4dv(program, location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_2x4_f32
>
requires (
    semantic::concepts::Span<span_const_mat_2x4_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_2x4_f32::value_type, f32, 2, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_2x4_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix2x4fv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix2x4fv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix2x4fv(program, location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x3_f64
>
requires (
    semantic::concepts::Span<span_const_mat_3x3_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_3x3_f64::value_type, f64, 3, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_3x3_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix3dv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix3dv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix3dv(program, location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x3_f32
>
requires (
    semantic::concepts::Span<span_const_mat_3x3_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_3x3_f32::value_type, f32, 3, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_3x3_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix3fv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix3fv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix3fv(program, location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x2_f64
>
requires (
    semantic::concepts::Span<span_const_mat_3x2_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_3x2_f64::value_type, f64, 3, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_3x2_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix3x2dv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix3x2dv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix3x2dv(program, location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x2_f32
>
requires (
    semantic::concepts::Span<span_const_mat_3x2_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_3x2_f32::value_type, f32, 3, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_3x2_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix3x2fv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix3x2fv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix3x2fv(program, location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x4_f64
>
requires (
    semantic::concepts::Span<span_const_mat_3x4_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_3x4_f64::value_type, f64, 3, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_3x4_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix3x4dv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix3x4dv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix3x4dv(program, location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x4_f32
>
requires (
    semantic::concepts::Span<span_const_mat_3x4_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_3x4_f32::value_type, f32, 3, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_3x4_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix3x4fv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix3x4fv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix3x4fv(program, location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_4x4_f64
>
requires (
    semantic::concepts::Span<span_const_mat_4x4_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_4x4_f64::value_type, f64, 4, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_4x4_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix4dv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix4dv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix4dv(program, location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_4x4_f32
>
requires (
    semantic::concepts::Span<span_const_mat_4x4_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_4x4_f32::value_type, f32, 4, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_4x4_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix4fv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix4fv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix4fv(program, location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_4x2_f64
>
requires (
    semantic::concepts::Span<span_const_mat_4x2_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_4x2_f64::value_type, f64, 4, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_4x2_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix4x2dv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix4x2dv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix4x2dv(program, location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_4x2_f32
>
requires (
    semantic::concepts::Span<span_const_mat_4x2_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_4x2_f32::value_type, f32, 4, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_4x2_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix4x2fv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix4x2fv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix4x2fv(program, location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_4x3_f64
>
requires (
    semantic::concepts::Span<span_const_mat_4x3_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_4x3_f64::value_type, f64, 4, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_4x3_f64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix4x3dv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix4x3dv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix4x3dv(program, location, count, transpose, reinterpret_cast<const GLdouble *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_4x3_f32
>
requires (
    semantic::concepts::Span<span_const_mat_4x3_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_4x3_f32::value_type, f32, 4, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, bool transpose, span_const_mat_4x3_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformMatrix4x3fv)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformMatrix4x3fv"));
        glIsProgram(program);
    }
    glProgramUniformMatrix4x3fv(program, location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void use_program_stages(u32 pipeline, groups::use_program_stage_mask stages, u32 program)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUseProgramStages)
                Throw(undefined_behavior(
                    "unloaded function UseProgramStages"));
        glIsProgramPipeline(pipeline);
        glIsProgram(program);
    }
    glUseProgramStages(pipeline, static_cast<GLenum>(stages), program);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void validate_program_pipeline(u32 pipeline)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glValidateProgramPipeline)
                Throw(undefined_behavior(
                    "unloaded function ValidateProgramPipeline"));
        glIsProgramPipeline(pipeline);
    }
    glValidateProgramPipeline(pipeline);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_separate_shader_objects
#endif // GL_ARB_separate_shader_objects
#ifdef GL_ARB_shader_atomic_counter_ops
namespace arb_shader_atomic_counter_ops {
} // arb_shader_atomic_counter_ops
#endif // GL_ARB_shader_atomic_counter_ops
#ifdef GL_ARB_shader_atomic_counters
namespace arb_shader_atomic_counters {
constexpr u32 atomic_counter_buffer = 0x92C0;
constexpr u32 atomic_counter_buffer_binding = 0x92C1;
constexpr u32 atomic_counter_buffer_start = 0x92C2;
constexpr u32 atomic_counter_buffer_size = 0x92C3;
constexpr u32 atomic_counter_buffer_data_size = 0x92C4;
constexpr u32 atomic_counter_buffer_active_atomic_counters = 0x92C5;
constexpr u32 atomic_counter_buffer_active_atomic_counter_indices = 0x92C6;
constexpr u32 atomic_counter_buffer_referenced_by_vertex_shader = 0x92C7;
constexpr u32 atomic_counter_buffer_referenced_by_tess_control_shader = 0x92C8;
constexpr u32 atomic_counter_buffer_referenced_by_tess_evaluation_shader = 0x92C9;
constexpr u32 atomic_counter_buffer_referenced_by_geometry_shader = 0x92CA;
constexpr u32 atomic_counter_buffer_referenced_by_fragment_shader = 0x92CB;
constexpr u32 max_vertex_atomic_counter_buffers = 0x92CC;
constexpr u32 max_tess_control_atomic_counter_buffers = 0x92CD;
constexpr u32 max_tess_evaluation_atomic_counter_buffers = 0x92CE;
constexpr u32 max_geometry_atomic_counter_buffers = 0x92CF;
constexpr u32 max_fragment_atomic_counter_buffers = 0x92D0;
constexpr u32 max_combined_atomic_counter_buffers = 0x92D1;
constexpr u32 max_vertex_atomic_counters = 0x92D2;
constexpr u32 max_tess_control_atomic_counters = 0x92D3;
constexpr u32 max_tess_evaluation_atomic_counters = 0x92D4;
constexpr u32 max_geometry_atomic_counters = 0x92D5;
constexpr u32 max_fragment_atomic_counters = 0x92D6;
constexpr u32 max_combined_atomic_counters = 0x92D7;
constexpr u32 max_atomic_counter_buffer_size = 0x92D8;
constexpr u32 active_atomic_counter_buffers = 0x92D9;
constexpr u32 uniform_atomic_counter_buffer_index = 0x92DA;
constexpr u32 unsigned_int_atomic_counter = 0x92DB;
constexpr u32 max_atomic_counter_buffer_bindings = 0x92DC;
template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_active_atomic_counter_bufferiv(u32 program, u32 bufferIndex, groups::atomic_counter_buffer_prop pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetActiveAtomicCounterBufferiv)
                Throw(undefined_behavior(
                    "unloaded function GetActiveAtomicCounterBufferiv"));
        glIsProgram(program);
    }
    glGetActiveAtomicCounterBufferiv(program, bufferIndex, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_shader_atomic_counters
#endif // GL_ARB_shader_atomic_counters
#ifdef GL_ARB_shader_ballot
namespace arb_shader_ballot {
} // arb_shader_ballot
#endif // GL_ARB_shader_ballot
#ifdef GL_ARB_shader_bit_encoding
namespace arb_shader_bit_encoding {
} // arb_shader_bit_encoding
#endif // GL_ARB_shader_bit_encoding
#ifdef GL_ARB_shader_clock
namespace arb_shader_clock {
} // arb_shader_clock
#endif // GL_ARB_shader_clock
#ifdef GL_ARB_shader_draw_parameters
namespace arb_shader_draw_parameters {
} // arb_shader_draw_parameters
#endif // GL_ARB_shader_draw_parameters
#ifdef GL_ARB_shader_group_vote
namespace arb_shader_group_vote {
} // arb_shader_group_vote
#endif // GL_ARB_shader_group_vote
#ifdef GL_ARB_shader_image_load_store
namespace arb_shader_image_load_store {
constexpr u32 vertex_attrib_array_barrier_bit = 0x00000001;
constexpr u32 element_array_barrier_bit = 0x00000002;
constexpr u32 uniform_barrier_bit = 0x00000004;
constexpr u32 texture_fetch_barrier_bit = 0x00000008;
constexpr u32 shader_image_access_barrier_bit = 0x00000020;
constexpr u32 command_barrier_bit = 0x00000040;
constexpr u32 pixel_buffer_barrier_bit = 0x00000080;
constexpr u32 texture_update_barrier_bit = 0x00000100;
constexpr u32 buffer_update_barrier_bit = 0x00000200;
constexpr u32 framebuffer_barrier_bit = 0x00000400;
constexpr u32 transform_feedback_barrier_bit = 0x00000800;
constexpr u32 atomic_counter_barrier_bit = 0x00001000;
constexpr u32 all_barrier_bits = 0xFFFFFFFF;
constexpr u32 max_image_units = 0x8F38;
constexpr u32 max_combined_image_units_and_fragment_outputs = 0x8F39;
constexpr u32 image_binding_name = 0x8F3A;
constexpr u32 image_binding_level = 0x8F3B;
constexpr u32 image_binding_layered = 0x8F3C;
constexpr u32 image_binding_layer = 0x8F3D;
constexpr u32 image_binding_access = 0x8F3E;
constexpr u32 image_1d = 0x904C;
constexpr u32 image_2d = 0x904D;
constexpr u32 image_3d = 0x904E;
constexpr u32 image_2d_rect = 0x904F;
constexpr u32 image_cube = 0x9050;
constexpr u32 image_buffer = 0x9051;
constexpr u32 image_1d_array = 0x9052;
constexpr u32 image_2d_array = 0x9053;
constexpr u32 image_cube_map_array = 0x9054;
constexpr u32 image_2d_multisample = 0x9055;
constexpr u32 image_2d_multisample_array = 0x9056;
constexpr u32 int_image_1d = 0x9057;
constexpr u32 int_image_2d = 0x9058;
constexpr u32 int_image_3d = 0x9059;
constexpr u32 int_image_2d_rect = 0x905A;
constexpr u32 int_image_cube = 0x905B;
constexpr u32 int_image_buffer = 0x905C;
constexpr u32 int_image_1d_array = 0x905D;
constexpr u32 int_image_2d_array = 0x905E;
constexpr u32 int_image_cube_map_array = 0x905F;
constexpr u32 int_image_2d_multisample = 0x9060;
constexpr u32 int_image_2d_multisample_array = 0x9061;
constexpr u32 unsigned_int_image_1d = 0x9062;
constexpr u32 unsigned_int_image_2d = 0x9063;
constexpr u32 unsigned_int_image_3d = 0x9064;
constexpr u32 unsigned_int_image_2d_rect = 0x9065;
constexpr u32 unsigned_int_image_cube = 0x9066;
constexpr u32 unsigned_int_image_buffer = 0x9067;
constexpr u32 unsigned_int_image_1d_array = 0x9068;
constexpr u32 unsigned_int_image_2d_array = 0x9069;
constexpr u32 unsigned_int_image_cube_map_array = 0x906A;
constexpr u32 unsigned_int_image_2d_multisample = 0x906B;
constexpr u32 unsigned_int_image_2d_multisample_array = 0x906C;
constexpr u32 max_image_samples = 0x906D;
constexpr u32 image_binding_format = 0x906E;
constexpr u32 image_format_compatibility_type = 0x90C7;
constexpr u32 image_format_compatibility_by_size = 0x90C8;
constexpr u32 image_format_compatibility_by_class = 0x90C9;
constexpr u32 max_vertex_image_uniforms = 0x90CA;
constexpr u32 max_tess_control_image_uniforms = 0x90CB;
constexpr u32 max_tess_evaluation_image_uniforms = 0x90CC;
constexpr u32 max_geometry_image_uniforms = 0x90CD;
constexpr u32 max_fragment_image_uniforms = 0x90CE;
constexpr u32 max_combined_image_uniforms = 0x90CF;
STATICINLINE void bind_image_texture(u32 unit, u32 texture, i32 level, bool layered, i32 layer, groups::buffer_access_arb access, groups::internal_format format)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindImageTexture)
                Throw(undefined_behavior(
                    "unloaded function BindImageTexture"));
        glIsTexture(texture);
    }
    glBindImageTexture(unit, texture, level, layered, layer, static_cast<GLenum>(access), static_cast<GLenum>(format));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void memory_barrier(groups::memory_barrier_mask barriers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMemoryBarrier)
                Throw(undefined_behavior(
                    "unloaded function MemoryBarrier"));
    }
    glMemoryBarrier(static_cast<GLenum>(barriers));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_shader_image_load_store
#endif // GL_ARB_shader_image_load_store
#ifdef GL_ARB_shader_image_size
namespace arb_shader_image_size {
} // arb_shader_image_size
#endif // GL_ARB_shader_image_size
#ifdef GL_ARB_shader_objects
namespace arb_shader_objects {
constexpr u32 program_object_arb = 0x8B40;
constexpr u32 shader_object_arb = 0x8B48;
constexpr u32 object_type_arb = 0x8B4E;
constexpr u32 object_subtype_arb = 0x8B4F;
constexpr u32 float_vec2_arb = 0x8B50;
constexpr u32 float_vec3_arb = 0x8B51;
constexpr u32 float_vec4_arb = 0x8B52;
constexpr u32 int_vec2_arb = 0x8B53;
constexpr u32 int_vec3_arb = 0x8B54;
constexpr u32 int_vec4_arb = 0x8B55;
constexpr u32 bool_arb = 0x8B56;
constexpr u32 bool_vec2_arb = 0x8B57;
constexpr u32 bool_vec3_arb = 0x8B58;
constexpr u32 bool_vec4_arb = 0x8B59;
constexpr u32 float_mat2_arb = 0x8B5A;
constexpr u32 float_mat3_arb = 0x8B5B;
constexpr u32 float_mat4_arb = 0x8B5C;
constexpr u32 sampler_1d_arb = 0x8B5D;
constexpr u32 sampler_2d_arb = 0x8B5E;
constexpr u32 sampler_3d_arb = 0x8B5F;
constexpr u32 sampler_cube_arb = 0x8B60;
constexpr u32 sampler_1d_shadow_arb = 0x8B61;
constexpr u32 sampler_2d_shadow_arb = 0x8B62;
constexpr u32 sampler_2d_rect_arb = 0x8B63;
constexpr u32 sampler_2d_rect_shadow_arb = 0x8B64;
constexpr u32 object_delete_status_arb = 0x8B80;
constexpr u32 object_compile_status_arb = 0x8B81;
constexpr u32 object_link_status_arb = 0x8B82;
constexpr u32 object_validate_status_arb = 0x8B83;
constexpr u32 object_info_log_length_arb = 0x8B84;
constexpr u32 object_attached_objects_arb = 0x8B85;
constexpr u32 object_active_uniforms_arb = 0x8B86;
constexpr u32 object_active_uniform_max_length_arb = 0x8B87;
constexpr u32 object_shader_source_length_arb = 0x8B88;
STATICINLINE void attach_object_arb(GLhandleARB containerObj, GLhandleARB obj)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glAttachObjectARB)
                Throw(undefined_behavior(
                    "unloaded function AttachObjectARB"));
    }
    glAttachObjectARB(containerObj, obj);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void compile_shader_arb(GLhandleARB shaderObj)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCompileShaderARB)
                Throw(undefined_behavior(
                    "unloaded function CompileShaderARB"));
    }
    glCompileShaderARB(shaderObj);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLhandleARB create_program_object_arb()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreateProgramObjectARB)
                Throw(undefined_behavior(
                    "unloaded function CreateProgramObjectARB"));
    }
    auto out = glCreateProgramObjectARB();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLhandleARB create_shader_object_arb(GLenum shaderType)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreateShaderObjectARB)
                Throw(undefined_behavior(
                    "unloaded function CreateShaderObjectARB"));
    }
    auto out = glCreateShaderObjectARB(shaderType);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void delete_object_arb(GLhandleARB obj)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteObjectARB)
                Throw(undefined_behavior(
                    "unloaded function DeleteObjectARB"));
    }
    glDeleteObjectARB(obj);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void detach_object_arb(GLhandleARB containerObj, GLhandleARB attachedObj)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDetachObjectARB)
                Throw(undefined_behavior(
                    "unloaded function DetachObjectARB"));
    }
    glDetachObjectARB(containerObj, attachedObj);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLcharARB
>
requires (
    semantic::concepts::Span<span_GLcharARB> &&
    std::is_same_v<std::decay_t<typename span_GLcharARB::value_type>, GLcharARB>)
STATICINLINE void get_active_uniform_arb(GLhandleARB programObj, u32 index, i32& length, i32& size, GLenum& type, span_GLcharARB name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetActiveUniformARB)
                Throw(undefined_behavior(
                    "unloaded function GetActiveUniformARB"));
    }
    glGetActiveUniformARB(programObj, index, name.size(), &length, &size, &type, reinterpret_cast<GLcharARB *>(name.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLhandleARB
>
requires (
    semantic::concepts::Span<span_GLhandleARB> &&
    std::is_same_v<std::decay_t<typename span_GLhandleARB::value_type>, GLhandleARB>)
STATICINLINE void get_attached_objects_arb(GLhandleARB containerObj, i32& count, span_GLhandleARB obj)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetAttachedObjectsARB)
                Throw(undefined_behavior(
                    "unloaded function GetAttachedObjectsARB"));
    }
    glGetAttachedObjectsARB(containerObj, obj.size(), &count, reinterpret_cast<GLhandleARB *>(obj.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLhandleARB get_handle_arb(GLenum pname)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetHandleARB)
                Throw(undefined_behavior(
                    "unloaded function GetHandleARB"));
    }
    auto out = glGetHandleARB(pname);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_GLcharARB
>
requires (
    semantic::concepts::Span<span_GLcharARB> &&
    std::is_same_v<std::decay_t<typename span_GLcharARB::value_type>, GLcharARB>)
STATICINLINE void get_info_log_arb(GLhandleARB obj, i32& length, span_GLcharARB infoLog)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetInfoLogARB)
                Throw(undefined_behavior(
                    "unloaded function GetInfoLogARB"));
    }
    glGetInfoLogARB(obj, infoLog.size(), &length, reinterpret_cast<GLcharARB *>(infoLog.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_object_parameterfv_arb(GLhandleARB obj, GLenum pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetObjectParameterfvARB)
                Throw(undefined_behavior(
                    "unloaded function GetObjectParameterfvARB"));
    }
    glGetObjectParameterfvARB(obj, pname, reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_object_parameteriv_arb(GLhandleARB obj, GLenum pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetObjectParameterivARB)
                Throw(undefined_behavior(
                    "unloaded function GetObjectParameterivARB"));
    }
    glGetObjectParameterivARB(obj, pname, reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLcharARB
>
requires (
    semantic::concepts::Span<span_GLcharARB> &&
    std::is_same_v<std::decay_t<typename span_GLcharARB::value_type>, GLcharARB>)
STATICINLINE void get_shader_source_arb(GLhandleARB obj, i32& length, span_GLcharARB source)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetShaderSourceARB)
                Throw(undefined_behavior(
                    "unloaded function GetShaderSourceARB"));
    }
    glGetShaderSourceARB(obj, source.size(), &length, reinterpret_cast<GLcharARB *>(source.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLcharARB
>
requires (
    semantic::concepts::Span<span_const_GLcharARB> &&
    std::is_same_v<std::decay_t<typename span_const_GLcharARB::value_type>, GLcharARB>)
STATICINLINE GLint get_uniform_location_arb(GLhandleARB programObj, span_const_GLcharARB const& name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetUniformLocationARB)
                Throw(undefined_behavior(
                    "unloaded function GetUniformLocationARB"));
    }
    auto out = glGetUniformLocationARB(programObj, reinterpret_cast<const GLcharARB *>(name.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_uniformfv_arb(GLhandleARB programObj, i32 location, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetUniformfvARB)
                Throw(undefined_behavior(
                    "unloaded function GetUniformfvARB"));
    }
    glGetUniformfvARB(programObj, location, reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_uniformiv_arb(GLhandleARB programObj, i32 location, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetUniformivARB)
                Throw(undefined_behavior(
                    "unloaded function GetUniformivARB"));
    }
    glGetUniformivARB(programObj, location, reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void link_program_arb(GLhandleARB programObj)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glLinkProgramARB)
                Throw(undefined_behavior(
                    "unloaded function LinkProgramARB"));
    }
    glLinkProgramARB(programObj);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLcharARB,
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_GLcharARB> &&
    std::is_same_v<std::decay_t<typename span_const_GLcharARB::value_type>, GLcharARB> &&
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void shader_source_arb(GLhandleARB shaderObj, span_const_GLcharARB const& string, span_const_i32 const& length)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glShaderSourceARB)
                Throw(undefined_behavior(
                    "unloaded function ShaderSourceARB"));
    }
    glShaderSourceARB(shaderObj, string.size(), reinterpret_cast<const GLcharARB **>(string.data()), reinterpret_cast<const GLint *>(length.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void uniform(i32 location, f32 v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1fARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform1fARB"));
    }
    glUniform1fARB(location, v0);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void uniform(i32 location, i32 count, span_const_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1fvARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform1fvARB"));
    }
    glUniform1fvARB(location, count, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void uniform(i32 location, i32 v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1iARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform1iARB"));
    }
    glUniform1iARB(location, v0);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void uniform(i32 location, i32 count, span_const_i32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1ivARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform1ivARB"));
    }
    glUniform1ivARB(location, count, reinterpret_cast<const GLint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_f32
>
requires (
    semantic::concepts::Vector<vec_2_f32, f32, 2>)
STATICINLINE void uniform(i32 location, vec_2_f32 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2fARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform2fARB"));
    }
    glUniform2fARB(location, v0.x(), v0.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_f32
>
requires (
    semantic::concepts::Span<span_const_vec_2_f32> &&
    semantic::concepts::Vector<typename span_const_vec_2_f32::value_type, f32, 2>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_2_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2fvARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform2fvARB"));
    }
    glUniform2fvARB(location, count, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void uniform(i32 location, vec_2_i32 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2iARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform2iARB"));
    }
    glUniform2iARB(location, v0.x(), v0.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_i32
>
requires (
    semantic::concepts::Span<span_const_vec_2_i32> &&
    semantic::concepts::Vector<typename span_const_vec_2_i32::value_type, i32, 2>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_2_i32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2ivARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform2ivARB"));
    }
    glUniform2ivARB(location, count, reinterpret_cast<const GLint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f32
>
requires (
    semantic::concepts::Vector<vec_3_f32, f32, 3>)
STATICINLINE void uniform(i32 location, vec_3_f32 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3fARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform3fARB"));
    }
    glUniform3fARB(location, v0.x(), v0.y(), v0.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_f32
>
requires (
    semantic::concepts::Span<span_const_vec_3_f32> &&
    semantic::concepts::Vector<typename span_const_vec_3_f32::value_type, f32, 3>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_3_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3fvARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform3fvARB"));
    }
    glUniform3fvARB(location, count, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void uniform(i32 location, vec_3_i32 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3iARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform3iARB"));
    }
    glUniform3iARB(location, v0.x(), v0.y(), v0.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_i32
>
requires (
    semantic::concepts::Span<span_const_vec_3_i32> &&
    semantic::concepts::Vector<typename span_const_vec_3_i32::value_type, i32, 3>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_3_i32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3ivARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform3ivARB"));
    }
    glUniform3ivARB(location, count, reinterpret_cast<const GLint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f32
>
requires (
    semantic::concepts::Vector<vec_4_f32, f32, 4>)
STATICINLINE void uniform(i32 location, vec_4_f32 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4fARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform4fARB"));
    }
    glUniform4fARB(location, v0.x(), v0.y(), v0.z(), v0.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f32
>
requires (
    semantic::concepts::Span<span_const_vec_4_f32> &&
    semantic::concepts::Vector<typename span_const_vec_4_f32::value_type, f32, 4>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_4_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4fvARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform4fvARB"));
    }
    glUniform4fvARB(location, count, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_i32
>
requires (
    semantic::concepts::Vector<vec_4_i32, i32, 4>)
STATICINLINE void uniform(i32 location, vec_4_i32 const& v0)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4iARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform4iARB"));
    }
    glUniform4iARB(location, v0.x(), v0.y(), v0.z(), v0.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_i32
>
requires (
    semantic::concepts::Span<span_const_vec_4_i32> &&
    semantic::concepts::Vector<typename span_const_vec_4_i32::value_type, i32, 4>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_4_i32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4ivARB)
                Throw(undefined_behavior(
                    "unloaded function Uniform4ivARB"));
    }
    glUniform4ivARB(location, count, reinterpret_cast<const GLint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_2x2_f32
>
requires (
    semantic::concepts::Span<span_const_mat_2x2_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_2x2_f32::value_type, f32, 2, 2>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_2x2_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix2fvARB)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix2fvARB"));
    }
    glUniformMatrix2fvARB(location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x3_f32
>
requires (
    semantic::concepts::Span<span_const_mat_3x3_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_3x3_f32::value_type, f32, 3, 3>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_3x3_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix3fvARB)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix3fvARB"));
    }
    glUniformMatrix3fvARB(location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_4x4_f32
>
requires (
    semantic::concepts::Span<span_const_mat_4x4_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_4x4_f32::value_type, f32, 4, 4>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_4x4_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix4fvARB)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix4fvARB"));
    }
    glUniformMatrix4fvARB(location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void use_program_object_arb(GLhandleARB programObj)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUseProgramObjectARB)
                Throw(undefined_behavior(
                    "unloaded function UseProgramObjectARB"));
    }
    glUseProgramObjectARB(programObj);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void validate_program_arb(GLhandleARB programObj)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glValidateProgramARB)
                Throw(undefined_behavior(
                    "unloaded function ValidateProgramARB"));
    }
    glValidateProgramARB(programObj);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_shader_objects
#endif // GL_ARB_shader_objects
#ifdef GL_ARB_shader_precision
namespace arb_shader_precision {
} // arb_shader_precision
#endif // GL_ARB_shader_precision
#ifdef GL_ARB_shader_stencil_export
namespace arb_shader_stencil_export {
} // arb_shader_stencil_export
#endif // GL_ARB_shader_stencil_export
#ifdef GL_ARB_shader_storage_buffer_object
namespace arb_shader_storage_buffer_object {
constexpr u32 shader_storage_barrier_bit = 0x00002000;
constexpr u32 max_combined_image_units_and_fragment_outputs = 0x8F39;
constexpr u32 max_combined_shader_output_resources = 0x8F39;
constexpr u32 shader_storage_buffer = 0x90D2;
constexpr u32 shader_storage_buffer_binding = 0x90D3;
constexpr u32 shader_storage_buffer_start = 0x90D4;
constexpr u32 shader_storage_buffer_size = 0x90D5;
constexpr u32 max_vertex_shader_storage_blocks = 0x90D6;
constexpr u32 max_geometry_shader_storage_blocks = 0x90D7;
constexpr u32 max_tess_control_shader_storage_blocks = 0x90D8;
constexpr u32 max_tess_evaluation_shader_storage_blocks = 0x90D9;
constexpr u32 max_fragment_shader_storage_blocks = 0x90DA;
constexpr u32 max_compute_shader_storage_blocks = 0x90DB;
constexpr u32 max_combined_shader_storage_blocks = 0x90DC;
constexpr u32 max_shader_storage_buffer_bindings = 0x90DD;
constexpr u32 max_shader_storage_block_size = 0x90DE;
constexpr u32 shader_storage_buffer_offset_alignment = 0x90DF;
STATICINLINE void shader_storage_block_binding(u32 program, u32 storageBlockIndex, u32 storageBlockBinding)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glShaderStorageBlockBinding)
                Throw(undefined_behavior(
                    "unloaded function ShaderStorageBlockBinding"));
        glIsProgram(program);
    }
    glShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_shader_storage_buffer_object
#endif // GL_ARB_shader_storage_buffer_object
#ifdef GL_ARB_shader_subroutine
namespace arb_shader_subroutine {
constexpr u32 uniform_size = 0x8A38;
constexpr u32 uniform_name_length = 0x8A39;
constexpr u32 active_subroutines = 0x8DE5;
constexpr u32 active_subroutine_uniforms = 0x8DE6;
constexpr u32 max_subroutines = 0x8DE7;
constexpr u32 max_subroutine_uniform_locations = 0x8DE8;
constexpr u32 active_subroutine_uniform_locations = 0x8E47;
constexpr u32 active_subroutine_max_length = 0x8E48;
constexpr u32 active_subroutine_uniform_max_length = 0x8E49;
constexpr u32 num_compatible_subroutines = 0x8E4A;
constexpr u32 compatible_subroutines = 0x8E4B;
template<
    class span_GLchar
>
requires (
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE void get_active_subroutine_name(u32 program, groups::shader_type shadertype, u32 index, i32& length, span_GLchar name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetActiveSubroutineName)
                Throw(undefined_behavior(
                    "unloaded function GetActiveSubroutineName"));
        glIsProgram(program);
    }
    glGetActiveSubroutineName(program, static_cast<GLenum>(shadertype), index, name.size(), &length, name.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLchar
>
requires (
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE void get_active_subroutine_uniform_name(u32 program, groups::shader_type shadertype, u32 index, i32& length, span_GLchar name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetActiveSubroutineUniformName)
                Throw(undefined_behavior(
                    "unloaded function GetActiveSubroutineUniformName"));
        glIsProgram(program);
    }
    glGetActiveSubroutineUniformName(program, static_cast<GLenum>(shadertype), index, name.size(), &length, name.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_active_subroutine_uniformiv(u32 program, groups::shader_type shadertype, u32 index, groups::subroutine_parameter_name pname, span_i32 values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetActiveSubroutineUniformiv)
                Throw(undefined_behavior(
                    "unloaded function GetActiveSubroutineUniformiv"));
        glIsProgram(program);
    }
    glGetActiveSubroutineUniformiv(program, static_cast<GLenum>(shadertype), index, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void get_program_stageiv(u32 program, groups::shader_type shadertype, groups::program_stage_prop pname, i32& values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramStageiv)
                Throw(undefined_behavior(
                    "unloaded function GetProgramStageiv"));
        glIsProgram(program);
    }
    glGetProgramStageiv(program, static_cast<GLenum>(shadertype), static_cast<GLenum>(pname), &values);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLuint get_subroutine_index(u32 program, groups::shader_type shadertype, std::string_view const& name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetSubroutineIndex)
                Throw(undefined_behavior(
                    "unloaded function GetSubroutineIndex"));
        glIsProgram(program);
    }
    auto out = glGetSubroutineIndex(program, static_cast<GLenum>(shadertype), name.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLint get_subroutine_uniform_location(u32 program, groups::shader_type shadertype, std::string_view const& name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetSubroutineUniformLocation)
                Throw(undefined_behavior(
                    "unloaded function GetSubroutineUniformLocation"));
        glIsProgram(program);
    }
    auto out = glGetSubroutineUniformLocation(program, static_cast<GLenum>(shadertype), name.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void get_uniform_subroutineuiv(groups::shader_type shadertype, i32 location, u32& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetUniformSubroutineuiv)
                Throw(undefined_behavior(
                    "unloaded function GetUniformSubroutineuiv"));
    }
    glGetUniformSubroutineuiv(static_cast<GLenum>(shadertype), location, &params);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void uniform_subroutines(groups::shader_type shadertype, span_const_u32 const& indices)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformSubroutinesuiv)
                Throw(undefined_behavior(
                    "unloaded function UniformSubroutinesuiv"));
    }
    glUniformSubroutinesuiv(static_cast<GLenum>(shadertype), indices.size(), reinterpret_cast<const GLuint *>(indices.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_shader_subroutine
#endif // GL_ARB_shader_subroutine
#ifdef GL_ARB_shader_texture_image_samples
namespace arb_shader_texture_image_samples {
} // arb_shader_texture_image_samples
#endif // GL_ARB_shader_texture_image_samples
#ifdef GL_ARB_shader_texture_lod
namespace arb_shader_texture_lod {
} // arb_shader_texture_lod
#endif // GL_ARB_shader_texture_lod
#ifdef GL_ARB_shader_viewport_layer_array
namespace arb_shader_viewport_layer_array {
} // arb_shader_viewport_layer_array
#endif // GL_ARB_shader_viewport_layer_array
#ifdef GL_ARB_shading_language_100
namespace arb_shading_language_100 {
constexpr u32 shading_language_version_arb = 0x8B8C;
} // arb_shading_language_100
#endif // GL_ARB_shading_language_100
#ifdef GL_ARB_shading_language_420pack
namespace arb_shading_language_420pack {
} // arb_shading_language_420pack
#endif // GL_ARB_shading_language_420pack
#ifdef GL_ARB_shading_language_include
namespace arb_shading_language_include {
constexpr u32 shader_include_arb = 0x8DAE;
constexpr u32 named_string_length_arb = 0x8DE9;
constexpr u32 named_string_type_arb = 0x8DEA;
template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void compile_shader_include_arb(u32 shader, std::vector<std::string_view> path, span_const_i32 const& length)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCompileShaderIncludeARB)
                Throw(undefined_behavior(
                    "unloaded function CompileShaderIncludeARB"));
        glIsShader(shader);
    }
    auto [path_lens, path_cstr, path_store] = detail::transform_strings(path);
    glCompileShaderIncludeARB(shader, path_cstr.size(), path_cstr.data(), reinterpret_cast<const GLint *>(length.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void delete_named_string_arb(std::string_view const& name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteNamedStringARB)
                Throw(undefined_behavior(
                    "unloaded function DeleteNamedStringARB"));
    }
    glDeleteNamedStringARB(name.size(), name.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLchar
>
requires (
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE void get_named_string_arb(std::string_view const& name, i32& stringlen, span_GLchar string)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetNamedStringARB)
                Throw(undefined_behavior(
                    "unloaded function GetNamedStringARB"));
    }
    glGetNamedStringARB(name.size(), name.data(), string.size(), &stringlen, string.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_named_stringiv_arb(std::string_view const& name, GLenum pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetNamedStringivARB)
                Throw(undefined_behavior(
                    "unloaded function GetNamedStringivARB"));
    }
    glGetNamedStringivARB(name.size(), name.data(), pname, reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_named_string_arb(std::string_view const& name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsNamedStringARB)
                Throw(undefined_behavior(
                    "unloaded function IsNamedStringARB"));
    }
    auto out = glIsNamedStringARB(name.size(), name.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void named_string_arb(GLenum type, std::string_view const& name, std::string_view const& string)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedStringARB)
                Throw(undefined_behavior(
                    "unloaded function NamedStringARB"));
    }
    glNamedStringARB(type, name.size(), name.data(), string.size(), string.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_shading_language_include
#endif // GL_ARB_shading_language_include
#ifdef GL_ARB_shading_language_packing
namespace arb_shading_language_packing {
} // arb_shading_language_packing
#endif // GL_ARB_shading_language_packing
#ifdef GL_ARB_shadow
namespace arb_shadow {
constexpr u32 texture_compare_mode_arb = 0x884C;
constexpr u32 texture_compare_func_arb = 0x884D;
constexpr u32 compare_r_to_texture_arb = 0x884E;
} // arb_shadow
#endif // GL_ARB_shadow
#ifdef GL_ARB_shadow_ambient
namespace arb_shadow_ambient {
constexpr u32 texture_compare_fail_value_arb = 0x80BF;
} // arb_shadow_ambient
#endif // GL_ARB_shadow_ambient
#ifdef GL_ARB_sparse_buffer
namespace arb_sparse_buffer {
constexpr u32 sparse_storage_bit_arb = 0x0400;
constexpr u32 sparse_buffer_page_size_arb = 0x82F8;
STATICINLINE void buffer_page_commitment_arb(GLenum target, GLintptr offset, GLsizeiptr size, bool commit)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBufferPageCommitmentARB)
                Throw(undefined_behavior(
                    "unloaded function BufferPageCommitmentARB"));
    }
    glBufferPageCommitmentARB(target, offset, size, commit);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void named_buffer_page_commitment_ext(u32 buffer, GLintptr offset, GLsizeiptr size, bool commit)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedBufferPageCommitmentEXT)
                Throw(undefined_behavior(
                    "unloaded function NamedBufferPageCommitmentEXT"));
        glIsBuffer(buffer);
    }
    glNamedBufferPageCommitmentEXT(buffer, offset, size, commit);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void named_buffer_page_commitment_arb(u32 buffer, GLintptr offset, GLsizeiptr size, bool commit)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedBufferPageCommitmentARB)
                Throw(undefined_behavior(
                    "unloaded function NamedBufferPageCommitmentARB"));
        glIsBuffer(buffer);
    }
    glNamedBufferPageCommitmentARB(buffer, offset, size, commit);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_sparse_buffer
#endif // GL_ARB_sparse_buffer
#ifdef GL_ARB_sparse_texture
namespace arb_sparse_texture {
constexpr u32 virtual_page_size_x_arb = 0x9195;
constexpr u32 virtual_page_size_y_arb = 0x9196;
constexpr u32 virtual_page_size_z_arb = 0x9197;
constexpr u32 max_sparse_texture_size_arb = 0x9198;
constexpr u32 max_sparse_3d_texture_size_arb = 0x9199;
constexpr u32 max_sparse_array_texture_layers_arb = 0x919A;
constexpr u32 texture_sparse_arb = 0x91A6;
constexpr u32 virtual_page_size_index_arb = 0x91A7;
constexpr u32 num_virtual_page_sizes_arb = 0x91A8;
constexpr u32 sparse_texture_full_array_cube_mipmaps_arb = 0x91A9;
constexpr u32 num_sparse_levels_arb = 0x91AA;
template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void tex_page_commitment_arb(GLenum target, i32 level, vec_3_i32 const& xoffset, vec_3_i32 const& width, bool commit)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexPageCommitmentARB)
                Throw(undefined_behavior(
                    "unloaded function TexPageCommitmentARB"));
    }
    glTexPageCommitmentARB(target, level, xoffset.x(), xoffset.y(), xoffset.z(), width[0], width[1], width[2], commit);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_sparse_texture
#endif // GL_ARB_sparse_texture
#ifdef GL_ARB_sparse_texture2
namespace arb_sparse_texture2 {
} // arb_sparse_texture2
#endif // GL_ARB_sparse_texture2
#ifdef GL_ARB_sparse_texture_clamp
namespace arb_sparse_texture_clamp {
} // arb_sparse_texture_clamp
#endif // GL_ARB_sparse_texture_clamp
#ifdef GL_ARB_spirv_extensions
namespace arb_spirv_extensions {
constexpr u32 spir_v_extensions = 0x9553;
constexpr u32 num_spir_v_extensions = 0x9554;
} // arb_spirv_extensions
#endif // GL_ARB_spirv_extensions
#ifdef GL_ARB_stencil_texturing
namespace arb_stencil_texturing {
constexpr u32 depth_stencil_texture_mode = 0x90EA;
} // arb_stencil_texturing
#endif // GL_ARB_stencil_texturing
#ifdef GL_ARB_sync
namespace arb_sync {
constexpr u32 sync_flush_commands_bit = 0x00000001;
constexpr u32 timeout_ignored = 0xFFFFFFFFFFFFFFFF;
constexpr u32 max_server_wait_timeout = 0x9111;
constexpr u32 object_type = 0x9112;
constexpr u32 sync_condition = 0x9113;
constexpr u32 sync_status = 0x9114;
constexpr u32 sync_flags = 0x9115;
constexpr u32 sync_fence = 0x9116;
constexpr u32 sync_gpu_commands_complete = 0x9117;
constexpr u32 unsignaled = 0x9118;
constexpr u32 signaled = 0x9119;
constexpr u32 already_signaled = 0x911A;
constexpr u32 timeout_expired = 0x911B;
constexpr u32 condition_satisfied = 0x911C;
constexpr u32 wait_failed = 0x911D;
STATICINLINE GLenum client_wait_sync(GLsync sync, groups::sync_object_mask flags, u64 timeout)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClientWaitSync)
                Throw(undefined_behavior(
                    "unloaded function ClientWaitSync"));
    }
    auto out = glClientWaitSync(sync, static_cast<GLenum>(flags), timeout);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void delete_sync(GLsync sync)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteSync)
                Throw(undefined_behavior(
                    "unloaded function DeleteSync"));
    }
    glDeleteSync(sync);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLsync fence_sync(groups::sync_condition condition, groups::sync_behavior_flags flags)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFenceSync)
                Throw(undefined_behavior(
                    "unloaded function FenceSync"));
    }
    auto out = glFenceSync(static_cast<GLenum>(condition), static_cast<GLenum>(flags));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_i64
>
requires (
    semantic::concepts::Span<span_i64> &&
    std::is_same_v<std::decay_t<typename span_i64::value_type>, i64>)
STATICINLINE void get_integer64v(groups::get_prop pname, span_i64 data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetInteger64v)
                Throw(undefined_behavior(
                    "unloaded function GetInteger64v"));
    }
    glGetInteger64v(static_cast<GLenum>(pname), reinterpret_cast<GLint64 *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_synciv(GLsync sync, groups::sync_parameter_name pname, i32& length, span_i32 values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetSynciv)
                Throw(undefined_behavior(
                    "unloaded function GetSynciv"));
    }
    glGetSynciv(sync, static_cast<GLenum>(pname), values.size(), &length, reinterpret_cast<GLint *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_sync(GLsync sync)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsSync)
                Throw(undefined_behavior(
                    "unloaded function IsSync"));
    }
    auto out = glIsSync(sync);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void wait_sync(GLsync sync, groups::sync_behavior_flags flags, u64 timeout)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWaitSync)
                Throw(undefined_behavior(
                    "unloaded function WaitSync"));
    }
    glWaitSync(sync, static_cast<GLenum>(flags), timeout);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_sync
#endif // GL_ARB_sync
#ifdef GL_ARB_tessellation_shader
namespace arb_tessellation_shader {
constexpr u32 triangles = 0x0004;
constexpr u32 quads = 0x0007;
constexpr u32 patches = 0x000E;
constexpr u32 equal = 0x0202;
constexpr u32 cw = 0x0900;
constexpr u32 ccw = 0x0901;
constexpr u32 uniform_block_referenced_by_tess_control_shader = 0x84F0;
constexpr u32 uniform_block_referenced_by_tess_evaluation_shader = 0x84F1;
constexpr u32 max_tess_control_input_components = 0x886C;
constexpr u32 max_tess_evaluation_input_components = 0x886D;
constexpr u32 max_combined_tess_control_uniform_components = 0x8E1E;
constexpr u32 max_combined_tess_evaluation_uniform_components = 0x8E1F;
constexpr u32 patch_vertices = 0x8E72;
constexpr u32 patch_default_inner_level = 0x8E73;
constexpr u32 patch_default_outer_level = 0x8E74;
constexpr u32 tess_control_output_vertices = 0x8E75;
constexpr u32 tess_gen_mode = 0x8E76;
constexpr u32 tess_gen_spacing = 0x8E77;
constexpr u32 tess_gen_vertex_order = 0x8E78;
constexpr u32 tess_gen_point_mode = 0x8E79;
constexpr u32 isolines = 0x8E7A;
constexpr u32 fractional_odd = 0x8E7B;
constexpr u32 fractional_even = 0x8E7C;
constexpr u32 max_patch_vertices = 0x8E7D;
constexpr u32 max_tess_gen_level = 0x8E7E;
constexpr u32 max_tess_control_uniform_components = 0x8E7F;
constexpr u32 max_tess_evaluation_uniform_components = 0x8E80;
constexpr u32 max_tess_control_texture_image_units = 0x8E81;
constexpr u32 max_tess_evaluation_texture_image_units = 0x8E82;
constexpr u32 max_tess_control_output_components = 0x8E83;
constexpr u32 max_tess_patch_components = 0x8E84;
constexpr u32 max_tess_control_total_output_components = 0x8E85;
constexpr u32 max_tess_evaluation_output_components = 0x8E86;
constexpr u32 tess_evaluation_shader = 0x8E87;
constexpr u32 tess_control_shader = 0x8E88;
constexpr u32 max_tess_control_uniform_blocks = 0x8E89;
constexpr u32 max_tess_evaluation_uniform_blocks = 0x8E8A;
template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void patch_parameter(groups::patch_parameter_name pname, span_const_f32 const& values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPatchParameterfv)
                Throw(undefined_behavior(
                    "unloaded function PatchParameterfv"));
    }
    glPatchParameterfv(static_cast<GLenum>(pname), reinterpret_cast<const GLfloat *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void patch_parameter(groups::patch_parameter_name pname, i32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPatchParameteri)
                Throw(undefined_behavior(
                    "unloaded function PatchParameteri"));
    }
    glPatchParameteri(static_cast<GLenum>(pname), value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_tessellation_shader
#endif // GL_ARB_tessellation_shader
#ifdef GL_ARB_texture_barrier
namespace arb_texture_barrier {
STATICINLINE void texture_barrier()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureBarrier)
                Throw(undefined_behavior(
                    "unloaded function TextureBarrier"));
    }
    glTextureBarrier();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_texture_barrier
#endif // GL_ARB_texture_barrier
#ifdef GL_ARB_texture_border_clamp
namespace arb_texture_border_clamp {
constexpr u32 clamp_to_border_arb = 0x812D;
} // arb_texture_border_clamp
#endif // GL_ARB_texture_border_clamp
#ifdef GL_ARB_texture_buffer_object
namespace arb_texture_buffer_object {
constexpr u32 texture_buffer_arb = 0x8C2A;
constexpr u32 max_texture_buffer_size_arb = 0x8C2B;
constexpr u32 texture_binding_buffer_arb = 0x8C2C;
constexpr u32 texture_buffer_data_store_binding_arb = 0x8C2D;
constexpr u32 texture_buffer_format_arb = 0x8C2E;
STATICINLINE void tex_buffer_arb(groups::texture_target target, groups::sized_internal_format internalformat, u32 buffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexBufferARB)
                Throw(undefined_behavior(
                    "unloaded function TexBufferARB"));
        glIsBuffer(buffer);
    }
    glTexBufferARB(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_texture_buffer_object
#endif // GL_ARB_texture_buffer_object
#ifdef GL_ARB_texture_buffer_object_rgb32
namespace arb_texture_buffer_object_rgb32 {
constexpr u32 rgb32f = 0x8815;
constexpr u32 rgb32ui = 0x8D71;
constexpr u32 rgb32i = 0x8D83;
} // arb_texture_buffer_object_rgb32
#endif // GL_ARB_texture_buffer_object_rgb32
#ifdef GL_ARB_texture_buffer_range
namespace arb_texture_buffer_range {
constexpr u32 texture_buffer_offset = 0x919D;
constexpr u32 texture_buffer_size = 0x919E;
constexpr u32 texture_buffer_offset_alignment = 0x919F;
STATICINLINE void tex_buffer_range(groups::texture_target target, groups::sized_internal_format internalformat, u32 buffer, GLintptr offset, GLsizeiptr size)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexBufferRange)
                Throw(undefined_behavior(
                    "unloaded function TexBufferRange"));
        glIsBuffer(buffer);
    }
    glTexBufferRange(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer, offset, size);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_texture_buffer_range
#endif // GL_ARB_texture_buffer_range
#ifdef GL_ARB_texture_compression
namespace arb_texture_compression {
constexpr u32 compressed_alpha_arb = 0x84E9;
constexpr u32 compressed_luminance_arb = 0x84EA;
constexpr u32 compressed_luminance_alpha_arb = 0x84EB;
constexpr u32 compressed_intensity_arb = 0x84EC;
constexpr u32 compressed_rgb_arb = 0x84ED;
constexpr u32 compressed_rgba_arb = 0x84EE;
constexpr u32 texture_compression_hint_arb = 0x84EF;
constexpr u32 texture_compressed_image_size_arb = 0x86A0;
constexpr u32 texture_compressed_arb = 0x86A1;
constexpr u32 num_compressed_texture_formats_arb = 0x86A2;
constexpr u32 compressed_texture_formats_arb = 0x86A3;
template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void compressed_tex_image_1darb(groups::texture_target target, i32 level, groups::internal_format internalformat, i32 width, i32 border, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCompressedTexImage1DARB)
                Throw(undefined_behavior(
                    "unloaded function CompressedTexImage1DARB"));
    }
    glCompressedTexImage1DARB(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, border, data.size(), reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void compressed_tex_image_2darb(groups::texture_target target, i32 level, groups::internal_format internalformat, vec_2_i32 const& width, i32 border, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCompressedTexImage2DARB)
                Throw(undefined_behavior(
                    "unloaded function CompressedTexImage2DARB"));
    }
    glCompressedTexImage2DARB(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width[0], width[1], border, data.size(), reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void compressed_tex_image_3darb(groups::texture_target target, i32 level, groups::internal_format internalformat, vec_3_i32 const& width, i32 border, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCompressedTexImage3DARB)
                Throw(undefined_behavior(
                    "unloaded function CompressedTexImage3DARB"));
    }
    glCompressedTexImage3DARB(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width[0], width[1], width[2], border, data.size(), reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void compressed_tex_sub_image_1darb(groups::texture_target target, i32 level, i32 xoffset, i32 width, groups::pixel_format format, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCompressedTexSubImage1DARB)
                Throw(undefined_behavior(
                    "unloaded function CompressedTexSubImage1DARB"));
    }
    glCompressedTexSubImage1DARB(static_cast<GLenum>(target), level, xoffset, width, static_cast<GLenum>(format), data.size(), reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void compressed_tex_sub_image_2darb(groups::texture_target target, i32 level, vec_2_i32 const& xoffset, vec_2_i32 const& width, groups::pixel_format format, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCompressedTexSubImage2DARB)
                Throw(undefined_behavior(
                    "unloaded function CompressedTexSubImage2DARB"));
    }
    glCompressedTexSubImage2DARB(static_cast<GLenum>(target), level, xoffset.x(), xoffset.y(), width[0], width[1], static_cast<GLenum>(format), data.size(), reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void compressed_tex_sub_image_3darb(groups::texture_target target, i32 level, vec_3_i32 const& xoffset, vec_3_i32 const& width, groups::pixel_format format, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCompressedTexSubImage3DARB)
                Throw(undefined_behavior(
                    "unloaded function CompressedTexSubImage3DARB"));
    }
    glCompressedTexSubImage3DARB(static_cast<GLenum>(target), level, xoffset.x(), xoffset.y(), xoffset.z(), width[0], width[1], width[2], static_cast<GLenum>(format), data.size(), reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_compressed_tex_image_arb(groups::texture_target target, i32 level, span_byte img)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetCompressedTexImageARB)
                Throw(undefined_behavior(
                    "unloaded function GetCompressedTexImageARB"));
    }
    glGetCompressedTexImageARB(static_cast<GLenum>(target), level, reinterpret_cast<void *>(img.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_texture_compression
#endif // GL_ARB_texture_compression
#ifdef GL_ARB_texture_compression_bptc
namespace arb_texture_compression_bptc {
constexpr u32 compressed_rgba_bptc_unorm_arb = 0x8E8C;
constexpr u32 compressed_srgb_alpha_bptc_unorm_arb = 0x8E8D;
constexpr u32 compressed_rgb_bptc_signed_float_arb = 0x8E8E;
constexpr u32 compressed_rgb_bptc_unsigned_float_arb = 0x8E8F;
} // arb_texture_compression_bptc
#endif // GL_ARB_texture_compression_bptc
#ifdef GL_ARB_texture_compression_rgtc
namespace arb_texture_compression_rgtc {
constexpr u32 compressed_red_rgtc1 = 0x8DBB;
constexpr u32 compressed_signed_red_rgtc1 = 0x8DBC;
constexpr u32 compressed_rg_rgtc2 = 0x8DBD;
constexpr u32 compressed_signed_rg_rgtc2 = 0x8DBE;
} // arb_texture_compression_rgtc
#endif // GL_ARB_texture_compression_rgtc
#ifdef GL_ARB_texture_cube_map
namespace arb_texture_cube_map {
constexpr u32 normal_map_arb = 0x8511;
constexpr u32 reflection_map_arb = 0x8512;
constexpr u32 texture_cube_map_arb = 0x8513;
constexpr u32 texture_binding_cube_map_arb = 0x8514;
constexpr u32 texture_cube_map_positive_x_arb = 0x8515;
constexpr u32 texture_cube_map_negative_x_arb = 0x8516;
constexpr u32 texture_cube_map_positive_y_arb = 0x8517;
constexpr u32 texture_cube_map_negative_y_arb = 0x8518;
constexpr u32 texture_cube_map_positive_z_arb = 0x8519;
constexpr u32 texture_cube_map_negative_z_arb = 0x851A;
constexpr u32 proxy_texture_cube_map_arb = 0x851B;
constexpr u32 max_cube_map_texture_size_arb = 0x851C;
} // arb_texture_cube_map
#endif // GL_ARB_texture_cube_map
#ifdef GL_ARB_texture_cube_map_array
namespace arb_texture_cube_map_array {
constexpr u32 texture_cube_map_array_arb = 0x9009;
constexpr u32 texture_binding_cube_map_array_arb = 0x900A;
constexpr u32 proxy_texture_cube_map_array_arb = 0x900B;
constexpr u32 sampler_cube_map_array_arb = 0x900C;
constexpr u32 sampler_cube_map_array_shadow_arb = 0x900D;
constexpr u32 int_sampler_cube_map_array_arb = 0x900E;
constexpr u32 unsigned_int_sampler_cube_map_array_arb = 0x900F;
} // arb_texture_cube_map_array
#endif // GL_ARB_texture_cube_map_array
#ifdef GL_ARB_texture_env_add
namespace arb_texture_env_add {
} // arb_texture_env_add
#endif // GL_ARB_texture_env_add
#ifdef GL_ARB_texture_env_combine
namespace arb_texture_env_combine {
constexpr u32 subtract_arb = 0x84E7;
constexpr u32 combine_arb = 0x8570;
constexpr u32 combine_rgb_arb = 0x8571;
constexpr u32 combine_alpha_arb = 0x8572;
constexpr u32 rgb_scale_arb = 0x8573;
constexpr u32 add_signed_arb = 0x8574;
constexpr u32 interpolate_arb = 0x8575;
constexpr u32 constant_arb = 0x8576;
constexpr u32 primary_color_arb = 0x8577;
constexpr u32 previous_arb = 0x8578;
constexpr u32 source0_rgb_arb = 0x8580;
constexpr u32 source1_rgb_arb = 0x8581;
constexpr u32 source2_rgb_arb = 0x8582;
constexpr u32 source0_alpha_arb = 0x8588;
constexpr u32 source1_alpha_arb = 0x8589;
constexpr u32 source2_alpha_arb = 0x858A;
constexpr u32 operand0_rgb_arb = 0x8590;
constexpr u32 operand1_rgb_arb = 0x8591;
constexpr u32 operand2_rgb_arb = 0x8592;
constexpr u32 operand0_alpha_arb = 0x8598;
constexpr u32 operand1_alpha_arb = 0x8599;
constexpr u32 operand2_alpha_arb = 0x859A;
} // arb_texture_env_combine
#endif // GL_ARB_texture_env_combine
#ifdef GL_ARB_texture_env_crossbar
namespace arb_texture_env_crossbar {
} // arb_texture_env_crossbar
#endif // GL_ARB_texture_env_crossbar
#ifdef GL_ARB_texture_env_dot3
namespace arb_texture_env_dot3 {
constexpr u32 dot3_rgb_arb = 0x86AE;
constexpr u32 dot3_rgba_arb = 0x86AF;
} // arb_texture_env_dot3
#endif // GL_ARB_texture_env_dot3
#ifdef GL_ARB_texture_filter_anisotropic
namespace arb_texture_filter_anisotropic {
constexpr u32 texture_max_anisotropy = 0x84FE;
constexpr u32 max_texture_max_anisotropy = 0x84FF;
} // arb_texture_filter_anisotropic
#endif // GL_ARB_texture_filter_anisotropic
#ifdef GL_ARB_texture_filter_minmax
namespace arb_texture_filter_minmax {
constexpr u32 texture_reduction_mode_arb = 0x9366;
constexpr u32 weighted_average_arb = 0x9367;
} // arb_texture_filter_minmax
#endif // GL_ARB_texture_filter_minmax
#ifdef GL_ARB_texture_float
namespace arb_texture_float {
constexpr u32 rgba32f_arb = 0x8814;
constexpr u32 rgb32f_arb = 0x8815;
constexpr u32 alpha32f_arb = 0x8816;
constexpr u32 intensity32f_arb = 0x8817;
constexpr u32 luminance32f_arb = 0x8818;
constexpr u32 luminance_alpha32f_arb = 0x8819;
constexpr u32 rgba16f_arb = 0x881A;
constexpr u32 rgb16f_arb = 0x881B;
constexpr u32 alpha16f_arb = 0x881C;
constexpr u32 intensity16f_arb = 0x881D;
constexpr u32 luminance16f_arb = 0x881E;
constexpr u32 luminance_alpha16f_arb = 0x881F;
constexpr u32 texture_red_type_arb = 0x8C10;
constexpr u32 texture_green_type_arb = 0x8C11;
constexpr u32 texture_blue_type_arb = 0x8C12;
constexpr u32 texture_alpha_type_arb = 0x8C13;
constexpr u32 texture_luminance_type_arb = 0x8C14;
constexpr u32 texture_intensity_type_arb = 0x8C15;
constexpr u32 texture_depth_type_arb = 0x8C16;
constexpr u32 unsigned_normalized_arb = 0x8C17;
} // arb_texture_float
#endif // GL_ARB_texture_float
#ifdef GL_ARB_texture_gather
namespace arb_texture_gather {
constexpr u32 min_program_texture_gather_offset_arb = 0x8E5E;
constexpr u32 max_program_texture_gather_offset_arb = 0x8E5F;
constexpr u32 max_program_texture_gather_components_arb = 0x8F9F;
} // arb_texture_gather
#endif // GL_ARB_texture_gather
#ifdef GL_ARB_texture_mirror_clamp_to_edge
namespace arb_texture_mirror_clamp_to_edge {
constexpr u32 mirror_clamp_to_edge = 0x8743;
} // arb_texture_mirror_clamp_to_edge
#endif // GL_ARB_texture_mirror_clamp_to_edge
#ifdef GL_ARB_texture_mirrored_repeat
namespace arb_texture_mirrored_repeat {
constexpr u32 mirrored_repeat_arb = 0x8370;
} // arb_texture_mirrored_repeat
#endif // GL_ARB_texture_mirrored_repeat
#ifdef GL_ARB_texture_multisample
namespace arb_texture_multisample {
constexpr u32 sample_position = 0x8E50;
constexpr u32 sample_mask = 0x8E51;
constexpr u32 sample_mask_value = 0x8E52;
constexpr u32 max_sample_mask_words = 0x8E59;
constexpr u32 texture_2d_multisample = 0x9100;
constexpr u32 proxy_texture_2d_multisample = 0x9101;
constexpr u32 texture_2d_multisample_array = 0x9102;
constexpr u32 proxy_texture_2d_multisample_array = 0x9103;
constexpr u32 texture_binding_2d_multisample = 0x9104;
constexpr u32 texture_binding_2d_multisample_array = 0x9105;
constexpr u32 texture_samples = 0x9106;
constexpr u32 texture_fixed_sample_locations = 0x9107;
constexpr u32 sampler_2d_multisample = 0x9108;
constexpr u32 int_sampler_2d_multisample = 0x9109;
constexpr u32 unsigned_int_sampler_2d_multisample = 0x910A;
constexpr u32 sampler_2d_multisample_array = 0x910B;
constexpr u32 int_sampler_2d_multisample_array = 0x910C;
constexpr u32 unsigned_int_sampler_2d_multisample_array = 0x910D;
constexpr u32 max_color_texture_samples = 0x910E;
constexpr u32 max_depth_texture_samples = 0x910F;
constexpr u32 max_integer_samples = 0x9110;
template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_multisamplefv(groups::get_multisample_prop_nv pname, u32 index, span_f32 val)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetMultisamplefv)
                Throw(undefined_behavior(
                    "unloaded function GetMultisamplefv"));
    }
    glGetMultisamplefv(static_cast<GLenum>(pname), index, reinterpret_cast<GLfloat *>(val.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void sample_maski(u32 maskNumber, GLbitfield mask)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSampleMaski)
                Throw(undefined_behavior(
                    "unloaded function SampleMaski"));
    }
    glSampleMaski(maskNumber, mask);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void tex_image_2d_multisample(groups::texture_target target, i32 samples, groups::internal_format internalformat, vec_2_i32 const& width, bool fixedsamplelocations)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexImage2DMultisample)
                Throw(undefined_behavior(
                    "unloaded function TexImage2DMultisample"));
    }
    glTexImage2DMultisample(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width[0], width[1], fixedsamplelocations);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void tex_image_3d_multisample(groups::texture_target target, i32 samples, groups::internal_format internalformat, vec_3_i32 const& width, bool fixedsamplelocations)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexImage3DMultisample)
                Throw(undefined_behavior(
                    "unloaded function TexImage3DMultisample"));
    }
    glTexImage3DMultisample(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width[0], width[1], width[2], fixedsamplelocations);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_texture_multisample
#endif // GL_ARB_texture_multisample
#ifdef GL_ARB_texture_non_power_of_two
namespace arb_texture_non_power_of_two {
} // arb_texture_non_power_of_two
#endif // GL_ARB_texture_non_power_of_two
#ifdef GL_ARB_texture_query_levels
namespace arb_texture_query_levels {
} // arb_texture_query_levels
#endif // GL_ARB_texture_query_levels
#ifdef GL_ARB_texture_query_lod
namespace arb_texture_query_lod {
} // arb_texture_query_lod
#endif // GL_ARB_texture_query_lod
#ifdef GL_ARB_texture_rectangle
namespace arb_texture_rectangle {
constexpr u32 texture_rectangle_arb = 0x84F5;
constexpr u32 texture_binding_rectangle_arb = 0x84F6;
constexpr u32 proxy_texture_rectangle_arb = 0x84F7;
constexpr u32 max_rectangle_texture_size_arb = 0x84F8;
} // arb_texture_rectangle
#endif // GL_ARB_texture_rectangle
#ifdef GL_ARB_texture_rg
namespace arb_texture_rg {
constexpr u32 rg = 0x8227;
constexpr u32 rg_integer = 0x8228;
constexpr u32 r8 = 0x8229;
constexpr u32 r16 = 0x822A;
constexpr u32 rg8 = 0x822B;
constexpr u32 rg16 = 0x822C;
constexpr u32 r16f = 0x822D;
constexpr u32 r32f = 0x822E;
constexpr u32 rg16f = 0x822F;
constexpr u32 rg32f = 0x8230;
constexpr u32 r8i = 0x8231;
constexpr u32 r8ui = 0x8232;
constexpr u32 r16i = 0x8233;
constexpr u32 r16ui = 0x8234;
constexpr u32 r32i = 0x8235;
constexpr u32 r32ui = 0x8236;
constexpr u32 rg8i = 0x8237;
constexpr u32 rg8ui = 0x8238;
constexpr u32 rg16i = 0x8239;
constexpr u32 rg16ui = 0x823A;
constexpr u32 rg32i = 0x823B;
constexpr u32 rg32ui = 0x823C;
} // arb_texture_rg
#endif // GL_ARB_texture_rg
#ifdef GL_ARB_texture_rgb10_a2ui
namespace arb_texture_rgb10_a2ui {
constexpr u32 rgb10_a2ui = 0x906F;
} // arb_texture_rgb10_a2ui
#endif // GL_ARB_texture_rgb10_a2ui
#ifdef GL_ARB_texture_stencil8
namespace arb_texture_stencil8 {
constexpr u32 stencil_index = 0x1901;
constexpr u32 stencil_index8 = 0x8D48;
} // arb_texture_stencil8
#endif // GL_ARB_texture_stencil8
#ifdef GL_ARB_texture_storage
namespace arb_texture_storage {
constexpr u32 texture_immutable_format = 0x912F;
STATICINLINE void tex_storage_1d(groups::texture_target target, i32 levels, groups::sized_internal_format internalformat, i32 width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexStorage1D)
                Throw(undefined_behavior(
                    "unloaded function TexStorage1D"));
    }
    glTexStorage1D(static_cast<GLenum>(target), levels, static_cast<GLenum>(internalformat), width);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void tex_storage_2d(groups::texture_target target, i32 levels, groups::sized_internal_format internalformat, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexStorage2D)
                Throw(undefined_behavior(
                    "unloaded function TexStorage2D"));
    }
    glTexStorage2D(static_cast<GLenum>(target), levels, static_cast<GLenum>(internalformat), width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void tex_storage_3d(groups::texture_target target, i32 levels, groups::sized_internal_format internalformat, vec_3_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexStorage3D)
                Throw(undefined_behavior(
                    "unloaded function TexStorage3D"));
    }
    glTexStorage3D(static_cast<GLenum>(target), levels, static_cast<GLenum>(internalformat), width[0], width[1], width[2]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_texture_storage
#endif // GL_ARB_texture_storage
#ifdef GL_ARB_texture_storage_multisample
namespace arb_texture_storage_multisample {
template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void tex_storage_2d_multisample(groups::texture_target target, i32 samples, groups::sized_internal_format internalformat, vec_2_i32 const& width, bool fixedsamplelocations)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexStorage2DMultisample)
                Throw(undefined_behavior(
                    "unloaded function TexStorage2DMultisample"));
    }
    glTexStorage2DMultisample(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width[0], width[1], fixedsamplelocations);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void tex_storage_3d_multisample(groups::texture_target target, i32 samples, groups::sized_internal_format internalformat, vec_3_i32 const& width, bool fixedsamplelocations)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexStorage3DMultisample)
                Throw(undefined_behavior(
                    "unloaded function TexStorage3DMultisample"));
    }
    glTexStorage3DMultisample(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width[0], width[1], width[2], fixedsamplelocations);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_texture_storage_multisample
#endif // GL_ARB_texture_storage_multisample
#ifdef GL_ARB_texture_swizzle
namespace arb_texture_swizzle {
constexpr u32 texture_swizzle_r = 0x8E42;
constexpr u32 texture_swizzle_g = 0x8E43;
constexpr u32 texture_swizzle_b = 0x8E44;
constexpr u32 texture_swizzle_a = 0x8E45;
constexpr u32 texture_swizzle_rgba = 0x8E46;
} // arb_texture_swizzle
#endif // GL_ARB_texture_swizzle
#ifdef GL_ARB_texture_view
namespace arb_texture_view {
constexpr u32 texture_view_min_level = 0x82DB;
constexpr u32 texture_view_num_levels = 0x82DC;
constexpr u32 texture_view_min_layer = 0x82DD;
constexpr u32 texture_view_num_layers = 0x82DE;
constexpr u32 texture_immutable_levels = 0x82DF;
STATICINLINE void texture_view(u32 texture, groups::texture_target target, u32 origtexture, groups::sized_internal_format internalformat, u32 minlevel, u32 numlevels, u32 minlayer, u32 numlayers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureView)
                Throw(undefined_behavior(
                    "unloaded function TextureView"));
        glIsTexture(texture);
    }
    glTextureView(texture, static_cast<GLenum>(target), origtexture, static_cast<GLenum>(internalformat), minlevel, numlevels, minlayer, numlayers);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_texture_view
#endif // GL_ARB_texture_view
#ifdef GL_ARB_timer_query
namespace arb_timer_query {
constexpr u32 time_elapsed = 0x88BF;
constexpr u32 timestamp = 0x8E28;
template<
    class span_i64
>
requires (
    semantic::concepts::Span<span_i64> &&
    std::is_same_v<std::decay_t<typename span_i64::value_type>, i64>)
STATICINLINE void get_query_objecti64v(u32 id, groups::query_object_parameter_name pname, span_i64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetQueryObjecti64v)
                Throw(undefined_behavior(
                    "unloaded function GetQueryObjecti64v"));
    }
    glGetQueryObjecti64v(id, static_cast<GLenum>(pname), reinterpret_cast<GLint64 *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u64
>
requires (
    semantic::concepts::Span<span_u64> &&
    std::is_same_v<std::decay_t<typename span_u64::value_type>, u64>)
STATICINLINE void get_query_objectui64v(u32 id, groups::query_object_parameter_name pname, span_u64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetQueryObjectui64v)
                Throw(undefined_behavior(
                    "unloaded function GetQueryObjectui64v"));
    }
    glGetQueryObjectui64v(id, static_cast<GLenum>(pname), reinterpret_cast<GLuint64 *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void query_counter(u32 id, groups::query_counter_target target)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glQueryCounter)
                Throw(undefined_behavior(
                    "unloaded function QueryCounter"));
    }
    glQueryCounter(id, static_cast<GLenum>(target));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_timer_query
#endif // GL_ARB_timer_query
#ifdef GL_ARB_transform_feedback2
namespace arb_transform_feedback2 {
constexpr u32 transform_feedback = 0x8E22;
constexpr u32 transform_feedback_buffer_paused = 0x8E23;
constexpr u32 transform_feedback_buffer_active = 0x8E24;
constexpr u32 transform_feedback_binding = 0x8E25;
STATICINLINE void bind_transform_feedback(groups::bind_transform_feedback_target target, u32 id)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindTransformFeedback)
                Throw(undefined_behavior(
                    "unloaded function BindTransformFeedback"));
    }
    glBindTransformFeedback(static_cast<GLenum>(target), id);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_transform_feedbacks(span_const_u32 const& ids)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteTransformFeedbacks)
                Throw(undefined_behavior(
                    "unloaded function DeleteTransformFeedbacks"));
    }
    glDeleteTransformFeedbacks(ids.size(), reinterpret_cast<const GLuint *>(ids.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void draw_transform_feedback(groups::primitive_type mode, u32 id)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawTransformFeedback)
                Throw(undefined_behavior(
                    "unloaded function DrawTransformFeedback"));
    }
    glDrawTransformFeedback(static_cast<GLenum>(mode), id);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void gen_transform_feedbacks(span_u32 ids)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenTransformFeedbacks)
                Throw(undefined_behavior(
                    "unloaded function GenTransformFeedbacks"));
    }
    glGenTransformFeedbacks(ids.size(), reinterpret_cast<GLuint *>(ids.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_transform_feedback(u32 id)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsTransformFeedback)
                Throw(undefined_behavior(
                    "unloaded function IsTransformFeedback"));
    }
    auto out = glIsTransformFeedback(id);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void pause_transform_feedback()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPauseTransformFeedback)
                Throw(undefined_behavior(
                    "unloaded function PauseTransformFeedback"));
    }
    glPauseTransformFeedback();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void resume_transform_feedback()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glResumeTransformFeedback)
                Throw(undefined_behavior(
                    "unloaded function ResumeTransformFeedback"));
    }
    glResumeTransformFeedback();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_transform_feedback2
#endif // GL_ARB_transform_feedback2
#ifdef GL_ARB_transform_feedback3
namespace arb_transform_feedback3 {
constexpr u32 max_transform_feedback_buffers = 0x8E70;
constexpr u32 max_vertex_streams = 0x8E71;
STATICINLINE void begin_query_indexed(groups::query_target target, u32 index, u32 id)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBeginQueryIndexed)
                Throw(undefined_behavior(
                    "unloaded function BeginQueryIndexed"));
    }
    glBeginQueryIndexed(static_cast<GLenum>(target), index, id);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void draw_transform_feedback_stream(groups::primitive_type mode, u32 id, u32 stream)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawTransformFeedbackStream)
                Throw(undefined_behavior(
                    "unloaded function DrawTransformFeedbackStream"));
    }
    glDrawTransformFeedbackStream(static_cast<GLenum>(mode), id, stream);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void end_query_indexed(groups::query_target target, u32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEndQueryIndexed)
                Throw(undefined_behavior(
                    "unloaded function EndQueryIndexed"));
    }
    glEndQueryIndexed(static_cast<GLenum>(target), index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_query_indexediv(groups::query_target target, u32 index, groups::query_parameter_name pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetQueryIndexediv)
                Throw(undefined_behavior(
                    "unloaded function GetQueryIndexediv"));
    }
    glGetQueryIndexediv(static_cast<GLenum>(target), index, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_transform_feedback3
#endif // GL_ARB_transform_feedback3
#ifdef GL_ARB_transform_feedback_instanced
namespace arb_transform_feedback_instanced {
STATICINLINE void draw_transform_feedback_instanced(groups::primitive_type mode, u32 id, i32 instancecount)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawTransformFeedbackInstanced)
                Throw(undefined_behavior(
                    "unloaded function DrawTransformFeedbackInstanced"));
    }
    glDrawTransformFeedbackInstanced(static_cast<GLenum>(mode), id, instancecount);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void draw_transform_feedback_stream_instanced(groups::primitive_type mode, u32 id, u32 stream, i32 instancecount)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawTransformFeedbackStreamInstanced)
                Throw(undefined_behavior(
                    "unloaded function DrawTransformFeedbackStreamInstanced"));
    }
    glDrawTransformFeedbackStreamInstanced(static_cast<GLenum>(mode), id, stream, instancecount);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_transform_feedback_instanced
#endif // GL_ARB_transform_feedback_instanced
#ifdef GL_ARB_transform_feedback_overflow_query
namespace arb_transform_feedback_overflow_query {
constexpr u32 transform_feedback_overflow_arb = 0x82EC;
constexpr u32 transform_feedback_stream_overflow_arb = 0x82ED;
} // arb_transform_feedback_overflow_query
#endif // GL_ARB_transform_feedback_overflow_query
#ifdef GL_ARB_transpose_matrix
namespace arb_transpose_matrix {
constexpr u32 transpose_modelview_matrix_arb = 0x84E3;
constexpr u32 transpose_projection_matrix_arb = 0x84E4;
constexpr u32 transpose_texture_matrix_arb = 0x84E5;
constexpr u32 transpose_color_matrix_arb = 0x84E6;
template<
    class span_const_mat_NonexNone_f64
>
requires (
    semantic::concepts::Span<span_const_mat_NonexNone_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_NonexNone_f64::value_type, f64, None, None>)
STATICINLINE void load_transpose_matrixd_arb(span_const_mat_NonexNone_f64 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glLoadTransposeMatrixdARB)
                Throw(undefined_behavior(
                    "unloaded function LoadTransposeMatrixdARB"));
    }
    glLoadTransposeMatrixdARB(reinterpret_cast<const GLdouble *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_NonexNone_f32
>
requires (
    semantic::concepts::Span<span_const_mat_NonexNone_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_NonexNone_f32::value_type, f32, None, None>)
STATICINLINE void load_transpose_matrixf_arb(span_const_mat_NonexNone_f32 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glLoadTransposeMatrixfARB)
                Throw(undefined_behavior(
                    "unloaded function LoadTransposeMatrixfARB"));
    }
    glLoadTransposeMatrixfARB(reinterpret_cast<const GLfloat *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_NonexNone_f64
>
requires (
    semantic::concepts::Span<span_const_mat_NonexNone_f64> &&
    semantic::concepts::Matrix<typename span_const_mat_NonexNone_f64::value_type, f64, None, None>)
STATICINLINE void mult_transpose_matrixd_arb(span_const_mat_NonexNone_f64 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultTransposeMatrixdARB)
                Throw(undefined_behavior(
                    "unloaded function MultTransposeMatrixdARB"));
    }
    glMultTransposeMatrixdARB(reinterpret_cast<const GLdouble *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_NonexNone_f32
>
requires (
    semantic::concepts::Span<span_const_mat_NonexNone_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_NonexNone_f32::value_type, f32, None, None>)
STATICINLINE void mult_transpose_matrixf_arb(span_const_mat_NonexNone_f32 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultTransposeMatrixfARB)
                Throw(undefined_behavior(
                    "unloaded function MultTransposeMatrixfARB"));
    }
    glMultTransposeMatrixfARB(reinterpret_cast<const GLfloat *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_transpose_matrix
#endif // GL_ARB_transpose_matrix
#ifdef GL_ARB_uniform_buffer_object
namespace arb_uniform_buffer_object {
constexpr u32 invalid_index = 0xFFFFFFFF;
constexpr u32 uniform_buffer = 0x8A11;
constexpr u32 uniform_buffer_binding = 0x8A28;
constexpr u32 uniform_buffer_start = 0x8A29;
constexpr u32 uniform_buffer_size = 0x8A2A;
constexpr u32 max_vertex_uniform_blocks = 0x8A2B;
constexpr u32 max_geometry_uniform_blocks = 0x8A2C;
constexpr u32 max_fragment_uniform_blocks = 0x8A2D;
constexpr u32 max_combined_uniform_blocks = 0x8A2E;
constexpr u32 max_uniform_buffer_bindings = 0x8A2F;
constexpr u32 max_uniform_block_size = 0x8A30;
constexpr u32 max_combined_vertex_uniform_components = 0x8A31;
constexpr u32 max_combined_geometry_uniform_components = 0x8A32;
constexpr u32 max_combined_fragment_uniform_components = 0x8A33;
constexpr u32 uniform_buffer_offset_alignment = 0x8A34;
constexpr u32 active_uniform_block_max_name_length = 0x8A35;
constexpr u32 active_uniform_blocks = 0x8A36;
constexpr u32 uniform_type = 0x8A37;
constexpr u32 uniform_size = 0x8A38;
constexpr u32 uniform_name_length = 0x8A39;
constexpr u32 uniform_block_index = 0x8A3A;
constexpr u32 uniform_offset = 0x8A3B;
constexpr u32 uniform_array_stride = 0x8A3C;
constexpr u32 uniform_matrix_stride = 0x8A3D;
constexpr u32 uniform_is_row_major = 0x8A3E;
constexpr u32 uniform_block_binding = 0x8A3F;
constexpr u32 uniform_block_data_size = 0x8A40;
constexpr u32 uniform_block_name_length = 0x8A41;
constexpr u32 uniform_block_active_uniforms = 0x8A42;
constexpr u32 uniform_block_active_uniform_indices = 0x8A43;
constexpr u32 uniform_block_referenced_by_vertex_shader = 0x8A44;
constexpr u32 uniform_block_referenced_by_geometry_shader = 0x8A45;
constexpr u32 uniform_block_referenced_by_fragment_shader = 0x8A46;
STATICINLINE void bind_buffer_base(groups::buffer_target_arb target, u32 index, u32 buffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindBufferBase)
                Throw(undefined_behavior(
                    "unloaded function BindBufferBase"));
        glIsBuffer(buffer);
    }
    glBindBufferBase(static_cast<GLenum>(target), index, buffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void bind_buffer_range(groups::buffer_target_arb target, u32 index, u32 buffer, GLintptr offset, GLsizeiptr size)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindBufferRange)
                Throw(undefined_behavior(
                    "unloaded function BindBufferRange"));
        glIsBuffer(buffer);
    }
    glBindBufferRange(static_cast<GLenum>(target), index, buffer, offset, size);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLchar
>
requires (
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE void get_active_uniform_block_name(u32 program, u32 uniformBlockIndex, i32& length, span_GLchar uniformBlockName)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetActiveUniformBlockName)
                Throw(undefined_behavior(
                    "unloaded function GetActiveUniformBlockName"));
        glIsProgram(program);
    }
    glGetActiveUniformBlockName(program, uniformBlockIndex, uniformBlockName.size(), &length, uniformBlockName.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_active_uniform_blockiv(u32 program, u32 uniformBlockIndex, groups::uniform_block_prop pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetActiveUniformBlockiv)
                Throw(undefined_behavior(
                    "unloaded function GetActiveUniformBlockiv"));
        glIsProgram(program);
    }
    glGetActiveUniformBlockiv(program, uniformBlockIndex, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLchar
>
requires (
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE void get_active_uniform_name(u32 program, u32 uniformIndex, i32& length, span_GLchar uniformName)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetActiveUniformName)
                Throw(undefined_behavior(
                    "unloaded function GetActiveUniformName"));
        glIsProgram(program);
    }
    glGetActiveUniformName(program, uniformIndex, uniformName.size(), &length, uniformName.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32,
    class span_i32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32> &&
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_active_uniformsiv(u32 program, span_const_u32 const& uniformIndices, groups::uniform_prop pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetActiveUniformsiv)
                Throw(undefined_behavior(
                    "unloaded function GetActiveUniformsiv"));
        glIsProgram(program);
    }
    glGetActiveUniformsiv(program, uniformIndices.size(), reinterpret_cast<const GLuint *>(uniformIndices.data()), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_integeri_v(groups::get_prop target, u32 index, span_i32 data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetIntegeri_v)
                Throw(undefined_behavior(
                    "unloaded function GetIntegeri_v"));
    }
    glGetIntegeri_v(static_cast<GLenum>(target), index, reinterpret_cast<GLint *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLuint get_uniform_block_index(u32 program, std::string_view const& uniformBlockName)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetUniformBlockIndex)
                Throw(undefined_behavior(
                    "unloaded function GetUniformBlockIndex"));
        glIsProgram(program);
    }
    auto out = glGetUniformBlockIndex(program, uniformBlockName.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_uniform_indices(u32 program, i32 uniformCount, std::vector<std::string_view> uniformNames, span_u32 uniformIndices)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetUniformIndices)
                Throw(undefined_behavior(
                    "unloaded function GetUniformIndices"));
        glIsProgram(program);
    }
    auto [uniformNames_lens, uniformNames_cstr, uniformNames_store] = detail::transform_strings(uniformNames);
    glGetUniformIndices(program, uniformCount, uniformNames_cstr.data(), reinterpret_cast<GLuint *>(uniformIndices.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void uniform_block_binding(u32 program, u32 uniformBlockIndex, u32 uniformBlockBinding)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformBlockBinding)
                Throw(undefined_behavior(
                    "unloaded function UniformBlockBinding"));
        glIsProgram(program);
    }
    glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_uniform_buffer_object
#endif // GL_ARB_uniform_buffer_object
#ifdef GL_ARB_vertex_array_bgra
namespace arb_vertex_array_bgra {
constexpr u32 bgra = 0x80E1;
} // arb_vertex_array_bgra
#endif // GL_ARB_vertex_array_bgra
#ifdef GL_ARB_vertex_array_object
namespace arb_vertex_array_object {
constexpr u32 vertex_array_binding = 0x85B5;
STATICINLINE void bind_vertex_array(u32 array)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindVertexArray)
                Throw(undefined_behavior(
                    "unloaded function BindVertexArray"));
        glIsVertexArray(array);
    }
    glBindVertexArray(array);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_vertex_arrays(span_const_u32 const& arrays)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteVertexArrays)
                Throw(undefined_behavior(
                    "unloaded function DeleteVertexArrays"));
    }
    glDeleteVertexArrays(arrays.size(), reinterpret_cast<const GLuint *>(arrays.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void gen_vertex_arrays(span_u32 arrays)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenVertexArrays)
                Throw(undefined_behavior(
                    "unloaded function GenVertexArrays"));
    }
    glGenVertexArrays(arrays.size(), reinterpret_cast<GLuint *>(arrays.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_vertex_array(u32 array)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsVertexArray)
                Throw(undefined_behavior(
                    "unloaded function IsVertexArray"));
        glIsVertexArray(array);
    }
    auto out = glIsVertexArray(array);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // arb_vertex_array_object
#endif // GL_ARB_vertex_array_object
#ifdef GL_ARB_vertex_attrib_64bit
namespace arb_vertex_attrib_64bit {
constexpr u32 rgb32i = 0x8D83;
constexpr u32 double_mat2 = 0x8F46;
constexpr u32 double_mat3 = 0x8F47;
constexpr u32 double_mat4 = 0x8F48;
constexpr u32 double_mat2x3 = 0x8F49;
constexpr u32 double_mat2x4 = 0x8F4A;
constexpr u32 double_mat3x2 = 0x8F4B;
constexpr u32 double_mat3x4 = 0x8F4C;
constexpr u32 double_mat4x2 = 0x8F4D;
constexpr u32 double_mat4x3 = 0x8F4E;
constexpr u32 double_vec2 = 0x8FFC;
constexpr u32 double_vec3 = 0x8FFD;
constexpr u32 double_vec4 = 0x8FFE;
template<
    class span_f64
>
requires (
    semantic::concepts::Span<span_f64> &&
    std::is_same_v<std::decay_t<typename span_f64::value_type>, f64>)
STATICINLINE void get_vertex_attrib_ldv(u32 index, groups::vertex_attrib_enum pname, span_f64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribLdv)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribLdv"));
    }
    glGetVertexAttribLdv(index, static_cast<GLenum>(pname), reinterpret_cast<GLdouble *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib_l1d(u32 index, f64 x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL1d)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL1d"));
    }
    glVertexAttribL1d(index, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f64
>
requires (
    semantic::concepts::Span<span_const_f64> &&
    std::is_same_v<std::decay_t<typename span_const_f64::value_type>, f64>)
STATICINLINE void vertex_attrib_l1dv(u32 index, span_const_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL1dv)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL1dv"));
    }
    glVertexAttribL1dv(index, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_f64
>
requires (
    semantic::concepts::Vector<vec_2_f64, f64, 2>)
STATICINLINE void vertex_attrib_l2d(u32 index, vec_2_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL2d)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL2d"));
    }
    glVertexAttribL2d(index, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_f64
>
requires (
    semantic::concepts::Span<span_const_vec_2_f64> &&
    semantic::concepts::Vector<typename span_const_vec_2_f64::value_type, f64, 2>)
STATICINLINE void vertex_attrib_l2dv(u32 index, span_const_vec_2_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL2dv)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL2dv"));
    }
    glVertexAttribL2dv(index, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f64
>
requires (
    semantic::concepts::Vector<vec_3_f64, f64, 3>)
STATICINLINE void vertex_attrib_l3d(u32 index, vec_3_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL3d)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL3d"));
    }
    glVertexAttribL3d(index, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_f64
>
requires (
    semantic::concepts::Span<span_const_vec_3_f64> &&
    semantic::concepts::Vector<typename span_const_vec_3_f64::value_type, f64, 3>)
STATICINLINE void vertex_attrib_l3dv(u32 index, span_const_vec_3_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL3dv)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL3dv"));
    }
    glVertexAttribL3dv(index, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f64
>
requires (
    semantic::concepts::Vector<vec_4_f64, f64, 4>)
STATICINLINE void vertex_attrib_l4d(u32 index, vec_4_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL4d)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL4d"));
    }
    glVertexAttribL4d(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f64
>
requires (
    semantic::concepts::Span<span_const_vec_4_f64> &&
    semantic::concepts::Vector<typename span_const_vec_4_f64::value_type, f64, 4>)
STATICINLINE void vertex_attrib_l4dv(u32 index, span_const_vec_4_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL4dv)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL4dv"));
    }
    glVertexAttribL4dv(index, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void vertex_attrib_l_pointer(u32 index, groups::vertex_attrib_long type, i32 stride, span_const_byte const& pointer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribLPointer)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribLPointer"));
    }
    glVertexAttribLPointer(index, pointer.size(), static_cast<GLenum>(type), stride, reinterpret_cast<const void *>(pointer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_vertex_attrib_64bit
#endif // GL_ARB_vertex_attrib_64bit
#ifdef GL_ARB_vertex_attrib_binding
namespace arb_vertex_attrib_binding {
constexpr u32 vertex_attrib_binding = 0x82D4;
constexpr u32 vertex_attrib_relative_offset = 0x82D5;
constexpr u32 vertex_binding_divisor = 0x82D6;
constexpr u32 vertex_binding_offset = 0x82D7;
constexpr u32 vertex_binding_stride = 0x82D8;
constexpr u32 max_vertex_attrib_relative_offset = 0x82D9;
constexpr u32 max_vertex_attrib_bindings = 0x82DA;
STATICINLINE void bind_vertex_buffer(u32 bindingindex, u32 buffer, GLintptr offset, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindVertexBuffer)
                Throw(undefined_behavior(
                    "unloaded function BindVertexBuffer"));
        glIsBuffer(buffer);
    }
    glBindVertexBuffer(bindingindex, buffer, offset, stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib_binding(u32 attribindex, u32 bindingindex)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribBinding)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribBinding"));
    }
    glVertexAttribBinding(attribindex, bindingindex);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib_format(u32 attribindex, i32 size, groups::vertex_attrib_type type, bool normalized, u32 relativeoffset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribFormat)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribFormat"));
    }
    glVertexAttribFormat(attribindex, size, static_cast<GLenum>(type), normalized, relativeoffset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib_i_format(u32 attribindex, i32 size, groups::vertex_attrib_int type, u32 relativeoffset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribIFormat)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribIFormat"));
    }
    glVertexAttribIFormat(attribindex, size, static_cast<GLenum>(type), relativeoffset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib_l_format(u32 attribindex, i32 size, groups::vertex_attrib_long type, u32 relativeoffset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribLFormat)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribLFormat"));
    }
    glVertexAttribLFormat(attribindex, size, static_cast<GLenum>(type), relativeoffset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_binding_divisor(u32 bindingindex, u32 divisor)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexBindingDivisor)
                Throw(undefined_behavior(
                    "unloaded function VertexBindingDivisor"));
    }
    glVertexBindingDivisor(bindingindex, divisor);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_vertex_attrib_binding
#endif // GL_ARB_vertex_attrib_binding
#ifdef GL_ARB_vertex_blend
namespace arb_vertex_blend {
constexpr u32 modelview0_arb = 0x1700;
constexpr u32 modelview1_arb = 0x850A;
constexpr u32 max_vertex_units_arb = 0x86A4;
constexpr u32 active_vertex_units_arb = 0x86A5;
constexpr u32 weight_sum_unity_arb = 0x86A6;
constexpr u32 vertex_blend_arb = 0x86A7;
constexpr u32 current_weight_arb = 0x86A8;
constexpr u32 weight_array_type_arb = 0x86A9;
constexpr u32 weight_array_stride_arb = 0x86AA;
constexpr u32 weight_array_size_arb = 0x86AB;
constexpr u32 weight_array_pointer_arb = 0x86AC;
constexpr u32 weight_array_arb = 0x86AD;
constexpr u32 modelview2_arb = 0x8722;
constexpr u32 modelview3_arb = 0x8723;
constexpr u32 modelview4_arb = 0x8724;
constexpr u32 modelview5_arb = 0x8725;
constexpr u32 modelview6_arb = 0x8726;
constexpr u32 modelview7_arb = 0x8727;
constexpr u32 modelview8_arb = 0x8728;
constexpr u32 modelview9_arb = 0x8729;
constexpr u32 modelview10_arb = 0x872A;
constexpr u32 modelview11_arb = 0x872B;
constexpr u32 modelview12_arb = 0x872C;
constexpr u32 modelview13_arb = 0x872D;
constexpr u32 modelview14_arb = 0x872E;
constexpr u32 modelview15_arb = 0x872F;
constexpr u32 modelview16_arb = 0x8730;
constexpr u32 modelview17_arb = 0x8731;
constexpr u32 modelview18_arb = 0x8732;
constexpr u32 modelview19_arb = 0x8733;
constexpr u32 modelview20_arb = 0x8734;
constexpr u32 modelview21_arb = 0x8735;
constexpr u32 modelview22_arb = 0x8736;
constexpr u32 modelview23_arb = 0x8737;
constexpr u32 modelview24_arb = 0x8738;
constexpr u32 modelview25_arb = 0x8739;
constexpr u32 modelview26_arb = 0x873A;
constexpr u32 modelview27_arb = 0x873B;
constexpr u32 modelview28_arb = 0x873C;
constexpr u32 modelview29_arb = 0x873D;
constexpr u32 modelview30_arb = 0x873E;
constexpr u32 modelview31_arb = 0x873F;
STATICINLINE void vertex_blend_arb(i32 count)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexBlendARB)
                Throw(undefined_behavior(
                    "unloaded function VertexBlendARB"));
    }
    glVertexBlendARB(count);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void weight_pointer_arb(i32 size, groups::weight_pointer_type_arb type, i32 stride, span_const_byte const& pointer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWeightPointerARB)
                Throw(undefined_behavior(
                    "unloaded function WeightPointerARB"));
    }
    glWeightPointerARB(size, static_cast<GLenum>(type), stride, reinterpret_cast<const void *>(pointer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i8
>
requires (
    semantic::concepts::Span<span_const_i8> &&
    std::is_same_v<std::decay_t<typename span_const_i8::value_type>, i8>)
STATICINLINE void weightbv_arb(span_const_i8 const& weights)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWeightbvARB)
                Throw(undefined_behavior(
                    "unloaded function WeightbvARB"));
    }
    glWeightbvARB(weights.size(), reinterpret_cast<const GLbyte *>(weights.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f64
>
requires (
    semantic::concepts::Span<span_const_f64> &&
    std::is_same_v<std::decay_t<typename span_const_f64::value_type>, f64>)
STATICINLINE void weightdv_arb(span_const_f64 const& weights)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWeightdvARB)
                Throw(undefined_behavior(
                    "unloaded function WeightdvARB"));
    }
    glWeightdvARB(weights.size(), reinterpret_cast<const GLdouble *>(weights.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void weightfv_arb(span_const_f32 const& weights)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWeightfvARB)
                Throw(undefined_behavior(
                    "unloaded function WeightfvARB"));
    }
    glWeightfvARB(weights.size(), reinterpret_cast<const GLfloat *>(weights.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void weightiv_arb(span_const_i32 const& weights)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWeightivARB)
                Throw(undefined_behavior(
                    "unloaded function WeightivARB"));
    }
    glWeightivARB(weights.size(), reinterpret_cast<const GLint *>(weights.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i16
>
requires (
    semantic::concepts::Span<span_const_i16> &&
    std::is_same_v<std::decay_t<typename span_const_i16::value_type>, i16>)
STATICINLINE void weightsv_arb(span_const_i16 const& weights)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWeightsvARB)
                Throw(undefined_behavior(
                    "unloaded function WeightsvARB"));
    }
    glWeightsvARB(weights.size(), reinterpret_cast<const GLshort *>(weights.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u8
>
requires (
    semantic::concepts::Span<span_const_u8> &&
    std::is_same_v<std::decay_t<typename span_const_u8::value_type>, u8>)
STATICINLINE void weightubv_arb(span_const_u8 const& weights)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWeightubvARB)
                Throw(undefined_behavior(
                    "unloaded function WeightubvARB"));
    }
    glWeightubvARB(weights.size(), reinterpret_cast<const GLubyte *>(weights.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void weightuiv_arb(span_const_u32 const& weights)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWeightuivARB)
                Throw(undefined_behavior(
                    "unloaded function WeightuivARB"));
    }
    glWeightuivARB(weights.size(), reinterpret_cast<const GLuint *>(weights.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u16
>
requires (
    semantic::concepts::Span<span_const_u16> &&
    std::is_same_v<std::decay_t<typename span_const_u16::value_type>, u16>)
STATICINLINE void weightusv_arb(span_const_u16 const& weights)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWeightusvARB)
                Throw(undefined_behavior(
                    "unloaded function WeightusvARB"));
    }
    glWeightusvARB(weights.size(), reinterpret_cast<const GLushort *>(weights.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_vertex_blend
#endif // GL_ARB_vertex_blend
#ifdef GL_ARB_vertex_buffer_object
namespace arb_vertex_buffer_object {
constexpr u32 buffer_size_arb = 0x8764;
constexpr u32 buffer_usage_arb = 0x8765;
constexpr u32 array_buffer_arb = 0x8892;
constexpr u32 element_array_buffer_arb = 0x8893;
constexpr u32 array_buffer_binding_arb = 0x8894;
constexpr u32 element_array_buffer_binding_arb = 0x8895;
constexpr u32 vertex_array_buffer_binding_arb = 0x8896;
constexpr u32 normal_array_buffer_binding_arb = 0x8897;
constexpr u32 color_array_buffer_binding_arb = 0x8898;
constexpr u32 index_array_buffer_binding_arb = 0x8899;
constexpr u32 texture_coord_array_buffer_binding_arb = 0x889A;
constexpr u32 edge_flag_array_buffer_binding_arb = 0x889B;
constexpr u32 secondary_color_array_buffer_binding_arb = 0x889C;
constexpr u32 fog_coordinate_array_buffer_binding_arb = 0x889D;
constexpr u32 weight_array_buffer_binding_arb = 0x889E;
constexpr u32 vertex_attrib_array_buffer_binding_arb = 0x889F;
constexpr u32 read_only_arb = 0x88B8;
constexpr u32 write_only_arb = 0x88B9;
constexpr u32 read_write_arb = 0x88BA;
constexpr u32 buffer_access_arb = 0x88BB;
constexpr u32 buffer_mapped_arb = 0x88BC;
constexpr u32 buffer_map_pointer_arb = 0x88BD;
constexpr u32 stream_draw_arb = 0x88E0;
constexpr u32 stream_read_arb = 0x88E1;
constexpr u32 stream_copy_arb = 0x88E2;
constexpr u32 static_draw_arb = 0x88E4;
constexpr u32 static_read_arb = 0x88E5;
constexpr u32 static_copy_arb = 0x88E6;
constexpr u32 dynamic_draw_arb = 0x88E8;
constexpr u32 dynamic_read_arb = 0x88E9;
constexpr u32 dynamic_copy_arb = 0x88EA;
STATICINLINE void bind_buffer_arb(groups::buffer_target_arb target, u32 buffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindBufferARB)
                Throw(undefined_behavior(
                    "unloaded function BindBufferARB"));
        glIsBuffer(buffer);
    }
    glBindBufferARB(static_cast<GLenum>(target), buffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void buffer_data_arb(groups::buffer_target_arb target, span_const_byte const& data, groups::buffer_usage_arb usage)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBufferDataARB)
                Throw(undefined_behavior(
                    "unloaded function BufferDataARB"));
    }
    glBufferDataARB(static_cast<GLenum>(target), data.size(), reinterpret_cast<const void *>(data.data()), static_cast<GLenum>(usage));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void buffer_sub_data_arb(groups::buffer_target_arb target, GLintptrARB offset, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBufferSubDataARB)
                Throw(undefined_behavior(
                    "unloaded function BufferSubDataARB"));
    }
    glBufferSubDataARB(static_cast<GLenum>(target), offset, data.size(), reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_buffers_arb(span_const_u32 const& buffers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteBuffersARB)
                Throw(undefined_behavior(
                    "unloaded function DeleteBuffersARB"));
    }
    glDeleteBuffersARB(buffers.size(), reinterpret_cast<const GLuint *>(buffers.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void gen_buffers_arb(span_u32 buffers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenBuffersARB)
                Throw(undefined_behavior(
                    "unloaded function GenBuffersARB"));
    }
    glGenBuffersARB(buffers.size(), reinterpret_cast<GLuint *>(buffers.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_buffer_parameteriv_arb(groups::buffer_target_arb target, groups::buffer_prop_arb pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetBufferParameterivARB)
                Throw(undefined_behavior(
                    "unloaded function GetBufferParameterivARB"));
    }
    glGetBufferParameterivARB(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_buffer_pointerv_arb(groups::buffer_target_arb target, groups::buffer_pointer_name_arb pname, span_byte params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetBufferPointervARB)
                Throw(undefined_behavior(
                    "unloaded function GetBufferPointervARB"));
    }
    glGetBufferPointervARB(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<void **>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_buffer_sub_data_arb(groups::buffer_target_arb target, GLintptrARB offset, span_byte data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetBufferSubDataARB)
                Throw(undefined_behavior(
                    "unloaded function GetBufferSubDataARB"));
    }
    glGetBufferSubDataARB(static_cast<GLenum>(target), offset, data.size(), reinterpret_cast<void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_buffer_arb(u32 buffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsBufferARB)
                Throw(undefined_behavior(
                    "unloaded function IsBufferARB"));
        glIsBuffer(buffer);
    }
    auto out = glIsBufferARB(buffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void * map_buffer_arb(groups::buffer_target_arb target, groups::buffer_access_arb access)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMapBufferARB)
                Throw(undefined_behavior(
                    "unloaded function MapBufferARB"));
    }
    auto out = glMapBufferARB(static_cast<GLenum>(target), static_cast<GLenum>(access));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLboolean unmap_buffer_arb(groups::buffer_target_arb target)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUnmapBufferARB)
                Throw(undefined_behavior(
                    "unloaded function UnmapBufferARB"));
    }
    auto out = glUnmapBufferARB(static_cast<GLenum>(target));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // arb_vertex_buffer_object
#endif // GL_ARB_vertex_buffer_object
#ifdef GL_ARB_vertex_program
namespace arb_vertex_program {
constexpr u32 color_sum_arb = 0x8458;
constexpr u32 vertex_program_arb = 0x8620;
constexpr u32 vertex_attrib_array_enabled_arb = 0x8622;
constexpr u32 vertex_attrib_array_size_arb = 0x8623;
constexpr u32 vertex_attrib_array_stride_arb = 0x8624;
constexpr u32 vertex_attrib_array_type_arb = 0x8625;
constexpr u32 current_vertex_attrib_arb = 0x8626;
constexpr u32 program_length_arb = 0x8627;
constexpr u32 program_string_arb = 0x8628;
constexpr u32 max_program_matrix_stack_depth_arb = 0x862E;
constexpr u32 max_program_matrices_arb = 0x862F;
constexpr u32 current_matrix_stack_depth_arb = 0x8640;
constexpr u32 current_matrix_arb = 0x8641;
constexpr u32 vertex_program_point_size_arb = 0x8642;
constexpr u32 vertex_program_two_side_arb = 0x8643;
constexpr u32 vertex_attrib_array_pointer_arb = 0x8645;
constexpr u32 program_error_position_arb = 0x864B;
constexpr u32 program_binding_arb = 0x8677;
constexpr u32 max_vertex_attribs_arb = 0x8869;
constexpr u32 vertex_attrib_array_normalized_arb = 0x886A;
constexpr u32 program_error_string_arb = 0x8874;
constexpr u32 program_format_ascii_arb = 0x8875;
constexpr u32 program_format_arb = 0x8876;
constexpr u32 program_instructions_arb = 0x88A0;
constexpr u32 max_program_instructions_arb = 0x88A1;
constexpr u32 program_native_instructions_arb = 0x88A2;
constexpr u32 max_program_native_instructions_arb = 0x88A3;
constexpr u32 program_temporaries_arb = 0x88A4;
constexpr u32 max_program_temporaries_arb = 0x88A5;
constexpr u32 program_native_temporaries_arb = 0x88A6;
constexpr u32 max_program_native_temporaries_arb = 0x88A7;
constexpr u32 program_parameters_arb = 0x88A8;
constexpr u32 max_program_parameters_arb = 0x88A9;
constexpr u32 program_native_parameters_arb = 0x88AA;
constexpr u32 max_program_native_parameters_arb = 0x88AB;
constexpr u32 program_attribs_arb = 0x88AC;
constexpr u32 max_program_attribs_arb = 0x88AD;
constexpr u32 program_native_attribs_arb = 0x88AE;
constexpr u32 max_program_native_attribs_arb = 0x88AF;
constexpr u32 program_address_registers_arb = 0x88B0;
constexpr u32 max_program_address_registers_arb = 0x88B1;
constexpr u32 program_native_address_registers_arb = 0x88B2;
constexpr u32 max_program_native_address_registers_arb = 0x88B3;
constexpr u32 max_program_local_parameters_arb = 0x88B4;
constexpr u32 max_program_env_parameters_arb = 0x88B5;
constexpr u32 program_under_native_limits_arb = 0x88B6;
constexpr u32 transpose_current_matrix_arb = 0x88B7;
constexpr u32 matrix0_arb = 0x88C0;
constexpr u32 matrix1_arb = 0x88C1;
constexpr u32 matrix2_arb = 0x88C2;
constexpr u32 matrix3_arb = 0x88C3;
constexpr u32 matrix4_arb = 0x88C4;
constexpr u32 matrix5_arb = 0x88C5;
constexpr u32 matrix6_arb = 0x88C6;
constexpr u32 matrix7_arb = 0x88C7;
constexpr u32 matrix8_arb = 0x88C8;
constexpr u32 matrix9_arb = 0x88C9;
constexpr u32 matrix10_arb = 0x88CA;
constexpr u32 matrix11_arb = 0x88CB;
constexpr u32 matrix12_arb = 0x88CC;
constexpr u32 matrix13_arb = 0x88CD;
constexpr u32 matrix14_arb = 0x88CE;
constexpr u32 matrix15_arb = 0x88CF;
constexpr u32 matrix16_arb = 0x88D0;
constexpr u32 matrix17_arb = 0x88D1;
constexpr u32 matrix18_arb = 0x88D2;
constexpr u32 matrix19_arb = 0x88D3;
constexpr u32 matrix20_arb = 0x88D4;
constexpr u32 matrix21_arb = 0x88D5;
constexpr u32 matrix22_arb = 0x88D6;
constexpr u32 matrix23_arb = 0x88D7;
constexpr u32 matrix24_arb = 0x88D8;
constexpr u32 matrix25_arb = 0x88D9;
constexpr u32 matrix26_arb = 0x88DA;
constexpr u32 matrix27_arb = 0x88DB;
constexpr u32 matrix28_arb = 0x88DC;
constexpr u32 matrix29_arb = 0x88DD;
constexpr u32 matrix30_arb = 0x88DE;
constexpr u32 matrix31_arb = 0x88DF;
STATICINLINE void bind_program_arb(groups::program_target target, u32 program)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindProgramARB)
                Throw(undefined_behavior(
                    "unloaded function BindProgramARB"));
        glIsProgram(program);
    }
    glBindProgramARB(static_cast<GLenum>(target), program);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_programs_arb(span_const_u32 const& programs)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteProgramsARB)
                Throw(undefined_behavior(
                    "unloaded function DeleteProgramsARB"));
    }
    glDeleteProgramsARB(programs.size(), reinterpret_cast<const GLuint *>(programs.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void disable_vertex_attrib_array_arb(u32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDisableVertexAttribArrayARB)
                Throw(undefined_behavior(
                    "unloaded function DisableVertexAttribArrayARB"));
    }
    glDisableVertexAttribArrayARB(index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void enable_vertex_attrib_array_arb(u32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEnableVertexAttribArrayARB)
                Throw(undefined_behavior(
                    "unloaded function EnableVertexAttribArrayARB"));
    }
    glEnableVertexAttribArrayARB(index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void gen_programs_arb(span_u32 programs)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenProgramsARB)
                Throw(undefined_behavior(
                    "unloaded function GenProgramsARB"));
    }
    glGenProgramsARB(programs.size(), reinterpret_cast<GLuint *>(programs.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f64
>
requires (
    semantic::concepts::Span<span_f64> &&
    std::is_same_v<std::decay_t<typename span_f64::value_type>, f64>)
STATICINLINE void get_program_env_parameterdv_arb(groups::program_target target, u32 index, span_f64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramEnvParameterdvARB)
                Throw(undefined_behavior(
                    "unloaded function GetProgramEnvParameterdvARB"));
    }
    glGetProgramEnvParameterdvARB(static_cast<GLenum>(target), index, reinterpret_cast<GLdouble *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_program_env_parameterfv_arb(groups::program_target target, u32 index, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramEnvParameterfvARB)
                Throw(undefined_behavior(
                    "unloaded function GetProgramEnvParameterfvARB"));
    }
    glGetProgramEnvParameterfvARB(static_cast<GLenum>(target), index, reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f64
>
requires (
    semantic::concepts::Span<span_f64> &&
    std::is_same_v<std::decay_t<typename span_f64::value_type>, f64>)
STATICINLINE void get_program_local_parameterdv_arb(groups::program_target target, u32 index, span_f64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramLocalParameterdvARB)
                Throw(undefined_behavior(
                    "unloaded function GetProgramLocalParameterdvARB"));
    }
    glGetProgramLocalParameterdvARB(static_cast<GLenum>(target), index, reinterpret_cast<GLdouble *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_program_local_parameterfv_arb(groups::program_target target, u32 index, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramLocalParameterfvARB)
                Throw(undefined_behavior(
                    "unloaded function GetProgramLocalParameterfvARB"));
    }
    glGetProgramLocalParameterfvARB(static_cast<GLenum>(target), index, reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_program_string_arb(groups::program_target target, groups::program_string_property pname, span_byte string)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramStringARB)
                Throw(undefined_behavior(
                    "unloaded function GetProgramStringARB"));
    }
    glGetProgramStringARB(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<void *>(string.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void get_programiv_arb(groups::program_target target, groups::program_property_arb pname, i32& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramivARB)
                Throw(undefined_behavior(
                    "unloaded function GetProgramivARB"));
    }
    glGetProgramivARB(static_cast<GLenum>(target), static_cast<GLenum>(pname), &params);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_vertex_attrib_pointerv_arb(u32 index, groups::vertex_attrib_pointer_property_arb pname, span_byte pointer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribPointervARB)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribPointervARB"));
    }
    glGetVertexAttribPointervARB(index, static_cast<GLenum>(pname), reinterpret_cast<void **>(pointer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f64
>
requires (
    semantic::concepts::Span<span_f64> &&
    std::is_same_v<std::decay_t<typename span_f64::value_type>, f64>)
STATICINLINE void get_vertex_attribdv_arb(u32 index, groups::vertex_attrib_property_arb pname, span_f64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribdvARB)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribdvARB"));
    }
    glGetVertexAttribdvARB(index, static_cast<GLenum>(pname), reinterpret_cast<GLdouble *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_vertex_attribfv_arb(u32 index, groups::vertex_attrib_property_arb pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribfvARB)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribfvARB"));
    }
    glGetVertexAttribfvARB(index, static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_vertex_attribiv_arb(u32 index, groups::vertex_attrib_property_arb pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribivARB)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribivARB"));
    }
    glGetVertexAttribivARB(index, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_program_arb(u32 program)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsProgramARB)
                Throw(undefined_behavior(
                    "unloaded function IsProgramARB"));
        glIsProgram(program);
    }
    auto out = glIsProgramARB(program);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class vec_4_f64
>
requires (
    semantic::concepts::Vector<vec_4_f64, f64, 4>)
STATICINLINE void program_env_parameter4d_arb(groups::program_target target, u32 index, vec_4_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramEnvParameter4dARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramEnvParameter4dARB"));
    }
    glProgramEnvParameter4dARB(static_cast<GLenum>(target), index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f64
>
requires (
    semantic::concepts::Span<span_const_vec_4_f64> &&
    semantic::concepts::Vector<typename span_const_vec_4_f64::value_type, f64, 4>)
STATICINLINE void program_env_parameter4dv_arb(groups::program_target target, u32 index, span_const_vec_4_f64 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramEnvParameter4dvARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramEnvParameter4dvARB"));
    }
    glProgramEnvParameter4dvARB(static_cast<GLenum>(target), index, reinterpret_cast<const GLdouble *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f32
>
requires (
    semantic::concepts::Vector<vec_4_f32, f32, 4>)
STATICINLINE void program_env_parameter4f_arb(groups::program_target target, u32 index, vec_4_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramEnvParameter4fARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramEnvParameter4fARB"));
    }
    glProgramEnvParameter4fARB(static_cast<GLenum>(target), index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f32
>
requires (
    semantic::concepts::Span<span_const_vec_4_f32> &&
    semantic::concepts::Vector<typename span_const_vec_4_f32::value_type, f32, 4>)
STATICINLINE void program_env_parameter4fv_arb(groups::program_target target, u32 index, span_const_vec_4_f32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramEnvParameter4fvARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramEnvParameter4fvARB"));
    }
    glProgramEnvParameter4fvARB(static_cast<GLenum>(target), index, reinterpret_cast<const GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f64
>
requires (
    semantic::concepts::Vector<vec_4_f64, f64, 4>)
STATICINLINE void program_local_parameter4d_arb(groups::program_target target, u32 index, vec_4_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramLocalParameter4dARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramLocalParameter4dARB"));
    }
    glProgramLocalParameter4dARB(static_cast<GLenum>(target), index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f64
>
requires (
    semantic::concepts::Span<span_const_vec_4_f64> &&
    semantic::concepts::Vector<typename span_const_vec_4_f64::value_type, f64, 4>)
STATICINLINE void program_local_parameter4dv_arb(groups::program_target target, u32 index, span_const_vec_4_f64 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramLocalParameter4dvARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramLocalParameter4dvARB"));
    }
    glProgramLocalParameter4dvARB(static_cast<GLenum>(target), index, reinterpret_cast<const GLdouble *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f32
>
requires (
    semantic::concepts::Vector<vec_4_f32, f32, 4>)
STATICINLINE void program_local_parameter4f_arb(groups::program_target target, u32 index, vec_4_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramLocalParameter4fARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramLocalParameter4fARB"));
    }
    glProgramLocalParameter4fARB(static_cast<GLenum>(target), index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f32
>
requires (
    semantic::concepts::Span<span_const_vec_4_f32> &&
    semantic::concepts::Vector<typename span_const_vec_4_f32::value_type, f32, 4>)
STATICINLINE void program_local_parameter4fv_arb(groups::program_target target, u32 index, span_const_vec_4_f32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramLocalParameter4fvARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramLocalParameter4fvARB"));
    }
    glProgramLocalParameter4fvARB(static_cast<GLenum>(target), index, reinterpret_cast<const GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void program_string_arb(groups::program_target target, groups::program_format format, span_const_byte const& string)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramStringARB)
                Throw(undefined_behavior(
                    "unloaded function ProgramStringARB"));
    }
    glProgramStringARB(static_cast<GLenum>(target), static_cast<GLenum>(format), string.size(), reinterpret_cast<const void *>(string.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib1d_arb(u32 index, f64 x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1dARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1dARB"));
    }
    glVertexAttrib1dARB(index, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f64
>
requires (
    semantic::concepts::Span<span_const_f64> &&
    std::is_same_v<std::decay_t<typename span_const_f64::value_type>, f64>)
STATICINLINE void vertex_attrib1dv_arb(u32 index, span_const_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1dvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1dvARB"));
    }
    glVertexAttrib1dvARB(index, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib1f_arb(u32 index, f32 x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1fARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1fARB"));
    }
    glVertexAttrib1fARB(index, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void vertex_attrib1fv_arb(u32 index, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1fvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1fvARB"));
    }
    glVertexAttrib1fvARB(index, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib1s_arb(u32 index, i16 x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1sARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1sARB"));
    }
    glVertexAttrib1sARB(index, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i16
>
requires (
    semantic::concepts::Span<span_const_i16> &&
    std::is_same_v<std::decay_t<typename span_const_i16::value_type>, i16>)
STATICINLINE void vertex_attrib1sv_arb(u32 index, span_const_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1svARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1svARB"));
    }
    glVertexAttrib1svARB(index, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_f64
>
requires (
    semantic::concepts::Vector<vec_2_f64, f64, 2>)
STATICINLINE void vertex_attrib2d_arb(u32 index, vec_2_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2dARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2dARB"));
    }
    glVertexAttrib2dARB(index, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_f64
>
requires (
    semantic::concepts::Span<span_const_vec_2_f64> &&
    semantic::concepts::Vector<typename span_const_vec_2_f64::value_type, f64, 2>)
STATICINLINE void vertex_attrib2dv_arb(u32 index, span_const_vec_2_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2dvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2dvARB"));
    }
    glVertexAttrib2dvARB(index, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_f32
>
requires (
    semantic::concepts::Vector<vec_2_f32, f32, 2>)
STATICINLINE void vertex_attrib2f_arb(u32 index, vec_2_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2fARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2fARB"));
    }
    glVertexAttrib2fARB(index, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_f32
>
requires (
    semantic::concepts::Span<span_const_vec_2_f32> &&
    semantic::concepts::Vector<typename span_const_vec_2_f32::value_type, f32, 2>)
STATICINLINE void vertex_attrib2fv_arb(u32 index, span_const_vec_2_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2fvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2fvARB"));
    }
    glVertexAttrib2fvARB(index, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i16
>
requires (
    semantic::concepts::Vector<vec_2_i16, i16, 2>)
STATICINLINE void vertex_attrib2s_arb(u32 index, vec_2_i16 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2sARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2sARB"));
    }
    glVertexAttrib2sARB(index, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_i16
>
requires (
    semantic::concepts::Span<span_const_vec_2_i16> &&
    semantic::concepts::Vector<typename span_const_vec_2_i16::value_type, i16, 2>)
STATICINLINE void vertex_attrib2sv_arb(u32 index, span_const_vec_2_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2svARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2svARB"));
    }
    glVertexAttrib2svARB(index, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f64
>
requires (
    semantic::concepts::Vector<vec_3_f64, f64, 3>)
STATICINLINE void vertex_attrib3d_arb(u32 index, vec_3_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3dARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3dARB"));
    }
    glVertexAttrib3dARB(index, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_f64
>
requires (
    semantic::concepts::Span<span_const_vec_3_f64> &&
    semantic::concepts::Vector<typename span_const_vec_3_f64::value_type, f64, 3>)
STATICINLINE void vertex_attrib3dv_arb(u32 index, span_const_vec_3_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3dvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3dvARB"));
    }
    glVertexAttrib3dvARB(index, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f32
>
requires (
    semantic::concepts::Vector<vec_3_f32, f32, 3>)
STATICINLINE void vertex_attrib3f_arb(u32 index, vec_3_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3fARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3fARB"));
    }
    glVertexAttrib3fARB(index, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_f32
>
requires (
    semantic::concepts::Span<span_const_vec_3_f32> &&
    semantic::concepts::Vector<typename span_const_vec_3_f32::value_type, f32, 3>)
STATICINLINE void vertex_attrib3fv_arb(u32 index, span_const_vec_3_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3fvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3fvARB"));
    }
    glVertexAttrib3fvARB(index, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i16
>
requires (
    semantic::concepts::Vector<vec_3_i16, i16, 3>)
STATICINLINE void vertex_attrib3s_arb(u32 index, vec_3_i16 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3sARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3sARB"));
    }
    glVertexAttrib3sARB(index, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_i16
>
requires (
    semantic::concepts::Span<span_const_vec_3_i16> &&
    semantic::concepts::Vector<typename span_const_vec_3_i16::value_type, i16, 3>)
STATICINLINE void vertex_attrib3sv_arb(u32 index, span_const_vec_3_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3svARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3svARB"));
    }
    glVertexAttrib3svARB(index, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i8
>
requires (
    semantic::concepts::Span<span_const_i8> &&
    std::is_same_v<std::decay_t<typename span_const_i8::value_type>, i8>)
STATICINLINE void vertex_attrib4_nbv_arb(u32 index, span_const_i8 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4NbvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4NbvARB"));
    }
    glVertexAttrib4NbvARB(index, reinterpret_cast<const GLbyte *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void vertex_attrib4_niv_arb(u32 index, span_const_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4NivARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4NivARB"));
    }
    glVertexAttrib4NivARB(index, reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i16
>
requires (
    semantic::concepts::Span<span_const_i16> &&
    std::is_same_v<std::decay_t<typename span_const_i16::value_type>, i16>)
STATICINLINE void vertex_attrib4_nsv_arb(u32 index, span_const_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4NsvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4NsvARB"));
    }
    glVertexAttrib4NsvARB(index, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_u8
>
requires (
    semantic::concepts::Vector<vec_4_u8, u8, 4>)
STATICINLINE void vertex_attrib4_nub_arb(u32 index, vec_4_u8 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4NubARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4NubARB"));
    }
    glVertexAttrib4NubARB(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u8
>
requires (
    semantic::concepts::Span<span_const_u8> &&
    std::is_same_v<std::decay_t<typename span_const_u8::value_type>, u8>)
STATICINLINE void vertex_attrib4_nubv_arb(u32 index, span_const_u8 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4NubvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4NubvARB"));
    }
    glVertexAttrib4NubvARB(index, reinterpret_cast<const GLubyte *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void vertex_attrib4_nuiv_arb(u32 index, span_const_u32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4NuivARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4NuivARB"));
    }
    glVertexAttrib4NuivARB(index, reinterpret_cast<const GLuint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u16
>
requires (
    semantic::concepts::Span<span_const_u16> &&
    std::is_same_v<std::decay_t<typename span_const_u16::value_type>, u16>)
STATICINLINE void vertex_attrib4_nusv_arb(u32 index, span_const_u16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4NusvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4NusvARB"));
    }
    glVertexAttrib4NusvARB(index, reinterpret_cast<const GLushort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i8
>
requires (
    semantic::concepts::Span<span_const_i8> &&
    std::is_same_v<std::decay_t<typename span_const_i8::value_type>, i8>)
STATICINLINE void vertex_attrib4bv_arb(u32 index, span_const_i8 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4bvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4bvARB"));
    }
    glVertexAttrib4bvARB(index, reinterpret_cast<const GLbyte *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f64
>
requires (
    semantic::concepts::Vector<vec_4_f64, f64, 4>)
STATICINLINE void vertex_attrib4d_arb(u32 index, vec_4_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4dARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4dARB"));
    }
    glVertexAttrib4dARB(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f64
>
requires (
    semantic::concepts::Span<span_const_vec_4_f64> &&
    semantic::concepts::Vector<typename span_const_vec_4_f64::value_type, f64, 4>)
STATICINLINE void vertex_attrib4dv_arb(u32 index, span_const_vec_4_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4dvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4dvARB"));
    }
    glVertexAttrib4dvARB(index, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f32
>
requires (
    semantic::concepts::Vector<vec_4_f32, f32, 4>)
STATICINLINE void vertex_attrib4f_arb(u32 index, vec_4_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4fARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4fARB"));
    }
    glVertexAttrib4fARB(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f32
>
requires (
    semantic::concepts::Span<span_const_vec_4_f32> &&
    semantic::concepts::Vector<typename span_const_vec_4_f32::value_type, f32, 4>)
STATICINLINE void vertex_attrib4fv_arb(u32 index, span_const_vec_4_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4fvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4fvARB"));
    }
    glVertexAttrib4fvARB(index, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_i32
>
requires (
    semantic::concepts::Span<span_const_vec_4_i32> &&
    semantic::concepts::Vector<typename span_const_vec_4_i32::value_type, i32, 4>)
STATICINLINE void vertex_attrib4iv_arb(u32 index, span_const_vec_4_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4ivARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4ivARB"));
    }
    glVertexAttrib4ivARB(index, reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_i16
>
requires (
    semantic::concepts::Vector<vec_4_i16, i16, 4>)
STATICINLINE void vertex_attrib4s_arb(u32 index, vec_4_i16 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4sARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4sARB"));
    }
    glVertexAttrib4sARB(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_i16
>
requires (
    semantic::concepts::Span<span_const_vec_4_i16> &&
    semantic::concepts::Vector<typename span_const_vec_4_i16::value_type, i16, 4>)
STATICINLINE void vertex_attrib4sv_arb(u32 index, span_const_vec_4_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4svARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4svARB"));
    }
    glVertexAttrib4svARB(index, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u8
>
requires (
    semantic::concepts::Span<span_const_u8> &&
    std::is_same_v<std::decay_t<typename span_const_u8::value_type>, u8>)
STATICINLINE void vertex_attrib4ubv_arb(u32 index, span_const_u8 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4ubvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4ubvARB"));
    }
    glVertexAttrib4ubvARB(index, reinterpret_cast<const GLubyte *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u32
>
requires (
    semantic::concepts::Span<span_const_vec_4_u32> &&
    semantic::concepts::Vector<typename span_const_vec_4_u32::value_type, u32, 4>)
STATICINLINE void vertex_attrib4uiv_arb(u32 index, span_const_vec_4_u32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4uivARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4uivARB"));
    }
    glVertexAttrib4uivARB(index, reinterpret_cast<const GLuint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u16
>
requires (
    semantic::concepts::Span<span_const_vec_4_u16> &&
    semantic::concepts::Vector<typename span_const_vec_4_u16::value_type, u16, 4>)
STATICINLINE void vertex_attrib4usv_arb(u32 index, span_const_vec_4_u16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4usvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4usvARB"));
    }
    glVertexAttrib4usvARB(index, reinterpret_cast<const GLushort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void vertex_attrib_pointer_arb(u32 index, i32 size, groups::vertex_attrib_pointer_type type, bool normalized, i32 stride, span_const_byte const& pointer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribPointerARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribPointerARB"));
    }
    glVertexAttribPointerARB(index, size, static_cast<GLenum>(type), normalized, stride, reinterpret_cast<const void *>(pointer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_vertex_program
#endif // GL_ARB_vertex_program
#ifdef GL_ARB_vertex_shader
namespace arb_vertex_shader {
constexpr u32 float = 0x1406;
constexpr u32 vertex_attrib_array_enabled_arb = 0x8622;
constexpr u32 vertex_attrib_array_size_arb = 0x8623;
constexpr u32 vertex_attrib_array_stride_arb = 0x8624;
constexpr u32 vertex_attrib_array_type_arb = 0x8625;
constexpr u32 current_vertex_attrib_arb = 0x8626;
constexpr u32 vertex_program_point_size_arb = 0x8642;
constexpr u32 vertex_program_two_side_arb = 0x8643;
constexpr u32 vertex_attrib_array_pointer_arb = 0x8645;
constexpr u32 max_vertex_attribs_arb = 0x8869;
constexpr u32 vertex_attrib_array_normalized_arb = 0x886A;
constexpr u32 max_texture_coords_arb = 0x8871;
constexpr u32 max_texture_image_units_arb = 0x8872;
constexpr u32 vertex_shader_arb = 0x8B31;
constexpr u32 max_vertex_uniform_components_arb = 0x8B4A;
constexpr u32 max_varying_floats_arb = 0x8B4B;
constexpr u32 max_vertex_texture_image_units_arb = 0x8B4C;
constexpr u32 max_combined_texture_image_units_arb = 0x8B4D;
constexpr u32 float_vec2_arb = 0x8B50;
constexpr u32 float_vec3_arb = 0x8B51;
constexpr u32 float_vec4_arb = 0x8B52;
constexpr u32 float_mat2_arb = 0x8B5A;
constexpr u32 float_mat3_arb = 0x8B5B;
constexpr u32 float_mat4_arb = 0x8B5C;
constexpr u32 object_active_attributes_arb = 0x8B89;
constexpr u32 object_active_attribute_max_length_arb = 0x8B8A;
template<
    class span_const_GLcharARB
>
requires (
    semantic::concepts::Span<span_const_GLcharARB> &&
    std::is_same_v<std::decay_t<typename span_const_GLcharARB::value_type>, GLcharARB>)
STATICINLINE void bind_attrib_location_arb(GLhandleARB programObj, u32 index, span_const_GLcharARB const& name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindAttribLocationARB)
                Throw(undefined_behavior(
                    "unloaded function BindAttribLocationARB"));
    }
    glBindAttribLocationARB(programObj, index, reinterpret_cast<const GLcharARB *>(name.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void disable_vertex_attrib_array_arb(u32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDisableVertexAttribArrayARB)
                Throw(undefined_behavior(
                    "unloaded function DisableVertexAttribArrayARB"));
    }
    glDisableVertexAttribArrayARB(index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void enable_vertex_attrib_array_arb(u32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEnableVertexAttribArrayARB)
                Throw(undefined_behavior(
                    "unloaded function EnableVertexAttribArrayARB"));
    }
    glEnableVertexAttribArrayARB(index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLcharARB
>
requires (
    semantic::concepts::Span<span_GLcharARB> &&
    std::is_same_v<std::decay_t<typename span_GLcharARB::value_type>, GLcharARB>)
STATICINLINE void get_active_attrib_arb(GLhandleARB programObj, u32 index, i32& length, i32& size, GLenum& type, span_GLcharARB name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetActiveAttribARB)
                Throw(undefined_behavior(
                    "unloaded function GetActiveAttribARB"));
    }
    glGetActiveAttribARB(programObj, index, name.size(), &length, &size, &type, reinterpret_cast<GLcharARB *>(name.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLcharARB
>
requires (
    semantic::concepts::Span<span_const_GLcharARB> &&
    std::is_same_v<std::decay_t<typename span_const_GLcharARB::value_type>, GLcharARB>)
STATICINLINE GLint get_attrib_location_arb(GLhandleARB programObj, span_const_GLcharARB const& name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetAttribLocationARB)
                Throw(undefined_behavior(
                    "unloaded function GetAttribLocationARB"));
    }
    auto out = glGetAttribLocationARB(programObj, reinterpret_cast<const GLcharARB *>(name.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_vertex_attrib_pointerv_arb(u32 index, groups::vertex_attrib_pointer_property_arb pname, span_byte pointer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribPointervARB)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribPointervARB"));
    }
    glGetVertexAttribPointervARB(index, static_cast<GLenum>(pname), reinterpret_cast<void **>(pointer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f64
>
requires (
    semantic::concepts::Span<span_f64> &&
    std::is_same_v<std::decay_t<typename span_f64::value_type>, f64>)
STATICINLINE void get_vertex_attribdv_arb(u32 index, groups::vertex_attrib_property_arb pname, span_f64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribdvARB)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribdvARB"));
    }
    glGetVertexAttribdvARB(index, static_cast<GLenum>(pname), reinterpret_cast<GLdouble *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_vertex_attribfv_arb(u32 index, groups::vertex_attrib_property_arb pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribfvARB)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribfvARB"));
    }
    glGetVertexAttribfvARB(index, static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_vertex_attribiv_arb(u32 index, groups::vertex_attrib_property_arb pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribivARB)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribivARB"));
    }
    glGetVertexAttribivARB(index, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib1d_arb(u32 index, f64 x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1dARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1dARB"));
    }
    glVertexAttrib1dARB(index, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f64
>
requires (
    semantic::concepts::Span<span_const_f64> &&
    std::is_same_v<std::decay_t<typename span_const_f64::value_type>, f64>)
STATICINLINE void vertex_attrib1dv_arb(u32 index, span_const_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1dvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1dvARB"));
    }
    glVertexAttrib1dvARB(index, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib1f_arb(u32 index, f32 x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1fARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1fARB"));
    }
    glVertexAttrib1fARB(index, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void vertex_attrib1fv_arb(u32 index, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1fvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1fvARB"));
    }
    glVertexAttrib1fvARB(index, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib1s_arb(u32 index, i16 x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1sARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1sARB"));
    }
    glVertexAttrib1sARB(index, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i16
>
requires (
    semantic::concepts::Span<span_const_i16> &&
    std::is_same_v<std::decay_t<typename span_const_i16::value_type>, i16>)
STATICINLINE void vertex_attrib1sv_arb(u32 index, span_const_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1svARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1svARB"));
    }
    glVertexAttrib1svARB(index, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_f64
>
requires (
    semantic::concepts::Vector<vec_2_f64, f64, 2>)
STATICINLINE void vertex_attrib2d_arb(u32 index, vec_2_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2dARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2dARB"));
    }
    glVertexAttrib2dARB(index, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_f64
>
requires (
    semantic::concepts::Span<span_const_vec_2_f64> &&
    semantic::concepts::Vector<typename span_const_vec_2_f64::value_type, f64, 2>)
STATICINLINE void vertex_attrib2dv_arb(u32 index, span_const_vec_2_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2dvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2dvARB"));
    }
    glVertexAttrib2dvARB(index, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_f32
>
requires (
    semantic::concepts::Vector<vec_2_f32, f32, 2>)
STATICINLINE void vertex_attrib2f_arb(u32 index, vec_2_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2fARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2fARB"));
    }
    glVertexAttrib2fARB(index, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_f32
>
requires (
    semantic::concepts::Span<span_const_vec_2_f32> &&
    semantic::concepts::Vector<typename span_const_vec_2_f32::value_type, f32, 2>)
STATICINLINE void vertex_attrib2fv_arb(u32 index, span_const_vec_2_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2fvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2fvARB"));
    }
    glVertexAttrib2fvARB(index, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i16
>
requires (
    semantic::concepts::Vector<vec_2_i16, i16, 2>)
STATICINLINE void vertex_attrib2s_arb(u32 index, vec_2_i16 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2sARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2sARB"));
    }
    glVertexAttrib2sARB(index, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_i16
>
requires (
    semantic::concepts::Span<span_const_vec_2_i16> &&
    semantic::concepts::Vector<typename span_const_vec_2_i16::value_type, i16, 2>)
STATICINLINE void vertex_attrib2sv_arb(u32 index, span_const_vec_2_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2svARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2svARB"));
    }
    glVertexAttrib2svARB(index, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f64
>
requires (
    semantic::concepts::Vector<vec_3_f64, f64, 3>)
STATICINLINE void vertex_attrib3d_arb(u32 index, vec_3_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3dARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3dARB"));
    }
    glVertexAttrib3dARB(index, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_f64
>
requires (
    semantic::concepts::Span<span_const_vec_3_f64> &&
    semantic::concepts::Vector<typename span_const_vec_3_f64::value_type, f64, 3>)
STATICINLINE void vertex_attrib3dv_arb(u32 index, span_const_vec_3_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3dvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3dvARB"));
    }
    glVertexAttrib3dvARB(index, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f32
>
requires (
    semantic::concepts::Vector<vec_3_f32, f32, 3>)
STATICINLINE void vertex_attrib3f_arb(u32 index, vec_3_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3fARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3fARB"));
    }
    glVertexAttrib3fARB(index, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_f32
>
requires (
    semantic::concepts::Span<span_const_vec_3_f32> &&
    semantic::concepts::Vector<typename span_const_vec_3_f32::value_type, f32, 3>)
STATICINLINE void vertex_attrib3fv_arb(u32 index, span_const_vec_3_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3fvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3fvARB"));
    }
    glVertexAttrib3fvARB(index, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i16
>
requires (
    semantic::concepts::Vector<vec_3_i16, i16, 3>)
STATICINLINE void vertex_attrib3s_arb(u32 index, vec_3_i16 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3sARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3sARB"));
    }
    glVertexAttrib3sARB(index, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_i16
>
requires (
    semantic::concepts::Span<span_const_vec_3_i16> &&
    semantic::concepts::Vector<typename span_const_vec_3_i16::value_type, i16, 3>)
STATICINLINE void vertex_attrib3sv_arb(u32 index, span_const_vec_3_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3svARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3svARB"));
    }
    glVertexAttrib3svARB(index, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i8
>
requires (
    semantic::concepts::Span<span_const_i8> &&
    std::is_same_v<std::decay_t<typename span_const_i8::value_type>, i8>)
STATICINLINE void vertex_attrib4_nbv_arb(u32 index, span_const_i8 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4NbvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4NbvARB"));
    }
    glVertexAttrib4NbvARB(index, reinterpret_cast<const GLbyte *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void vertex_attrib4_niv_arb(u32 index, span_const_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4NivARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4NivARB"));
    }
    glVertexAttrib4NivARB(index, reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i16
>
requires (
    semantic::concepts::Span<span_const_i16> &&
    std::is_same_v<std::decay_t<typename span_const_i16::value_type>, i16>)
STATICINLINE void vertex_attrib4_nsv_arb(u32 index, span_const_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4NsvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4NsvARB"));
    }
    glVertexAttrib4NsvARB(index, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_u8
>
requires (
    semantic::concepts::Vector<vec_4_u8, u8, 4>)
STATICINLINE void vertex_attrib4_nub_arb(u32 index, vec_4_u8 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4NubARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4NubARB"));
    }
    glVertexAttrib4NubARB(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u8
>
requires (
    semantic::concepts::Span<span_const_u8> &&
    std::is_same_v<std::decay_t<typename span_const_u8::value_type>, u8>)
STATICINLINE void vertex_attrib4_nubv_arb(u32 index, span_const_u8 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4NubvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4NubvARB"));
    }
    glVertexAttrib4NubvARB(index, reinterpret_cast<const GLubyte *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void vertex_attrib4_nuiv_arb(u32 index, span_const_u32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4NuivARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4NuivARB"));
    }
    glVertexAttrib4NuivARB(index, reinterpret_cast<const GLuint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u16
>
requires (
    semantic::concepts::Span<span_const_u16> &&
    std::is_same_v<std::decay_t<typename span_const_u16::value_type>, u16>)
STATICINLINE void vertex_attrib4_nusv_arb(u32 index, span_const_u16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4NusvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4NusvARB"));
    }
    glVertexAttrib4NusvARB(index, reinterpret_cast<const GLushort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i8
>
requires (
    semantic::concepts::Span<span_const_i8> &&
    std::is_same_v<std::decay_t<typename span_const_i8::value_type>, i8>)
STATICINLINE void vertex_attrib4bv_arb(u32 index, span_const_i8 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4bvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4bvARB"));
    }
    glVertexAttrib4bvARB(index, reinterpret_cast<const GLbyte *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f64
>
requires (
    semantic::concepts::Vector<vec_4_f64, f64, 4>)
STATICINLINE void vertex_attrib4d_arb(u32 index, vec_4_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4dARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4dARB"));
    }
    glVertexAttrib4dARB(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f64
>
requires (
    semantic::concepts::Span<span_const_vec_4_f64> &&
    semantic::concepts::Vector<typename span_const_vec_4_f64::value_type, f64, 4>)
STATICINLINE void vertex_attrib4dv_arb(u32 index, span_const_vec_4_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4dvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4dvARB"));
    }
    glVertexAttrib4dvARB(index, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f32
>
requires (
    semantic::concepts::Vector<vec_4_f32, f32, 4>)
STATICINLINE void vertex_attrib4f_arb(u32 index, vec_4_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4fARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4fARB"));
    }
    glVertexAttrib4fARB(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f32
>
requires (
    semantic::concepts::Span<span_const_vec_4_f32> &&
    semantic::concepts::Vector<typename span_const_vec_4_f32::value_type, f32, 4>)
STATICINLINE void vertex_attrib4fv_arb(u32 index, span_const_vec_4_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4fvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4fvARB"));
    }
    glVertexAttrib4fvARB(index, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_i32
>
requires (
    semantic::concepts::Span<span_const_vec_4_i32> &&
    semantic::concepts::Vector<typename span_const_vec_4_i32::value_type, i32, 4>)
STATICINLINE void vertex_attrib4iv_arb(u32 index, span_const_vec_4_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4ivARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4ivARB"));
    }
    glVertexAttrib4ivARB(index, reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_i16
>
requires (
    semantic::concepts::Vector<vec_4_i16, i16, 4>)
STATICINLINE void vertex_attrib4s_arb(u32 index, vec_4_i16 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4sARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4sARB"));
    }
    glVertexAttrib4sARB(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_i16
>
requires (
    semantic::concepts::Span<span_const_vec_4_i16> &&
    semantic::concepts::Vector<typename span_const_vec_4_i16::value_type, i16, 4>)
STATICINLINE void vertex_attrib4sv_arb(u32 index, span_const_vec_4_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4svARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4svARB"));
    }
    glVertexAttrib4svARB(index, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u8
>
requires (
    semantic::concepts::Span<span_const_u8> &&
    std::is_same_v<std::decay_t<typename span_const_u8::value_type>, u8>)
STATICINLINE void vertex_attrib4ubv_arb(u32 index, span_const_u8 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4ubvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4ubvARB"));
    }
    glVertexAttrib4ubvARB(index, reinterpret_cast<const GLubyte *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u32
>
requires (
    semantic::concepts::Span<span_const_vec_4_u32> &&
    semantic::concepts::Vector<typename span_const_vec_4_u32::value_type, u32, 4>)
STATICINLINE void vertex_attrib4uiv_arb(u32 index, span_const_vec_4_u32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4uivARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4uivARB"));
    }
    glVertexAttrib4uivARB(index, reinterpret_cast<const GLuint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u16
>
requires (
    semantic::concepts::Span<span_const_vec_4_u16> &&
    semantic::concepts::Vector<typename span_const_vec_4_u16::value_type, u16, 4>)
STATICINLINE void vertex_attrib4usv_arb(u32 index, span_const_vec_4_u16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4usvARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4usvARB"));
    }
    glVertexAttrib4usvARB(index, reinterpret_cast<const GLushort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void vertex_attrib_pointer_arb(u32 index, i32 size, groups::vertex_attrib_pointer_type type, bool normalized, i32 stride, span_const_byte const& pointer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribPointerARB)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribPointerARB"));
    }
    glVertexAttribPointerARB(index, size, static_cast<GLenum>(type), normalized, stride, reinterpret_cast<const void *>(pointer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_vertex_shader
#endif // GL_ARB_vertex_shader
#ifdef GL_ARB_vertex_type_10f_11f_11f_rev
namespace arb_vertex_type_10f_11f_11f_rev {
constexpr u32 unsigned_int_10f_11f_11f_rev = 0x8C3B;
} // arb_vertex_type_10f_11f_11f_rev
#endif // GL_ARB_vertex_type_10f_11f_11f_rev
#ifdef GL_ARB_vertex_type_2_10_10_10_rev
namespace arb_vertex_type_2_10_10_10_rev {
constexpr u32 unsigned_int_2_10_10_10_rev = 0x8368;
constexpr u32 int_2_10_10_10_rev = 0x8D9F;
STATICINLINE void vertex_attrib_p1ui(u32 index, groups::vertex_attrib_pointer_type type, bool normalized, u32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribP1ui)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribP1ui"));
    }
    glVertexAttribP1ui(index, static_cast<GLenum>(type), normalized, value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void vertex_attrib_p1uiv(u32 index, groups::vertex_attrib_pointer_type type, bool normalized, span_const_u32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribP1uiv)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribP1uiv"));
    }
    glVertexAttribP1uiv(index, static_cast<GLenum>(type), normalized, reinterpret_cast<const GLuint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib_p2ui(u32 index, groups::vertex_attrib_pointer_type type, bool normalized, u32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribP2ui)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribP2ui"));
    }
    glVertexAttribP2ui(index, static_cast<GLenum>(type), normalized, value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_u32
>
requires (
    semantic::concepts::Span<span_const_vec_2_u32> &&
    semantic::concepts::Vector<typename span_const_vec_2_u32::value_type, u32, 2>)
STATICINLINE void vertex_attrib_p2uiv(u32 index, groups::vertex_attrib_pointer_type type, bool normalized, span_const_vec_2_u32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribP2uiv)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribP2uiv"));
    }
    glVertexAttribP2uiv(index, static_cast<GLenum>(type), normalized, reinterpret_cast<const GLuint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib_p3ui(u32 index, groups::vertex_attrib_pointer_type type, bool normalized, u32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribP3ui)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribP3ui"));
    }
    glVertexAttribP3ui(index, static_cast<GLenum>(type), normalized, value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_u32
>
requires (
    semantic::concepts::Span<span_const_vec_3_u32> &&
    semantic::concepts::Vector<typename span_const_vec_3_u32::value_type, u32, 3>)
STATICINLINE void vertex_attrib_p3uiv(u32 index, groups::vertex_attrib_pointer_type type, bool normalized, span_const_vec_3_u32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribP3uiv)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribP3uiv"));
    }
    glVertexAttribP3uiv(index, static_cast<GLenum>(type), normalized, reinterpret_cast<const GLuint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib_p4ui(u32 index, groups::vertex_attrib_pointer_type type, bool normalized, u32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribP4ui)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribP4ui"));
    }
    glVertexAttribP4ui(index, static_cast<GLenum>(type), normalized, value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u32
>
requires (
    semantic::concepts::Span<span_const_vec_4_u32> &&
    semantic::concepts::Vector<typename span_const_vec_4_u32::value_type, u32, 4>)
STATICINLINE void vertex_attrib_p4uiv(u32 index, groups::vertex_attrib_pointer_type type, bool normalized, span_const_vec_4_u32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribP4uiv)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribP4uiv"));
    }
    glVertexAttribP4uiv(index, static_cast<GLenum>(type), normalized, reinterpret_cast<const GLuint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void color_p3ui(groups::color_pointer_type type, u32 color)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColorP3ui)
                Throw(undefined_behavior(
                    "unloaded function ColorP3ui"));
    }
    glColorP3ui(static_cast<GLenum>(type), color);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_u32
>
requires (
    semantic::concepts::Span<span_const_vec_3_u32> &&
    semantic::concepts::Vector<typename span_const_vec_3_u32::value_type, u32, 3>)
STATICINLINE void color_p3uiv(groups::color_pointer_type type, span_const_vec_3_u32 const& color)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColorP3uiv)
                Throw(undefined_behavior(
                    "unloaded function ColorP3uiv"));
    }
    glColorP3uiv(static_cast<GLenum>(type), reinterpret_cast<const GLuint *>(color.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void color_p4ui(groups::color_pointer_type type, u32 color)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColorP4ui)
                Throw(undefined_behavior(
                    "unloaded function ColorP4ui"));
    }
    glColorP4ui(static_cast<GLenum>(type), color);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u32
>
requires (
    semantic::concepts::Span<span_const_vec_4_u32> &&
    semantic::concepts::Vector<typename span_const_vec_4_u32::value_type, u32, 4>)
STATICINLINE void color_p4uiv(groups::color_pointer_type type, span_const_vec_4_u32 const& color)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColorP4uiv)
                Throw(undefined_behavior(
                    "unloaded function ColorP4uiv"));
    }
    glColorP4uiv(static_cast<GLenum>(type), reinterpret_cast<const GLuint *>(color.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord_p1ui(groups::texture_unit texture, groups::tex_coord_pointer_type type, u32 coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoordP1ui)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoordP1ui"));
    }
    glMultiTexCoordP1ui(static_cast<GLenum>(texture), static_cast<GLenum>(type), coords);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void multi_tex_coord_p1uiv(groups::texture_unit texture, groups::tex_coord_pointer_type type, span_const_u32 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoordP1uiv)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoordP1uiv"));
    }
    glMultiTexCoordP1uiv(static_cast<GLenum>(texture), static_cast<GLenum>(type), reinterpret_cast<const GLuint *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord_p2ui(groups::texture_unit texture, groups::tex_coord_pointer_type type, u32 coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoordP2ui)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoordP2ui"));
    }
    glMultiTexCoordP2ui(static_cast<GLenum>(texture), static_cast<GLenum>(type), coords);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_u32
>
requires (
    semantic::concepts::Span<span_const_vec_2_u32> &&
    semantic::concepts::Vector<typename span_const_vec_2_u32::value_type, u32, 2>)
STATICINLINE void multi_tex_coord_p2uiv(groups::texture_unit texture, groups::tex_coord_pointer_type type, span_const_vec_2_u32 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoordP2uiv)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoordP2uiv"));
    }
    glMultiTexCoordP2uiv(static_cast<GLenum>(texture), static_cast<GLenum>(type), reinterpret_cast<const GLuint *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord_p3ui(groups::texture_unit texture, groups::tex_coord_pointer_type type, u32 coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoordP3ui)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoordP3ui"));
    }
    glMultiTexCoordP3ui(static_cast<GLenum>(texture), static_cast<GLenum>(type), coords);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_u32
>
requires (
    semantic::concepts::Span<span_const_vec_3_u32> &&
    semantic::concepts::Vector<typename span_const_vec_3_u32::value_type, u32, 3>)
STATICINLINE void multi_tex_coord_p3uiv(groups::texture_unit texture, groups::tex_coord_pointer_type type, span_const_vec_3_u32 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoordP3uiv)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoordP3uiv"));
    }
    glMultiTexCoordP3uiv(static_cast<GLenum>(texture), static_cast<GLenum>(type), reinterpret_cast<const GLuint *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord_p4ui(groups::texture_unit texture, groups::tex_coord_pointer_type type, u32 coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoordP4ui)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoordP4ui"));
    }
    glMultiTexCoordP4ui(static_cast<GLenum>(texture), static_cast<GLenum>(type), coords);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u32
>
requires (
    semantic::concepts::Span<span_const_vec_4_u32> &&
    semantic::concepts::Vector<typename span_const_vec_4_u32::value_type, u32, 4>)
STATICINLINE void multi_tex_coord_p4uiv(groups::texture_unit texture, groups::tex_coord_pointer_type type, span_const_vec_4_u32 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoordP4uiv)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoordP4uiv"));
    }
    glMultiTexCoordP4uiv(static_cast<GLenum>(texture), static_cast<GLenum>(type), reinterpret_cast<const GLuint *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void normal_p3ui(groups::normal_pointer_type type, u32 coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNormalP3ui)
                Throw(undefined_behavior(
                    "unloaded function NormalP3ui"));
    }
    glNormalP3ui(static_cast<GLenum>(type), coords);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_u32
>
requires (
    semantic::concepts::Span<span_const_vec_3_u32> &&
    semantic::concepts::Vector<typename span_const_vec_3_u32::value_type, u32, 3>)
STATICINLINE void normal_p3uiv(groups::normal_pointer_type type, span_const_vec_3_u32 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNormalP3uiv)
                Throw(undefined_behavior(
                    "unloaded function NormalP3uiv"));
    }
    glNormalP3uiv(static_cast<GLenum>(type), reinterpret_cast<const GLuint *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void secondary_color_p3ui(groups::color_pointer_type type, u32 color)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSecondaryColorP3ui)
                Throw(undefined_behavior(
                    "unloaded function SecondaryColorP3ui"));
    }
    glSecondaryColorP3ui(static_cast<GLenum>(type), color);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_u32
>
requires (
    semantic::concepts::Span<span_const_vec_3_u32> &&
    semantic::concepts::Vector<typename span_const_vec_3_u32::value_type, u32, 3>)
STATICINLINE void secondary_color_p3uiv(groups::color_pointer_type type, span_const_vec_3_u32 const& color)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSecondaryColorP3uiv)
                Throw(undefined_behavior(
                    "unloaded function SecondaryColorP3uiv"));
    }
    glSecondaryColorP3uiv(static_cast<GLenum>(type), reinterpret_cast<const GLuint *>(color.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_coord_p1ui(groups::tex_coord_pointer_type type, u32 coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoordP1ui)
                Throw(undefined_behavior(
                    "unloaded function TexCoordP1ui"));
    }
    glTexCoordP1ui(static_cast<GLenum>(type), coords);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void tex_coord_p1uiv(groups::tex_coord_pointer_type type, span_const_u32 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoordP1uiv)
                Throw(undefined_behavior(
                    "unloaded function TexCoordP1uiv"));
    }
    glTexCoordP1uiv(static_cast<GLenum>(type), reinterpret_cast<const GLuint *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_coord_p2ui(groups::tex_coord_pointer_type type, u32 coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoordP2ui)
                Throw(undefined_behavior(
                    "unloaded function TexCoordP2ui"));
    }
    glTexCoordP2ui(static_cast<GLenum>(type), coords);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_u32
>
requires (
    semantic::concepts::Span<span_const_vec_2_u32> &&
    semantic::concepts::Vector<typename span_const_vec_2_u32::value_type, u32, 2>)
STATICINLINE void tex_coord_p2uiv(groups::tex_coord_pointer_type type, span_const_vec_2_u32 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoordP2uiv)
                Throw(undefined_behavior(
                    "unloaded function TexCoordP2uiv"));
    }
    glTexCoordP2uiv(static_cast<GLenum>(type), reinterpret_cast<const GLuint *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_coord_p3ui(groups::tex_coord_pointer_type type, u32 coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoordP3ui)
                Throw(undefined_behavior(
                    "unloaded function TexCoordP3ui"));
    }
    glTexCoordP3ui(static_cast<GLenum>(type), coords);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_u32
>
requires (
    semantic::concepts::Span<span_const_vec_3_u32> &&
    semantic::concepts::Vector<typename span_const_vec_3_u32::value_type, u32, 3>)
STATICINLINE void tex_coord_p3uiv(groups::tex_coord_pointer_type type, span_const_vec_3_u32 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoordP3uiv)
                Throw(undefined_behavior(
                    "unloaded function TexCoordP3uiv"));
    }
    glTexCoordP3uiv(static_cast<GLenum>(type), reinterpret_cast<const GLuint *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_coord_p4ui(groups::tex_coord_pointer_type type, u32 coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoordP4ui)
                Throw(undefined_behavior(
                    "unloaded function TexCoordP4ui"));
    }
    glTexCoordP4ui(static_cast<GLenum>(type), coords);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u32
>
requires (
    semantic::concepts::Span<span_const_vec_4_u32> &&
    semantic::concepts::Vector<typename span_const_vec_4_u32::value_type, u32, 4>)
STATICINLINE void tex_coord_p4uiv(groups::tex_coord_pointer_type type, span_const_vec_4_u32 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoordP4uiv)
                Throw(undefined_behavior(
                    "unloaded function TexCoordP4uiv"));
    }
    glTexCoordP4uiv(static_cast<GLenum>(type), reinterpret_cast<const GLuint *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_p2ui(groups::vertex_pointer_type type, u32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexP2ui)
                Throw(undefined_behavior(
                    "unloaded function VertexP2ui"));
    }
    glVertexP2ui(static_cast<GLenum>(type), value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_u32
>
requires (
    semantic::concepts::Span<span_const_vec_2_u32> &&
    semantic::concepts::Vector<typename span_const_vec_2_u32::value_type, u32, 2>)
STATICINLINE void vertex_p2uiv(groups::vertex_pointer_type type, span_const_vec_2_u32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexP2uiv)
                Throw(undefined_behavior(
                    "unloaded function VertexP2uiv"));
    }
    glVertexP2uiv(static_cast<GLenum>(type), reinterpret_cast<const GLuint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_p3ui(groups::vertex_pointer_type type, u32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexP3ui)
                Throw(undefined_behavior(
                    "unloaded function VertexP3ui"));
    }
    glVertexP3ui(static_cast<GLenum>(type), value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_u32
>
requires (
    semantic::concepts::Span<span_const_vec_3_u32> &&
    semantic::concepts::Vector<typename span_const_vec_3_u32::value_type, u32, 3>)
STATICINLINE void vertex_p3uiv(groups::vertex_pointer_type type, span_const_vec_3_u32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexP3uiv)
                Throw(undefined_behavior(
                    "unloaded function VertexP3uiv"));
    }
    glVertexP3uiv(static_cast<GLenum>(type), reinterpret_cast<const GLuint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_p4ui(groups::vertex_pointer_type type, u32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexP4ui)
                Throw(undefined_behavior(
                    "unloaded function VertexP4ui"));
    }
    glVertexP4ui(static_cast<GLenum>(type), value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u32
>
requires (
    semantic::concepts::Span<span_const_vec_4_u32> &&
    semantic::concepts::Vector<typename span_const_vec_4_u32::value_type, u32, 4>)
STATICINLINE void vertex_p4uiv(groups::vertex_pointer_type type, span_const_vec_4_u32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexP4uiv)
                Throw(undefined_behavior(
                    "unloaded function VertexP4uiv"));
    }
    glVertexP4uiv(static_cast<GLenum>(type), reinterpret_cast<const GLuint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_vertex_type_2_10_10_10_rev
#endif // GL_ARB_vertex_type_2_10_10_10_rev
#ifdef GL_ARB_viewport_array
namespace arb_viewport_array {
constexpr u32 depth_range = 0x0B70;
constexpr u32 viewport = 0x0BA2;
constexpr u32 scissor_box = 0x0C10;
constexpr u32 scissor_test = 0x0C11;
constexpr u32 max_viewports = 0x825B;
constexpr u32 viewport_subpixel_bits = 0x825C;
constexpr u32 viewport_bounds_range = 0x825D;
constexpr u32 layer_provoking_vertex = 0x825E;
constexpr u32 viewport_index_provoking_vertex = 0x825F;
constexpr u32 undefined_vertex = 0x8260;
constexpr u32 first_vertex_convention = 0x8E4D;
constexpr u32 last_vertex_convention = 0x8E4E;
constexpr u32 provoking_vertex = 0x8E4F;
template<
    class span_const_f64
>
requires (
    semantic::concepts::Span<span_const_f64> &&
    std::is_same_v<std::decay_t<typename span_const_f64::value_type>, f64>)
STATICINLINE void depth_range_arrayv(u32 first, i32 count, span_const_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDepthRangeArrayv)
                Throw(undefined_behavior(
                    "unloaded function DepthRangeArrayv"));
    }
    glDepthRangeArrayv(first, count, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void depth_range_indexed(u32 index, f64 n, f64 f)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDepthRangeIndexed)
                Throw(undefined_behavior(
                    "unloaded function DepthRangeIndexed"));
    }
    glDepthRangeIndexed(index, n, f);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f64
>
requires (
    semantic::concepts::Span<span_f64> &&
    std::is_same_v<std::decay_t<typename span_f64::value_type>, f64>)
STATICINLINE void get_doublei_v(groups::get_prop target, u32 index, span_f64 data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetDoublei_v)
                Throw(undefined_behavior(
                    "unloaded function GetDoublei_v"));
    }
    glGetDoublei_v(static_cast<GLenum>(target), index, reinterpret_cast<GLdouble *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_floati_v(groups::get_prop target, u32 index, span_f32 data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetFloati_v)
                Throw(undefined_behavior(
                    "unloaded function GetFloati_v"));
    }
    glGetFloati_v(static_cast<GLenum>(target), index, reinterpret_cast<GLfloat *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void scissor_arrayv(u32 first, i32 count, span_const_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glScissorArrayv)
                Throw(undefined_behavior(
                    "unloaded function ScissorArrayv"));
    }
    glScissorArrayv(first, count, reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void scissor_indexed(u32 index, i32 left, i32 bottom, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glScissorIndexed)
                Throw(undefined_behavior(
                    "unloaded function ScissorIndexed"));
    }
    glScissorIndexed(index, left, bottom, width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void scissor_indexedv(u32 index, span_const_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glScissorIndexedv)
                Throw(undefined_behavior(
                    "unloaded function ScissorIndexedv"));
    }
    glScissorIndexedv(index, reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void viewport_arrayv(u32 first, i32 count, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glViewportArrayv)
                Throw(undefined_behavior(
                    "unloaded function ViewportArrayv"));
    }
    glViewportArrayv(first, count, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_f32
>
requires (
    semantic::concepts::Vector<vec_2_f32, f32, 2>)
STATICINLINE void viewport_indexedf(u32 index, vec_2_f32 const& x, vec_2_f32 const& w)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glViewportIndexedf)
                Throw(undefined_behavior(
                    "unloaded function ViewportIndexedf"));
    }
    glViewportIndexedf(index, x.x(), x.y(), w[0], w[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void viewport_indexedfv(u32 index, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glViewportIndexedfv)
                Throw(undefined_behavior(
                    "unloaded function ViewportIndexedfv"));
    }
    glViewportIndexedfv(index, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f64
>
requires (
    semantic::concepts::Span<span_const_f64> &&
    std::is_same_v<std::decay_t<typename span_const_f64::value_type>, f64>)
STATICINLINE void depth_range_arraydv_nv(u32 first, i32 count, span_const_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDepthRangeArraydvNV)
                Throw(undefined_behavior(
                    "unloaded function DepthRangeArraydvNV"));
    }
    glDepthRangeArraydvNV(first, count, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void depth_range_indexedd_nv(u32 index, f64 n, f64 f)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDepthRangeIndexeddNV)
                Throw(undefined_behavior(
                    "unloaded function DepthRangeIndexeddNV"));
    }
    glDepthRangeIndexeddNV(index, n, f);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_viewport_array
#endif // GL_ARB_viewport_array
#ifdef GL_ARB_window_pos
namespace arb_window_pos {
template<
    class vec_2_f64
>
requires (
    semantic::concepts::Vector<vec_2_f64, f64, 2>)
STATICINLINE void window_pos2d_arb(vec_2_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWindowPos2dARB)
                Throw(undefined_behavior(
                    "unloaded function WindowPos2dARB"));
    }
    glWindowPos2dARB(x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_f64
>
requires (
    semantic::concepts::Span<span_const_vec_2_f64> &&
    semantic::concepts::Vector<typename span_const_vec_2_f64::value_type, f64, 2>)
STATICINLINE void window_pos2dv_arb(span_const_vec_2_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWindowPos2dvARB)
                Throw(undefined_behavior(
                    "unloaded function WindowPos2dvARB"));
    }
    glWindowPos2dvARB(reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_f32
>
requires (
    semantic::concepts::Vector<vec_2_f32, f32, 2>)
STATICINLINE void window_pos2f_arb(vec_2_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWindowPos2fARB)
                Throw(undefined_behavior(
                    "unloaded function WindowPos2fARB"));
    }
    glWindowPos2fARB(x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_f32
>
requires (
    semantic::concepts::Span<span_const_vec_2_f32> &&
    semantic::concepts::Vector<typename span_const_vec_2_f32::value_type, f32, 2>)
STATICINLINE void window_pos2fv_arb(span_const_vec_2_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWindowPos2fvARB)
                Throw(undefined_behavior(
                    "unloaded function WindowPos2fvARB"));
    }
    glWindowPos2fvARB(reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void window_pos2i_arb(vec_2_i32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWindowPos2iARB)
                Throw(undefined_behavior(
                    "unloaded function WindowPos2iARB"));
    }
    glWindowPos2iARB(x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_i32
>
requires (
    semantic::concepts::Span<span_const_vec_2_i32> &&
    semantic::concepts::Vector<typename span_const_vec_2_i32::value_type, i32, 2>)
STATICINLINE void window_pos2iv_arb(span_const_vec_2_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWindowPos2ivARB)
                Throw(undefined_behavior(
                    "unloaded function WindowPos2ivARB"));
    }
    glWindowPos2ivARB(reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i16
>
requires (
    semantic::concepts::Vector<vec_2_i16, i16, 2>)
STATICINLINE void window_pos2s_arb(vec_2_i16 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWindowPos2sARB)
                Throw(undefined_behavior(
                    "unloaded function WindowPos2sARB"));
    }
    glWindowPos2sARB(x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_i16
>
requires (
    semantic::concepts::Span<span_const_vec_2_i16> &&
    semantic::concepts::Vector<typename span_const_vec_2_i16::value_type, i16, 2>)
STATICINLINE void window_pos2sv_arb(span_const_vec_2_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWindowPos2svARB)
                Throw(undefined_behavior(
                    "unloaded function WindowPos2svARB"));
    }
    glWindowPos2svARB(reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f64
>
requires (
    semantic::concepts::Vector<vec_3_f64, f64, 3>)
STATICINLINE void window_pos3d_arb(vec_3_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWindowPos3dARB)
                Throw(undefined_behavior(
                    "unloaded function WindowPos3dARB"));
    }
    glWindowPos3dARB(x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_f64
>
requires (
    semantic::concepts::Span<span_const_vec_3_f64> &&
    semantic::concepts::Vector<typename span_const_vec_3_f64::value_type, f64, 3>)
STATICINLINE void window_pos3dv_arb(span_const_vec_3_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWindowPos3dvARB)
                Throw(undefined_behavior(
                    "unloaded function WindowPos3dvARB"));
    }
    glWindowPos3dvARB(reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f32
>
requires (
    semantic::concepts::Vector<vec_3_f32, f32, 3>)
STATICINLINE void window_pos3f_arb(vec_3_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWindowPos3fARB)
                Throw(undefined_behavior(
                    "unloaded function WindowPos3fARB"));
    }
    glWindowPos3fARB(x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_f32
>
requires (
    semantic::concepts::Span<span_const_vec_3_f32> &&
    semantic::concepts::Vector<typename span_const_vec_3_f32::value_type, f32, 3>)
STATICINLINE void window_pos3fv_arb(span_const_vec_3_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWindowPos3fvARB)
                Throw(undefined_behavior(
                    "unloaded function WindowPos3fvARB"));
    }
    glWindowPos3fvARB(reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void window_pos3i_arb(vec_3_i32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWindowPos3iARB)
                Throw(undefined_behavior(
                    "unloaded function WindowPos3iARB"));
    }
    glWindowPos3iARB(x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_i32
>
requires (
    semantic::concepts::Span<span_const_vec_3_i32> &&
    semantic::concepts::Vector<typename span_const_vec_3_i32::value_type, i32, 3>)
STATICINLINE void window_pos3iv_arb(span_const_vec_3_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWindowPos3ivARB)
                Throw(undefined_behavior(
                    "unloaded function WindowPos3ivARB"));
    }
    glWindowPos3ivARB(reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i16
>
requires (
    semantic::concepts::Vector<vec_3_i16, i16, 3>)
STATICINLINE void window_pos3s_arb(vec_3_i16 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWindowPos3sARB)
                Throw(undefined_behavior(
                    "unloaded function WindowPos3sARB"));
    }
    glWindowPos3sARB(x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_i16
>
requires (
    semantic::concepts::Span<span_const_vec_3_i16> &&
    semantic::concepts::Vector<typename span_const_vec_3_i16::value_type, i16, 3>)
STATICINLINE void window_pos3sv_arb(span_const_vec_3_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWindowPos3svARB)
                Throw(undefined_behavior(
                    "unloaded function WindowPos3svARB"));
    }
    glWindowPos3svARB(reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // arb_window_pos
#endif // GL_ARB_window_pos
#ifdef GL_ARM_mali_program_binary
namespace arm_mali_program_binary {
constexpr u32 mali_program_binary_arm = 0x8F61;
} // arm_mali_program_binary
#endif // GL_ARM_mali_program_binary
#ifdef GL_ARM_mali_shader_binary
namespace arm_mali_shader_binary {
constexpr u32 mali_shader_binary_arm = 0x8F60;
} // arm_mali_shader_binary
#endif // GL_ARM_mali_shader_binary
#ifdef GL_ARM_rgba8
namespace arm_rgba8 {
} // arm_rgba8
#endif // GL_ARM_rgba8
#ifdef GL_ARM_shader_framebuffer_fetch
namespace arm_shader_framebuffer_fetch {
constexpr u32 fetch_per_sample_arm = 0x8F65;
constexpr u32 fragment_shader_framebuffer_fetch_mrt_arm = 0x8F66;
} // arm_shader_framebuffer_fetch
#endif // GL_ARM_shader_framebuffer_fetch
#ifdef GL_ARM_shader_framebuffer_fetch_depth_stencil
namespace arm_shader_framebuffer_fetch_depth_stencil {
} // arm_shader_framebuffer_fetch_depth_stencil
#endif // GL_ARM_shader_framebuffer_fetch_depth_stencil
#ifdef GL_ARM_texture_unnormalized_coordinates
namespace arm_texture_unnormalized_coordinates {
constexpr u32 texture_unnormalized_coordinates_arm = 0x8F6A;
} // arm_texture_unnormalized_coordinates
#endif // GL_ARM_texture_unnormalized_coordinates
#ifdef GL_NV_timeline_semaphore
namespace nv_timeline_semaphore {
constexpr u32 timeline_semaphore_value_nv = 0x9595;
constexpr u32 semaphore_type_nv = 0x95B3;
constexpr u32 semaphore_type_binary_nv = 0x95B4;
constexpr u32 semaphore_type_timeline_nv = 0x95B5;
constexpr u32 max_timeline_semaphore_value_difference_nv = 0x95B6;
template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void create_semaphores_nv(span_u32 semaphores)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreateSemaphoresNV)
                Throw(undefined_behavior(
                    "unloaded function CreateSemaphoresNV"));
    }
    glCreateSemaphoresNV(semaphores.size(), reinterpret_cast<GLuint *>(semaphores.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_semaphore_parameteriv_nv(u32 semaphore, groups::semaphore_parameter_name pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetSemaphoreParameterivNV)
                Throw(undefined_behavior(
                    "unloaded function GetSemaphoreParameterivNV"));
    }
    glGetSemaphoreParameterivNV(semaphore, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void semaphore_parameteriv_nv(u32 semaphore, groups::semaphore_parameter_name pname, span_const_i32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSemaphoreParameterivNV)
                Throw(undefined_behavior(
                    "unloaded function SemaphoreParameterivNV"));
    }
    glSemaphoreParameterivNV(semaphore, static_cast<GLenum>(pname), reinterpret_cast<const GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_timeline_semaphore
#endif // GL_NV_timeline_semaphore
#ifdef GL_INTEL_conservative_rasterization
namespace intel_conservative_rasterization {
constexpr u32 conservative_rasterization_intel = 0x83FE;
} // intel_conservative_rasterization
#endif // GL_INTEL_conservative_rasterization
#ifdef GL_INTEL_fragment_shader_ordering
namespace intel_fragment_shader_ordering {
} // intel_fragment_shader_ordering
#endif // GL_INTEL_fragment_shader_ordering
#ifdef GL_INTEL_framebuffer_CMAA
namespace intel_framebuffer_cmaa {
STATICINLINE void apply_framebuffer_attachment_cmaaintel()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glApplyFramebufferAttachmentCMAAINTEL)
                Throw(undefined_behavior(
                    "unloaded function ApplyFramebufferAttachmentCMAAINTEL"));
    }
    glApplyFramebufferAttachmentCMAAINTEL();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // intel_framebuffer_cmaa
#endif // GL_INTEL_framebuffer_CMAA
#ifdef GL_INTEL_map_texture
namespace intel_map_texture {
constexpr u32 layout_default_intel = 0;
constexpr u32 layout_linear_intel = 1;
constexpr u32 layout_linear_cpu_cached_intel = 2;
constexpr u32 texture_memory_layout_intel = 0x83FF;
STATICINLINE void * map_texture_2dintel(u32 texture, i32 level, GLbitfield access, i32& stride, GLenum& layout)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMapTexture2DINTEL)
                Throw(undefined_behavior(
                    "unloaded function MapTexture2DINTEL"));
        glIsTexture(texture);
    }
    auto out = glMapTexture2DINTEL(texture, level, access, &stride, &layout);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void sync_texture_intel(u32 texture)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSyncTextureINTEL)
                Throw(undefined_behavior(
                    "unloaded function SyncTextureINTEL"));
        glIsTexture(texture);
    }
    glSyncTextureINTEL(texture);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void unmap_texture_2dintel(u32 texture, i32 level)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUnmapTexture2DINTEL)
                Throw(undefined_behavior(
                    "unloaded function UnmapTexture2DINTEL"));
        glIsTexture(texture);
    }
    glUnmapTexture2DINTEL(texture, level);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // intel_map_texture
#endif // GL_INTEL_map_texture
#ifdef GL_INTEL_blackhole_render
namespace intel_blackhole_render {
constexpr u32 blackhole_render_intel = 0x83FC;
} // intel_blackhole_render
#endif // GL_INTEL_blackhole_render
#ifdef GL_INTEL_parallel_arrays
namespace intel_parallel_arrays {
constexpr u32 parallel_arrays_intel = 0x83F4;
constexpr u32 vertex_array_parallel_pointers_intel = 0x83F5;
constexpr u32 normal_array_parallel_pointers_intel = 0x83F6;
constexpr u32 color_array_parallel_pointers_intel = 0x83F7;
constexpr u32 texture_coord_array_parallel_pointers_intel = 0x83F8;
template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void color_pointerv_intel(i32 size, groups::vertex_pointer_type type, span_const_byte const& pointer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColorPointervINTEL)
                Throw(undefined_behavior(
                    "unloaded function ColorPointervINTEL"));
    }
    glColorPointervINTEL(size, static_cast<GLenum>(type), reinterpret_cast<const void **>(pointer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void normal_pointerv_intel(groups::normal_pointer_type type, span_const_byte const& pointer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNormalPointervINTEL)
                Throw(undefined_behavior(
                    "unloaded function NormalPointervINTEL"));
    }
    glNormalPointervINTEL(static_cast<GLenum>(type), reinterpret_cast<const void **>(pointer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void tex_coord_pointerv_intel(i32 size, groups::vertex_pointer_type type, span_const_byte const& pointer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoordPointervINTEL)
                Throw(undefined_behavior(
                    "unloaded function TexCoordPointervINTEL"));
    }
    glTexCoordPointervINTEL(size, static_cast<GLenum>(type), reinterpret_cast<const void **>(pointer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void vertex_pointerv_intel(i32 size, groups::vertex_pointer_type type, span_const_byte const& pointer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexPointervINTEL)
                Throw(undefined_behavior(
                    "unloaded function VertexPointervINTEL"));
    }
    glVertexPointervINTEL(size, static_cast<GLenum>(type), reinterpret_cast<const void **>(pointer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // intel_parallel_arrays
#endif // GL_INTEL_parallel_arrays
#ifdef GL_INTEL_performance_query
namespace intel_performance_query {
constexpr u32 perfquery_single_context_intel = 0x00000000;
constexpr u32 perfquery_global_context_intel = 0x00000001;
constexpr u32 perfquery_donot_flush_intel = 0x83F9;
constexpr u32 perfquery_flush_intel = 0x83FA;
constexpr u32 perfquery_wait_intel = 0x83FB;
constexpr u32 perfquery_counter_event_intel = 0x94F0;
constexpr u32 perfquery_counter_duration_norm_intel = 0x94F1;
constexpr u32 perfquery_counter_duration_raw_intel = 0x94F2;
constexpr u32 perfquery_counter_throughput_intel = 0x94F3;
constexpr u32 perfquery_counter_raw_intel = 0x94F4;
constexpr u32 perfquery_counter_timestamp_intel = 0x94F5;
constexpr u32 perfquery_counter_data_uint32_intel = 0x94F8;
constexpr u32 perfquery_counter_data_uint64_intel = 0x94F9;
constexpr u32 perfquery_counter_data_float_intel = 0x94FA;
constexpr u32 perfquery_counter_data_double_intel = 0x94FB;
constexpr u32 perfquery_counter_data_bool32_intel = 0x94FC;
constexpr u32 perfquery_query_name_length_max_intel = 0x94FD;
constexpr u32 perfquery_counter_name_length_max_intel = 0x94FE;
constexpr u32 perfquery_counter_desc_length_max_intel = 0x94FF;
constexpr u32 perfquery_gpa_extended_counters_intel = 0x9500;
STATICINLINE void begin_perf_query_intel(u32 queryHandle)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBeginPerfQueryINTEL)
                Throw(undefined_behavior(
                    "unloaded function BeginPerfQueryINTEL"));
    }
    glBeginPerfQueryINTEL(queryHandle);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void create_perf_query_intel(u32 queryId, span_u32 queryHandle)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreatePerfQueryINTEL)
                Throw(undefined_behavior(
                    "unloaded function CreatePerfQueryINTEL"));
    }
    glCreatePerfQueryINTEL(queryId, reinterpret_cast<GLuint *>(queryHandle.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void delete_perf_query_intel(u32 queryHandle)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeletePerfQueryINTEL)
                Throw(undefined_behavior(
                    "unloaded function DeletePerfQueryINTEL"));
    }
    glDeletePerfQueryINTEL(queryHandle);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void end_perf_query_intel(u32 queryHandle)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEndPerfQueryINTEL)
                Throw(undefined_behavior(
                    "unloaded function EndPerfQueryINTEL"));
    }
    glEndPerfQueryINTEL(queryHandle);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_first_perf_query_id_intel(span_u32 queryId)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetFirstPerfQueryIdINTEL)
                Throw(undefined_behavior(
                    "unloaded function GetFirstPerfQueryIdINTEL"));
    }
    glGetFirstPerfQueryIdINTEL(reinterpret_cast<GLuint *>(queryId.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_next_perf_query_id_intel(u32 queryId, span_u32 nextQueryId)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetNextPerfQueryIdINTEL)
                Throw(undefined_behavior(
                    "unloaded function GetNextPerfQueryIdINTEL"));
    }
    glGetNextPerfQueryIdINTEL(queryId, reinterpret_cast<GLuint *>(nextQueryId.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32,
    class span_u64
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32> &&
    semantic::concepts::Span<span_u64> &&
    std::is_same_v<std::decay_t<typename span_u64::value_type>, u64>)
STATICINLINE void get_perf_counter_info_intel(u32 queryId, u32 counterId, u32 counterNameLength, u32 counterDescLength, span_u32 counterOffset, span_u32 counterDataSize, span_u32 counterTypeEnum, span_u32 counterDataTypeEnum, span_u64 rawCounterMaxValue)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPerfCounterInfoINTEL)
                Throw(undefined_behavior(
                    "unloaded function GetPerfCounterInfoINTEL"));
    }
    glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterDescLength, reinterpret_cast<GLuint *>(counterOffset.data()), reinterpret_cast<GLuint *>(counterDataSize.data()), reinterpret_cast<GLuint *>(counterTypeEnum.data()), reinterpret_cast<GLuint *>(counterDataTypeEnum.data()), reinterpret_cast<GLuint64 *>(rawCounterMaxValue.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte,
    class span_u32
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte> &&
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_perf_query_data_intel(u32 queryHandle, u32 flags, i32 dataSize, span_byte data, span_u32 bytesWritten)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPerfQueryDataINTEL)
                Throw(undefined_behavior(
                    "unloaded function GetPerfQueryDataINTEL"));
    }
    glGetPerfQueryDataINTEL(queryHandle, flags, dataSize, reinterpret_cast<void *>(data.data()), reinterpret_cast<GLuint *>(bytesWritten.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_perf_query_id_by_name_intel(span_u32 queryId)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPerfQueryIdByNameINTEL)
                Throw(undefined_behavior(
                    "unloaded function GetPerfQueryIdByNameINTEL"));
    }
    glGetPerfQueryIdByNameINTEL(reinterpret_cast<GLuint *>(queryId.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_perf_query_info_intel(u32 queryId, u32 queryNameLength, span_u32 dataSize, span_u32 noCounters, span_u32 noInstances, span_u32 capsMask)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPerfQueryInfoINTEL)
                Throw(undefined_behavior(
                    "unloaded function GetPerfQueryInfoINTEL"));
    }
    glGetPerfQueryInfoINTEL(queryId, queryNameLength, reinterpret_cast<GLuint *>(dataSize.data()), reinterpret_cast<GLuint *>(noCounters.data()), reinterpret_cast<GLuint *>(noInstances.data()), reinterpret_cast<GLuint *>(capsMask.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // intel_performance_query
#endif // GL_INTEL_performance_query
#ifdef GL_KHR_blend_equation_advanced
namespace khr_blend_equation_advanced {
constexpr u32 multiply_khr = 0x9294;
constexpr u32 screen_khr = 0x9295;
constexpr u32 overlay_khr = 0x9296;
constexpr u32 darken_khr = 0x9297;
constexpr u32 lighten_khr = 0x9298;
constexpr u32 colordodge_khr = 0x9299;
constexpr u32 colorburn_khr = 0x929A;
constexpr u32 hardlight_khr = 0x929B;
constexpr u32 softlight_khr = 0x929C;
constexpr u32 difference_khr = 0x929E;
constexpr u32 exclusion_khr = 0x92A0;
constexpr u32 hsl_hue_khr = 0x92AD;
constexpr u32 hsl_saturation_khr = 0x92AE;
constexpr u32 hsl_color_khr = 0x92AF;
constexpr u32 hsl_luminosity_khr = 0x92B0;
STATICINLINE void blend_barrier_khr()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendBarrierKHR)
                Throw(undefined_behavior(
                    "unloaded function BlendBarrierKHR"));
    }
    glBlendBarrierKHR();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // khr_blend_equation_advanced
#endif // GL_KHR_blend_equation_advanced
#ifdef GL_KHR_blend_equation_advanced_coherent
namespace khr_blend_equation_advanced_coherent {
constexpr u32 blend_advanced_coherent_khr = 0x9285;
} // khr_blend_equation_advanced_coherent
#endif // GL_KHR_blend_equation_advanced_coherent
#ifdef GL_KHR_context_flush_control
namespace khr_context_flush_control {
constexpr u32 none = 0;
constexpr u32 context_release_behavior = 0x82FB;
constexpr u32 context_release_behavior_khr = 0x82FB;
constexpr u32 context_release_behavior_flush = 0x82FC;
constexpr u32 context_release_behavior_flush_khr = 0x82FC;
} // khr_context_flush_control
#endif // GL_KHR_context_flush_control
#ifdef GL_KHR_debug
namespace khr_debug {
constexpr u32 context_flag_debug_bit = 0x00000002;
constexpr u32 context_flag_debug_bit_khr = 0x00000002;
constexpr u32 stack_overflow = 0x0503;
constexpr u32 stack_overflow_khr = 0x0503;
constexpr u32 stack_underflow = 0x0504;
constexpr u32 stack_underflow_khr = 0x0504;
constexpr u32 vertex_array = 0x8074;
constexpr u32 vertex_array_khr = 0x8074;
constexpr u32 debug_output_synchronous = 0x8242;
constexpr u32 debug_output_synchronous_khr = 0x8242;
constexpr u32 debug_next_logged_message_length = 0x8243;
constexpr u32 debug_next_logged_message_length_khr = 0x8243;
constexpr u32 debug_callback_function = 0x8244;
constexpr u32 debug_callback_function_khr = 0x8244;
constexpr u32 debug_callback_user_param = 0x8245;
constexpr u32 debug_callback_user_param_khr = 0x8245;
constexpr u32 debug_source_api = 0x8246;
constexpr u32 debug_source_api_khr = 0x8246;
constexpr u32 debug_source_window_system = 0x8247;
constexpr u32 debug_source_window_system_khr = 0x8247;
constexpr u32 debug_source_shader_compiler = 0x8248;
constexpr u32 debug_source_shader_compiler_khr = 0x8248;
constexpr u32 debug_source_third_party = 0x8249;
constexpr u32 debug_source_third_party_khr = 0x8249;
constexpr u32 debug_source_application = 0x824A;
constexpr u32 debug_source_application_khr = 0x824A;
constexpr u32 debug_source_other = 0x824B;
constexpr u32 debug_source_other_khr = 0x824B;
constexpr u32 debug_type_error = 0x824C;
constexpr u32 debug_type_error_khr = 0x824C;
constexpr u32 debug_type_deprecated_behavior = 0x824D;
constexpr u32 debug_type_deprecated_behavior_khr = 0x824D;
constexpr u32 debug_type_undefined_behavior = 0x824E;
constexpr u32 debug_type_undefined_behavior_khr = 0x824E;
constexpr u32 debug_type_portability = 0x824F;
constexpr u32 debug_type_portability_khr = 0x824F;
constexpr u32 debug_type_performance = 0x8250;
constexpr u32 debug_type_performance_khr = 0x8250;
constexpr u32 debug_type_other = 0x8251;
constexpr u32 debug_type_other_khr = 0x8251;
constexpr u32 debug_type_marker = 0x8268;
constexpr u32 debug_type_marker_khr = 0x8268;
constexpr u32 debug_type_push_group = 0x8269;
constexpr u32 debug_type_push_group_khr = 0x8269;
constexpr u32 debug_type_pop_group = 0x826A;
constexpr u32 debug_type_pop_group_khr = 0x826A;
constexpr u32 debug_severity_notification = 0x826B;
constexpr u32 debug_severity_notification_khr = 0x826B;
constexpr u32 max_debug_group_stack_depth = 0x826C;
constexpr u32 max_debug_group_stack_depth_khr = 0x826C;
constexpr u32 debug_group_stack_depth = 0x826D;
constexpr u32 debug_group_stack_depth_khr = 0x826D;
constexpr u32 buffer = 0x82E0;
constexpr u32 buffer_khr = 0x82E0;
constexpr u32 shader = 0x82E1;
constexpr u32 shader_khr = 0x82E1;
constexpr u32 program = 0x82E2;
constexpr u32 program_khr = 0x82E2;
constexpr u32 query = 0x82E3;
constexpr u32 query_khr = 0x82E3;
constexpr u32 program_pipeline = 0x82E4;
constexpr u32 program_pipeline_khr = 0x82E4;
constexpr u32 sampler = 0x82E6;
constexpr u32 sampler_khr = 0x82E6;
constexpr u32 display_list = 0x82E7;
constexpr u32 max_label_length = 0x82E8;
constexpr u32 max_label_length_khr = 0x82E8;
constexpr u32 max_debug_message_length = 0x9143;
constexpr u32 max_debug_message_length_khr = 0x9143;
constexpr u32 max_debug_logged_messages = 0x9144;
constexpr u32 max_debug_logged_messages_khr = 0x9144;
constexpr u32 debug_logged_messages = 0x9145;
constexpr u32 debug_logged_messages_khr = 0x9145;
constexpr u32 debug_severity_high = 0x9146;
constexpr u32 debug_severity_high_khr = 0x9146;
constexpr u32 debug_severity_medium = 0x9147;
constexpr u32 debug_severity_medium_khr = 0x9147;
constexpr u32 debug_severity_low = 0x9148;
constexpr u32 debug_severity_low_khr = 0x9148;
constexpr u32 debug_output = 0x92E0;
constexpr u32 debug_output_khr = 0x92E0;
template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void debug_message_callback(GLDEBUGPROC callback, span_const_byte const& userParam)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDebugMessageCallback)
                Throw(undefined_behavior(
                    "unloaded function DebugMessageCallback"));
    }
    glDebugMessageCallback(callback, reinterpret_cast<const void *>(userParam.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void debug_message_control(groups::debug_source source, groups::debug_type type, groups::debug_severity severity, span_const_u32 const& ids, bool enabled)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDebugMessageControl)
                Throw(undefined_behavior(
                    "unloaded function DebugMessageControl"));
    }
    glDebugMessageControl(static_cast<GLenum>(source), static_cast<GLenum>(type), static_cast<GLenum>(severity), ids.size(), reinterpret_cast<const GLuint *>(ids.data()), enabled);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void debug_message_insert(groups::debug_source source, groups::debug_type type, u32 id, groups::debug_severity severity, i32 length, std::string_view const& buf)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDebugMessageInsert)
                Throw(undefined_behavior(
                    "unloaded function DebugMessageInsert"));
    }
    glDebugMessageInsert(static_cast<GLenum>(source), static_cast<GLenum>(type), id, static_cast<GLenum>(severity), length, buf.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLchar,
    class span_GLenum,
    class span_i32,
    class span_u32
>
requires (
    semantic::concepts::Span<span_GLenum> &&
    std::is_same_v<std::decay_t<typename span_GLenum::value_type>, GLenum> &&
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32> &&
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32> &&
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE GLuint get_debug_message_log(span_GLenum sources, span_GLenum types, span_u32 ids, span_GLenum severities, span_i32 lengths, span_GLchar messageLog)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetDebugMessageLog)
                Throw(undefined_behavior(
                    "unloaded function GetDebugMessageLog"));
    }
    auto out = glGetDebugMessageLog(sources.size(), messageLog.size(), reinterpret_cast<GLenum *>(sources.data()), reinterpret_cast<GLenum *>(types.data()), reinterpret_cast<GLuint *>(ids.data()), reinterpret_cast<GLenum *>(severities.data()), reinterpret_cast<GLsizei *>(lengths.data()), messageLog.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_GLchar
>
requires (
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE void get_object_label(groups::object_identifier identifier, u32 name, i32& length, span_GLchar label)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetObjectLabel)
                Throw(undefined_behavior(
                    "unloaded function GetObjectLabel"));
    }
    glGetObjectLabel(static_cast<GLenum>(identifier), name, label.size(), &length, label.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLchar,
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte> &&
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE void get_object_ptr_label(span_const_byte const& ptr, i32& length, span_GLchar label)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetObjectPtrLabel)
                Throw(undefined_behavior(
                    "unloaded function GetObjectPtrLabel"));
    }
    glGetObjectPtrLabel(reinterpret_cast<const void *>(ptr.data()), label.size(), &length, label.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_pointerv(groups::get_pointerv_prop pname, span_byte params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPointerv)
                Throw(undefined_behavior(
                    "unloaded function GetPointerv"));
    }
    glGetPointerv(static_cast<GLenum>(pname), reinterpret_cast<void **>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void object_label(groups::object_identifier identifier, u32 name, i32 length, std::string_view const& label)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glObjectLabel)
                Throw(undefined_behavior(
                    "unloaded function ObjectLabel"));
    }
    glObjectLabel(static_cast<GLenum>(identifier), name, length, label.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void object_ptr_label(span_const_byte const& ptr, i32 length, std::string_view const& label)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glObjectPtrLabel)
                Throw(undefined_behavior(
                    "unloaded function ObjectPtrLabel"));
    }
    glObjectPtrLabel(reinterpret_cast<const void *>(ptr.data()), length, label.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void pop_debug_group()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPopDebugGroup)
                Throw(undefined_behavior(
                    "unloaded function PopDebugGroup"));
    }
    glPopDebugGroup();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void push_debug_group(groups::debug_source source, u32 id, i32 length, std::string_view const& message)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPushDebugGroup)
                Throw(undefined_behavior(
                    "unloaded function PushDebugGroup"));
    }
    glPushDebugGroup(static_cast<GLenum>(source), id, length, message.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void debug_message_callback_khr(GLDEBUGPROCKHR callback, span_const_byte const& userParam)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDebugMessageCallbackKHR)
                Throw(undefined_behavior(
                    "unloaded function DebugMessageCallbackKHR"));
    }
    glDebugMessageCallbackKHR(callback, reinterpret_cast<const void *>(userParam.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void debug_message_control_khr(groups::debug_source source, groups::debug_type type, groups::debug_severity severity, i32 count, span_const_u32 const& ids, bool enabled)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDebugMessageControlKHR)
                Throw(undefined_behavior(
                    "unloaded function DebugMessageControlKHR"));
    }
    glDebugMessageControlKHR(static_cast<GLenum>(source), static_cast<GLenum>(type), static_cast<GLenum>(severity), count, reinterpret_cast<const GLuint *>(ids.data()), enabled);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void debug_message_insert_khr(groups::debug_source source, groups::debug_type type, u32 id, groups::debug_severity severity, i32 length, std::string_view const& buf)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDebugMessageInsertKHR)
                Throw(undefined_behavior(
                    "unloaded function DebugMessageInsertKHR"));
    }
    glDebugMessageInsertKHR(static_cast<GLenum>(source), static_cast<GLenum>(type), id, static_cast<GLenum>(severity), length, buf.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLchar,
    class span_GLenum,
    class span_i32,
    class span_u32
>
requires (
    semantic::concepts::Span<span_GLenum> &&
    std::is_same_v<std::decay_t<typename span_GLenum::value_type>, GLenum> &&
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32> &&
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32> &&
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE GLuint get_debug_message_log_khr(span_GLenum sources, span_GLenum types, span_u32 ids, span_GLenum severities, span_i32 lengths, span_GLchar messageLog)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetDebugMessageLogKHR)
                Throw(undefined_behavior(
                    "unloaded function GetDebugMessageLogKHR"));
    }
    auto out = glGetDebugMessageLogKHR(sources.size(), messageLog.size(), reinterpret_cast<GLenum *>(sources.data()), reinterpret_cast<GLenum *>(types.data()), reinterpret_cast<GLuint *>(ids.data()), reinterpret_cast<GLenum *>(severities.data()), reinterpret_cast<GLsizei *>(lengths.data()), messageLog.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_GLchar,
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32> &&
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE void get_object_label_khr(GLenum identifier, u32 name, span_i32 length, span_GLchar label)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetObjectLabelKHR)
                Throw(undefined_behavior(
                    "unloaded function GetObjectLabelKHR"));
    }
    glGetObjectLabelKHR(identifier, name, label.size(), reinterpret_cast<GLsizei *>(length.data()), label.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLchar,
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte> &&
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE void get_object_ptr_label_khr(span_const_byte const& ptr, i32& length, span_GLchar label)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetObjectPtrLabelKHR)
                Throw(undefined_behavior(
                    "unloaded function GetObjectPtrLabelKHR"));
    }
    glGetObjectPtrLabelKHR(reinterpret_cast<const void *>(ptr.data()), label.size(), &length, label.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_pointerv_khr(GLenum pname, span_byte params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPointervKHR)
                Throw(undefined_behavior(
                    "unloaded function GetPointervKHR"));
    }
    glGetPointervKHR(pname, reinterpret_cast<void **>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void object_label_khr(groups::object_identifier identifier, u32 name, i32 length, std::string_view const& label)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glObjectLabelKHR)
                Throw(undefined_behavior(
                    "unloaded function ObjectLabelKHR"));
    }
    glObjectLabelKHR(static_cast<GLenum>(identifier), name, length, label.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void object_ptr_label_khr(span_const_byte const& ptr, i32 length, std::string_view const& label)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glObjectPtrLabelKHR)
                Throw(undefined_behavior(
                    "unloaded function ObjectPtrLabelKHR"));
    }
    glObjectPtrLabelKHR(reinterpret_cast<const void *>(ptr.data()), length, label.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void pop_debug_group_khr()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPopDebugGroupKHR)
                Throw(undefined_behavior(
                    "unloaded function PopDebugGroupKHR"));
    }
    glPopDebugGroupKHR();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void push_debug_group_khr(groups::debug_source source, u32 id, i32 length, std::string_view const& message)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPushDebugGroupKHR)
                Throw(undefined_behavior(
                    "unloaded function PushDebugGroupKHR"));
    }
    glPushDebugGroupKHR(static_cast<GLenum>(source), id, length, message.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // khr_debug
#endif // GL_KHR_debug
#ifdef GL_KHR_no_error
namespace khr_no_error {
constexpr u32 context_flag_no_error_bit_khr = 0x00000008;
} // khr_no_error
#endif // GL_KHR_no_error
#ifdef GL_KHR_robust_buffer_access_behavior
namespace khr_robust_buffer_access_behavior {
} // khr_robust_buffer_access_behavior
#endif // GL_KHR_robust_buffer_access_behavior
#ifdef GL_KHR_robustness
namespace khr_robustness {
constexpr u32 no_error = 0;
constexpr u32 context_lost = 0x0507;
constexpr u32 context_lost_khr = 0x0507;
constexpr u32 lose_context_on_reset = 0x8252;
constexpr u32 lose_context_on_reset_khr = 0x8252;
constexpr u32 guilty_context_reset = 0x8253;
constexpr u32 guilty_context_reset_khr = 0x8253;
constexpr u32 innocent_context_reset = 0x8254;
constexpr u32 innocent_context_reset_khr = 0x8254;
constexpr u32 unknown_context_reset = 0x8255;
constexpr u32 unknown_context_reset_khr = 0x8255;
constexpr u32 reset_notification_strategy = 0x8256;
constexpr u32 reset_notification_strategy_khr = 0x8256;
constexpr u32 no_reset_notification = 0x8261;
constexpr u32 no_reset_notification_khr = 0x8261;
constexpr u32 context_robust_access = 0x90F3;
constexpr u32 context_robust_access_khr = 0x90F3;
STATICINLINE GLenum get_graphics_reset_status()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetGraphicsResetStatus)
                Throw(undefined_behavior(
                    "unloaded function GetGraphicsResetStatus"));
    }
    auto out = glGetGraphicsResetStatus();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void getn_uniformfv(u32 program, i32 location, i32 bufSize, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnUniformfv)
                Throw(undefined_behavior(
                    "unloaded function GetnUniformfv"));
        glIsProgram(program);
    }
    glGetnUniformfv(program, location, bufSize, reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void getn_uniformiv(u32 program, i32 location, i32 bufSize, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnUniformiv)
                Throw(undefined_behavior(
                    "unloaded function GetnUniformiv"));
        glIsProgram(program);
    }
    glGetnUniformiv(program, location, bufSize, reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void getn_uniformuiv(u32 program, i32 location, i32 bufSize, span_u32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnUniformuiv)
                Throw(undefined_behavior(
                    "unloaded function GetnUniformuiv"));
        glIsProgram(program);
    }
    glGetnUniformuiv(program, location, bufSize, reinterpret_cast<GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte,
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2> &&
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void readn_pixels(vec_2_i32 const& x, vec_2_i32 const& width, groups::pixel_format format, groups::pixel_type type, span_byte data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glReadnPixels)
                Throw(undefined_behavior(
                    "unloaded function ReadnPixels"));
    }
    glReadnPixels(x.x(), x.y(), width[0], width[1], static_cast<GLenum>(format), static_cast<GLenum>(type), data.size(), reinterpret_cast<void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLenum get_graphics_reset_status_khr()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetGraphicsResetStatusKHR)
                Throw(undefined_behavior(
                    "unloaded function GetGraphicsResetStatusKHR"));
    }
    auto out = glGetGraphicsResetStatusKHR();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void getn_uniformfv_khr(u32 program, i32 location, i32 bufSize, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnUniformfvKHR)
                Throw(undefined_behavior(
                    "unloaded function GetnUniformfvKHR"));
        glIsProgram(program);
    }
    glGetnUniformfvKHR(program, location, bufSize, reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void getn_uniformiv_khr(u32 program, i32 location, i32 bufSize, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnUniformivKHR)
                Throw(undefined_behavior(
                    "unloaded function GetnUniformivKHR"));
        glIsProgram(program);
    }
    glGetnUniformivKHR(program, location, bufSize, reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void getn_uniformuiv_khr(u32 program, i32 location, i32 bufSize, span_u32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetnUniformuivKHR)
                Throw(undefined_behavior(
                    "unloaded function GetnUniformuivKHR"));
        glIsProgram(program);
    }
    glGetnUniformuivKHR(program, location, bufSize, reinterpret_cast<GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte,
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2> &&
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void readn_pixels_khr(vec_2_i32 const& x, vec_2_i32 const& width, groups::pixel_format format, groups::pixel_type type, span_byte data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glReadnPixelsKHR)
                Throw(undefined_behavior(
                    "unloaded function ReadnPixelsKHR"));
    }
    glReadnPixelsKHR(x.x(), x.y(), width[0], width[1], static_cast<GLenum>(format), static_cast<GLenum>(type), data.size(), reinterpret_cast<void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // khr_robustness
#endif // GL_KHR_robustness
#ifdef GL_KHR_shader_subgroup
namespace khr_shader_subgroup {
constexpr u32 subgroup_feature_basic_bit_khr = 0x00000001;
constexpr u32 subgroup_feature_vote_bit_khr = 0x00000002;
constexpr u32 subgroup_feature_arithmetic_bit_khr = 0x00000004;
constexpr u32 subgroup_feature_ballot_bit_khr = 0x00000008;
constexpr u32 subgroup_feature_shuffle_bit_khr = 0x00000010;
constexpr u32 subgroup_feature_shuffle_relative_bit_khr = 0x00000020;
constexpr u32 subgroup_feature_clustered_bit_khr = 0x00000040;
constexpr u32 subgroup_feature_quad_bit_khr = 0x00000080;
constexpr u32 subgroup_size_khr = 0x9532;
constexpr u32 subgroup_supported_stages_khr = 0x9533;
constexpr u32 subgroup_supported_features_khr = 0x9534;
constexpr u32 subgroup_quad_all_stages_khr = 0x9535;
} // khr_shader_subgroup
#endif // GL_KHR_shader_subgroup
#ifdef GL_KHR_texture_compression_astc_hdr
namespace khr_texture_compression_astc_hdr {
constexpr u32 compressed_rgba_astc_4x4_khr = 0x93B0;
constexpr u32 compressed_rgba_astc_5x4_khr = 0x93B1;
constexpr u32 compressed_rgba_astc_5x5_khr = 0x93B2;
constexpr u32 compressed_rgba_astc_6x5_khr = 0x93B3;
constexpr u32 compressed_rgba_astc_6x6_khr = 0x93B4;
constexpr u32 compressed_rgba_astc_8x5_khr = 0x93B5;
constexpr u32 compressed_rgba_astc_8x6_khr = 0x93B6;
constexpr u32 compressed_rgba_astc_8x8_khr = 0x93B7;
constexpr u32 compressed_rgba_astc_10x5_khr = 0x93B8;
constexpr u32 compressed_rgba_astc_10x6_khr = 0x93B9;
constexpr u32 compressed_rgba_astc_10x8_khr = 0x93BA;
constexpr u32 compressed_rgba_astc_10x10_khr = 0x93BB;
constexpr u32 compressed_rgba_astc_12x10_khr = 0x93BC;
constexpr u32 compressed_rgba_astc_12x12_khr = 0x93BD;
constexpr u32 compressed_srgb8_alpha8_astc_4x4_khr = 0x93D0;
constexpr u32 compressed_srgb8_alpha8_astc_5x4_khr = 0x93D1;
constexpr u32 compressed_srgb8_alpha8_astc_5x5_khr = 0x93D2;
constexpr u32 compressed_srgb8_alpha8_astc_6x5_khr = 0x93D3;
constexpr u32 compressed_srgb8_alpha8_astc_6x6_khr = 0x93D4;
constexpr u32 compressed_srgb8_alpha8_astc_8x5_khr = 0x93D5;
constexpr u32 compressed_srgb8_alpha8_astc_8x6_khr = 0x93D6;
constexpr u32 compressed_srgb8_alpha8_astc_8x8_khr = 0x93D7;
constexpr u32 compressed_srgb8_alpha8_astc_10x5_khr = 0x93D8;
constexpr u32 compressed_srgb8_alpha8_astc_10x6_khr = 0x93D9;
constexpr u32 compressed_srgb8_alpha8_astc_10x8_khr = 0x93DA;
constexpr u32 compressed_srgb8_alpha8_astc_10x10_khr = 0x93DB;
constexpr u32 compressed_srgb8_alpha8_astc_12x10_khr = 0x93DC;
constexpr u32 compressed_srgb8_alpha8_astc_12x12_khr = 0x93DD;
} // khr_texture_compression_astc_hdr
#endif // GL_KHR_texture_compression_astc_hdr
#ifdef GL_KHR_texture_compression_astc_ldr
namespace khr_texture_compression_astc_ldr {
constexpr u32 compressed_rgba_astc_4x4_khr = 0x93B0;
constexpr u32 compressed_rgba_astc_5x4_khr = 0x93B1;
constexpr u32 compressed_rgba_astc_5x5_khr = 0x93B2;
constexpr u32 compressed_rgba_astc_6x5_khr = 0x93B3;
constexpr u32 compressed_rgba_astc_6x6_khr = 0x93B4;
constexpr u32 compressed_rgba_astc_8x5_khr = 0x93B5;
constexpr u32 compressed_rgba_astc_8x6_khr = 0x93B6;
constexpr u32 compressed_rgba_astc_8x8_khr = 0x93B7;
constexpr u32 compressed_rgba_astc_10x5_khr = 0x93B8;
constexpr u32 compressed_rgba_astc_10x6_khr = 0x93B9;
constexpr u32 compressed_rgba_astc_10x8_khr = 0x93BA;
constexpr u32 compressed_rgba_astc_10x10_khr = 0x93BB;
constexpr u32 compressed_rgba_astc_12x10_khr = 0x93BC;
constexpr u32 compressed_rgba_astc_12x12_khr = 0x93BD;
constexpr u32 compressed_srgb8_alpha8_astc_4x4_khr = 0x93D0;
constexpr u32 compressed_srgb8_alpha8_astc_5x4_khr = 0x93D1;
constexpr u32 compressed_srgb8_alpha8_astc_5x5_khr = 0x93D2;
constexpr u32 compressed_srgb8_alpha8_astc_6x5_khr = 0x93D3;
constexpr u32 compressed_srgb8_alpha8_astc_6x6_khr = 0x93D4;
constexpr u32 compressed_srgb8_alpha8_astc_8x5_khr = 0x93D5;
constexpr u32 compressed_srgb8_alpha8_astc_8x6_khr = 0x93D6;
constexpr u32 compressed_srgb8_alpha8_astc_8x8_khr = 0x93D7;
constexpr u32 compressed_srgb8_alpha8_astc_10x5_khr = 0x93D8;
constexpr u32 compressed_srgb8_alpha8_astc_10x6_khr = 0x93D9;
constexpr u32 compressed_srgb8_alpha8_astc_10x8_khr = 0x93DA;
constexpr u32 compressed_srgb8_alpha8_astc_10x10_khr = 0x93DB;
constexpr u32 compressed_srgb8_alpha8_astc_12x10_khr = 0x93DC;
constexpr u32 compressed_srgb8_alpha8_astc_12x12_khr = 0x93DD;
} // khr_texture_compression_astc_ldr
#endif // GL_KHR_texture_compression_astc_ldr
#ifdef GL_KHR_texture_compression_astc_sliced_3d
namespace khr_texture_compression_astc_sliced_3d {
} // khr_texture_compression_astc_sliced_3d
#endif // GL_KHR_texture_compression_astc_sliced_3d
#ifdef GL_KHR_parallel_shader_compile
namespace khr_parallel_shader_compile {
constexpr u32 max_shader_compiler_threads_khr = 0x91B0;
constexpr u32 completion_status_khr = 0x91B1;
STATICINLINE void max_shader_compiler_threads_khr(u32 count)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMaxShaderCompilerThreadsKHR)
                Throw(undefined_behavior(
                    "unloaded function MaxShaderCompilerThreadsKHR"));
    }
    glMaxShaderCompilerThreadsKHR(count);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // khr_parallel_shader_compile
#endif // GL_KHR_parallel_shader_compile
#ifdef GL_NVX_blend_equation_advanced_multi_draw_buffers
namespace nvx_blend_equation_advanced_multi_draw_buffers {
} // nvx_blend_equation_advanced_multi_draw_buffers
#endif // GL_NVX_blend_equation_advanced_multi_draw_buffers
#ifdef GL_NVX_conditional_render
namespace nvx_conditional_render {
STATICINLINE void begin_conditional_render_nvx(u32 id)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBeginConditionalRenderNVX)
                Throw(undefined_behavior(
                    "unloaded function BeginConditionalRenderNVX"));
    }
    glBeginConditionalRenderNVX(id);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void end_conditional_render_nvx()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEndConditionalRenderNVX)
                Throw(undefined_behavior(
                    "unloaded function EndConditionalRenderNVX"));
    }
    glEndConditionalRenderNVX();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nvx_conditional_render
#endif // GL_NVX_conditional_render
#ifdef GL_NVX_gpu_memory_info
namespace nvx_gpu_memory_info {
constexpr u32 gpu_memory_info_dedicated_vidmem_nvx = 0x9047;
constexpr u32 gpu_memory_info_total_available_memory_nvx = 0x9048;
constexpr u32 gpu_memory_info_current_available_vidmem_nvx = 0x9049;
constexpr u32 gpu_memory_info_eviction_count_nvx = 0x904A;
constexpr u32 gpu_memory_info_evicted_memory_nvx = 0x904B;
} // nvx_gpu_memory_info
#endif // GL_NVX_gpu_memory_info
#ifdef GL_NVX_linked_gpu_multicast
namespace nvx_linked_gpu_multicast {
constexpr u32 lgpu_separate_storage_bit_nvx = 0x0800;
constexpr u32 max_lgpu_gpus_nvx = 0x92BA;
template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void lgpu_copy_image_sub_data_nvx(u32 sourceGpu, GLbitfield destinationGpuMask, u32 srcName, GLenum srcTarget, i32 srcLevel, i32 srcX, i32 srxY, i32 srcZ, u32 dstName, GLenum dstTarget, i32 dstLevel, i32 dstX, i32 dstY, i32 dstZ, vec_3_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glLGPUCopyImageSubDataNVX)
                Throw(undefined_behavior(
                    "unloaded function LGPUCopyImageSubDataNVX"));
    }
    glLGPUCopyImageSubDataNVX(sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width[0], width[1], width[2]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void lgpu_interlock_nvx()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glLGPUInterlockNVX)
                Throw(undefined_behavior(
                    "unloaded function LGPUInterlockNVX"));
    }
    glLGPUInterlockNVX();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void lgpu_named_buffer_sub_data_nvx(GLbitfield gpuMask, u32 buffer, GLintptr offset, GLsizeiptr size, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glLGPUNamedBufferSubDataNVX)
                Throw(undefined_behavior(
                    "unloaded function LGPUNamedBufferSubDataNVX"));
        glIsBuffer(buffer);
    }
    glLGPUNamedBufferSubDataNVX(gpuMask, buffer, offset, size, reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nvx_linked_gpu_multicast
#endif // GL_NVX_linked_gpu_multicast
#ifdef GL_NV_alpha_to_coverage_dither_control
namespace nv_alpha_to_coverage_dither_control {
constexpr u32 alpha_to_coverage_dither_mode_nv = 0x92BF;
constexpr u32 alpha_to_coverage_dither_default_nv = 0x934D;
constexpr u32 alpha_to_coverage_dither_enable_nv = 0x934E;
constexpr u32 alpha_to_coverage_dither_disable_nv = 0x934F;
STATICINLINE void alpha_to_coverage_dither_control_nv(GLenum mode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glAlphaToCoverageDitherControlNV)
                Throw(undefined_behavior(
                    "unloaded function AlphaToCoverageDitherControlNV"));
    }
    glAlphaToCoverageDitherControlNV(mode);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_alpha_to_coverage_dither_control
#endif // GL_NV_alpha_to_coverage_dither_control
#ifdef GL_NV_bindless_multi_draw_indirect
namespace nv_bindless_multi_draw_indirect {
STATICINLINE void multi_draw_arrays_indirect_bindless_nv(groups::primitive_type mode, ptroff indirect, i32 drawCount, i32 stride, i32 vertexBufferCount)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiDrawArraysIndirectBindlessNV)
                Throw(undefined_behavior(
                    "unloaded function MultiDrawArraysIndirectBindlessNV"));
    }
    glMultiDrawArraysIndirectBindlessNV(static_cast<GLenum>(mode), reinterpret_cast<const void*>(indirect), drawCount, stride, vertexBufferCount);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_draw_elements_indirect_bindless_nv(groups::primitive_type mode, groups::draw_elements_type type, ptroff indirect, i32 drawCount, i32 stride, i32 vertexBufferCount)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiDrawElementsIndirectBindlessNV)
                Throw(undefined_behavior(
                    "unloaded function MultiDrawElementsIndirectBindlessNV"));
    }
    glMultiDrawElementsIndirectBindlessNV(static_cast<GLenum>(mode), static_cast<GLenum>(type), reinterpret_cast<const void*>(indirect), drawCount, stride, vertexBufferCount);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_bindless_multi_draw_indirect
#endif // GL_NV_bindless_multi_draw_indirect
#ifdef GL_NV_bindless_multi_draw_indirect_count
namespace nv_bindless_multi_draw_indirect_count {
STATICINLINE void multi_draw_arrays_indirect_bindless_count_nv(groups::primitive_type mode, ptroff indirect, i32 drawCount, i32 maxDrawCount, i32 stride, i32 vertexBufferCount)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiDrawArraysIndirectBindlessCountNV)
                Throw(undefined_behavior(
                    "unloaded function MultiDrawArraysIndirectBindlessCountNV"));
    }
    glMultiDrawArraysIndirectBindlessCountNV(static_cast<GLenum>(mode), reinterpret_cast<const void*>(indirect), drawCount, maxDrawCount, stride, vertexBufferCount);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_draw_elements_indirect_bindless_count_nv(groups::primitive_type mode, groups::draw_elements_type type, ptroff indirect, i32 drawCount, i32 maxDrawCount, i32 stride, i32 vertexBufferCount)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiDrawElementsIndirectBindlessCountNV)
                Throw(undefined_behavior(
                    "unloaded function MultiDrawElementsIndirectBindlessCountNV"));
    }
    glMultiDrawElementsIndirectBindlessCountNV(static_cast<GLenum>(mode), static_cast<GLenum>(type), reinterpret_cast<const void*>(indirect), drawCount, maxDrawCount, stride, vertexBufferCount);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_bindless_multi_draw_indirect_count
#endif // GL_NV_bindless_multi_draw_indirect_count
#ifdef GL_NV_bindless_texture
namespace nv_bindless_texture {
STATICINLINE GLuint64 get_image_handle_nv(u32 texture, i32 level, bool layered, i32 layer, groups::pixel_format format)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetImageHandleNV)
                Throw(undefined_behavior(
                    "unloaded function GetImageHandleNV"));
        glIsTexture(texture);
    }
    auto out = glGetImageHandleNV(texture, level, layered, layer, static_cast<GLenum>(format));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLuint64 get_texture_handle_nv(u32 texture)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTextureHandleNV)
                Throw(undefined_behavior(
                    "unloaded function GetTextureHandleNV"));
        glIsTexture(texture);
    }
    auto out = glGetTextureHandleNV(texture);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLuint64 get_texture_sampler_handle_nv(u32 texture, u32 sampler)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTextureSamplerHandleNV)
                Throw(undefined_behavior(
                    "unloaded function GetTextureSamplerHandleNV"));
        glIsTexture(texture);
        glIsSampler(sampler);
    }
    auto out = glGetTextureSamplerHandleNV(texture, sampler);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLboolean is_image_handle_resident_nv(u64 handle)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsImageHandleResidentNV)
                Throw(undefined_behavior(
                    "unloaded function IsImageHandleResidentNV"));
    }
    auto out = glIsImageHandleResidentNV(handle);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLboolean is_texture_handle_resident_nv(u64 handle)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsTextureHandleResidentNV)
                Throw(undefined_behavior(
                    "unloaded function IsTextureHandleResidentNV"));
    }
    auto out = glIsTextureHandleResidentNV(handle);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void make_image_handle_non_resident_nv(u64 handle)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMakeImageHandleNonResidentNV)
                Throw(undefined_behavior(
                    "unloaded function MakeImageHandleNonResidentNV"));
    }
    glMakeImageHandleNonResidentNV(handle);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void make_image_handle_resident_nv(u64 handle, GLenum access)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMakeImageHandleResidentNV)
                Throw(undefined_behavior(
                    "unloaded function MakeImageHandleResidentNV"));
    }
    glMakeImageHandleResidentNV(handle, access);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void make_texture_handle_non_resident_nv(u64 handle)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMakeTextureHandleNonResidentNV)
                Throw(undefined_behavior(
                    "unloaded function MakeTextureHandleNonResidentNV"));
    }
    glMakeTextureHandleNonResidentNV(handle);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void make_texture_handle_resident_nv(u64 handle)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMakeTextureHandleResidentNV)
                Throw(undefined_behavior(
                    "unloaded function MakeTextureHandleResidentNV"));
    }
    glMakeTextureHandleResidentNV(handle);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void program_uniform_handle(u32 program, i32 location, u64 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformHandleui64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformHandleui64NV"));
        glIsProgram(program);
    }
    glProgramUniformHandleui64NV(program, location, value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u64
>
requires (
    semantic::concepts::Span<span_const_u64> &&
    std::is_same_v<std::decay_t<typename span_const_u64::value_type>, u64>)
STATICINLINE void program_uniform_handle(u32 program, i32 location, span_const_u64 const& values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformHandleui64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformHandleui64vNV"));
        glIsProgram(program);
    }
    glProgramUniformHandleui64vNV(program, location, values.size(), reinterpret_cast<const GLuint64 *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void uniform_handle(i32 location, u64 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformHandleui64NV)
                Throw(undefined_behavior(
                    "unloaded function UniformHandleui64NV"));
    }
    glUniformHandleui64NV(location, value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u64
>
requires (
    semantic::concepts::Span<span_const_u64> &&
    std::is_same_v<std::decay_t<typename span_const_u64::value_type>, u64>)
STATICINLINE void uniform_handle(i32 location, span_const_u64 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformHandleui64vNV)
                Throw(undefined_behavior(
                    "unloaded function UniformHandleui64vNV"));
    }
    glUniformHandleui64vNV(location, value.size(), reinterpret_cast<const GLuint64 *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_bindless_texture
#endif // GL_NV_bindless_texture
#ifdef GL_NV_blend_equation_advanced
namespace nv_blend_equation_advanced {
constexpr u32 zero = 0;
constexpr u32 xor_nv = 0x1506;
constexpr u32 invert = 0x150A;
constexpr u32 red_nv = 0x1903;
constexpr u32 green_nv = 0x1904;
constexpr u32 blue_nv = 0x1905;
constexpr u32 blend_premultiplied_src_nv = 0x9280;
constexpr u32 blend_overlap_nv = 0x9281;
constexpr u32 uncorrelated_nv = 0x9282;
constexpr u32 disjoint_nv = 0x9283;
constexpr u32 conjoint_nv = 0x9284;
constexpr u32 src_nv = 0x9286;
constexpr u32 dst_nv = 0x9287;
constexpr u32 src_over_nv = 0x9288;
constexpr u32 dst_over_nv = 0x9289;
constexpr u32 src_in_nv = 0x928A;
constexpr u32 dst_in_nv = 0x928B;
constexpr u32 src_out_nv = 0x928C;
constexpr u32 dst_out_nv = 0x928D;
constexpr u32 src_atop_nv = 0x928E;
constexpr u32 dst_atop_nv = 0x928F;
constexpr u32 plus_nv = 0x9291;
constexpr u32 plus_darker_nv = 0x9292;
constexpr u32 multiply_nv = 0x9294;
constexpr u32 screen_nv = 0x9295;
constexpr u32 overlay_nv = 0x9296;
constexpr u32 darken_nv = 0x9297;
constexpr u32 lighten_nv = 0x9298;
constexpr u32 colordodge_nv = 0x9299;
constexpr u32 colorburn_nv = 0x929A;
constexpr u32 hardlight_nv = 0x929B;
constexpr u32 softlight_nv = 0x929C;
constexpr u32 difference_nv = 0x929E;
constexpr u32 minus_nv = 0x929F;
constexpr u32 exclusion_nv = 0x92A0;
constexpr u32 contrast_nv = 0x92A1;
constexpr u32 invert_rgb_nv = 0x92A3;
constexpr u32 lineardodge_nv = 0x92A4;
constexpr u32 linearburn_nv = 0x92A5;
constexpr u32 vividlight_nv = 0x92A6;
constexpr u32 linearlight_nv = 0x92A7;
constexpr u32 pinlight_nv = 0x92A8;
constexpr u32 hardmix_nv = 0x92A9;
constexpr u32 hsl_hue_nv = 0x92AD;
constexpr u32 hsl_saturation_nv = 0x92AE;
constexpr u32 hsl_color_nv = 0x92AF;
constexpr u32 hsl_luminosity_nv = 0x92B0;
constexpr u32 plus_clamped_nv = 0x92B1;
constexpr u32 plus_clamped_alpha_nv = 0x92B2;
constexpr u32 minus_clamped_nv = 0x92B3;
constexpr u32 invert_ovg_nv = 0x92B4;
STATICINLINE void blend_barrier_nv()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendBarrierNV)
                Throw(undefined_behavior(
                    "unloaded function BlendBarrierNV"));
    }
    glBlendBarrierNV();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void blend_parameteri_nv(GLenum pname, i32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendParameteriNV)
                Throw(undefined_behavior(
                    "unloaded function BlendParameteriNV"));
    }
    glBlendParameteriNV(pname, value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_blend_equation_advanced
#endif // GL_NV_blend_equation_advanced
#ifdef GL_NV_blend_equation_advanced_coherent
namespace nv_blend_equation_advanced_coherent {
constexpr u32 blend_advanced_coherent_nv = 0x9285;
} // nv_blend_equation_advanced_coherent
#endif // GL_NV_blend_equation_advanced_coherent
#ifdef GL_NV_blend_minmax_factor
namespace nv_blend_minmax_factor {
constexpr u32 factor_min_amd = 0x901C;
constexpr u32 factor_max_amd = 0x901D;
} // nv_blend_minmax_factor
#endif // GL_NV_blend_minmax_factor
#ifdef GL_NV_blend_square
namespace nv_blend_square {
} // nv_blend_square
#endif // GL_NV_blend_square
#ifdef GL_NV_clip_space_w_scaling
namespace nv_clip_space_w_scaling {
constexpr u32 viewport_position_w_scale_nv = 0x937C;
constexpr u32 viewport_position_w_scale_x_coeff_nv = 0x937D;
constexpr u32 viewport_position_w_scale_y_coeff_nv = 0x937E;
STATICINLINE void viewport_position_w_scale_nv(u32 index, f32 xcoeff, f32 ycoeff)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glViewportPositionWScaleNV)
                Throw(undefined_behavior(
                    "unloaded function ViewportPositionWScaleNV"));
    }
    glViewportPositionWScaleNV(index, xcoeff, ycoeff);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_clip_space_w_scaling
#endif // GL_NV_clip_space_w_scaling
#ifdef GL_NV_command_list
namespace nv_command_list {
constexpr u32 terminate_sequence_command_nv = 0x0000;
constexpr u32 nop_command_nv = 0x0001;
constexpr u32 draw_elements_command_nv = 0x0002;
constexpr u32 draw_arrays_command_nv = 0x0003;
constexpr u32 draw_elements_strip_command_nv = 0x0004;
constexpr u32 draw_arrays_strip_command_nv = 0x0005;
constexpr u32 draw_elements_instanced_command_nv = 0x0006;
constexpr u32 draw_arrays_instanced_command_nv = 0x0007;
constexpr u32 element_address_command_nv = 0x0008;
constexpr u32 attribute_address_command_nv = 0x0009;
constexpr u32 uniform_address_command_nv = 0x000A;
constexpr u32 blend_color_command_nv = 0x000B;
constexpr u32 stencil_ref_command_nv = 0x000C;
constexpr u32 line_width_command_nv = 0x000D;
constexpr u32 polygon_offset_command_nv = 0x000E;
constexpr u32 alpha_ref_command_nv = 0x000F;
constexpr u32 viewport_command_nv = 0x0010;
constexpr u32 scissor_command_nv = 0x0011;
constexpr u32 front_face_command_nv = 0x0012;
STATICINLINE void call_command_list_nv(u32 list)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCallCommandListNV)
                Throw(undefined_behavior(
                    "unloaded function CallCommandListNV"));
    }
    glCallCommandListNV(list);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void command_list_segments_nv(u32 list, u32 segments)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCommandListSegmentsNV)
                Throw(undefined_behavior(
                    "unloaded function CommandListSegmentsNV"));
    }
    glCommandListSegmentsNV(list, segments);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void compile_command_list_nv(u32 list)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCompileCommandListNV)
                Throw(undefined_behavior(
                    "unloaded function CompileCommandListNV"));
    }
    glCompileCommandListNV(list);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void create_command_lists_nv(span_u32 lists)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreateCommandListsNV)
                Throw(undefined_behavior(
                    "unloaded function CreateCommandListsNV"));
    }
    glCreateCommandListsNV(lists.size(), reinterpret_cast<GLuint *>(lists.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void create_states_nv(span_u32 states)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreateStatesNV)
                Throw(undefined_behavior(
                    "unloaded function CreateStatesNV"));
    }
    glCreateStatesNV(states.size(), reinterpret_cast<GLuint *>(states.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_command_lists_nv(span_const_u32 const& lists)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteCommandListsNV)
                Throw(undefined_behavior(
                    "unloaded function DeleteCommandListsNV"));
    }
    glDeleteCommandListsNV(lists.size(), reinterpret_cast<const GLuint *>(lists.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_states_nv(span_const_u32 const& states)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteStatesNV)
                Throw(undefined_behavior(
                    "unloaded function DeleteStatesNV"));
    }
    glDeleteStatesNV(states.size(), reinterpret_cast<const GLuint *>(states.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32,
    class span_const_u64
>
requires (
    semantic::concepts::Span<span_const_u64> &&
    std::is_same_v<std::decay_t<typename span_const_u64::value_type>, u64> &&
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void draw_commands_address_nv(GLenum primitiveMode, span_const_u64 const& indirects, span_const_i32 const& sizes, u32 count)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawCommandsAddressNV)
                Throw(undefined_behavior(
                    "unloaded function DrawCommandsAddressNV"));
    }
    glDrawCommandsAddressNV(primitiveMode, reinterpret_cast<const GLuint64 *>(indirects.data()), reinterpret_cast<const GLsizei *>(sizes.data()), count);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLintptr,
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_GLintptr> &&
    std::is_same_v<std::decay_t<typename span_const_GLintptr::value_type>, GLintptr> &&
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void draw_commands_nv(GLenum primitiveMode, u32 buffer, span_const_GLintptr const& indirects, span_const_i32 const& sizes, u32 count)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawCommandsNV)
                Throw(undefined_behavior(
                    "unloaded function DrawCommandsNV"));
        glIsBuffer(buffer);
    }
    glDrawCommandsNV(primitiveMode, buffer, reinterpret_cast<const GLintptr *>(indirects.data()), reinterpret_cast<const GLsizei *>(sizes.data()), count);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32,
    class span_const_u32,
    class span_const_u64
>
requires (
    semantic::concepts::Span<span_const_u64> &&
    std::is_same_v<std::decay_t<typename span_const_u64::value_type>, u64> &&
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32> &&
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void draw_commands_states_address_nv(span_const_u64 const& indirects, span_const_i32 const& sizes, span_const_u32 const& states, span_const_u32 const& fbos, u32 count)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawCommandsStatesAddressNV)
                Throw(undefined_behavior(
                    "unloaded function DrawCommandsStatesAddressNV"));
    }
    glDrawCommandsStatesAddressNV(reinterpret_cast<const GLuint64 *>(indirects.data()), reinterpret_cast<const GLsizei *>(sizes.data()), reinterpret_cast<const GLuint *>(states.data()), reinterpret_cast<const GLuint *>(fbos.data()), count);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLintptr,
    class span_const_i32,
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_GLintptr> &&
    std::is_same_v<std::decay_t<typename span_const_GLintptr::value_type>, GLintptr> &&
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32> &&
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void draw_commands_states_nv(u32 buffer, span_const_GLintptr const& indirects, span_const_i32 const& sizes, span_const_u32 const& states, span_const_u32 const& fbos, u32 count)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawCommandsStatesNV)
                Throw(undefined_behavior(
                    "unloaded function DrawCommandsStatesNV"));
        glIsBuffer(buffer);
    }
    glDrawCommandsStatesNV(buffer, reinterpret_cast<const GLintptr *>(indirects.data()), reinterpret_cast<const GLsizei *>(sizes.data()), reinterpret_cast<const GLuint *>(states.data()), reinterpret_cast<const GLuint *>(fbos.data()), count);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLuint get_command_header_nv(GLenum tokenID, u32 size)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetCommandHeaderNV)
                Throw(undefined_behavior(
                    "unloaded function GetCommandHeaderNV"));
    }
    auto out = glGetCommandHeaderNV(tokenID, size);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLushort get_stage_index_nv(groups::shader_type shadertype)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetStageIndexNV)
                Throw(undefined_behavior(
                    "unloaded function GetStageIndexNV"));
    }
    auto out = glGetStageIndexNV(static_cast<GLenum>(shadertype));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLboolean is_command_list_nv(u32 list)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsCommandListNV)
                Throw(undefined_behavior(
                    "unloaded function IsCommandListNV"));
    }
    auto out = glIsCommandListNV(list);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLboolean is_state_nv(u32 state)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsStateNV)
                Throw(undefined_behavior(
                    "unloaded function IsStateNV"));
    }
    auto out = glIsStateNV(state);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_byte,
    class span_const_i32,
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte> &&
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32> &&
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void list_draw_commands_states_client_nv(u32 list, u32 segment, span_const_byte const& indirects, span_const_i32 const& sizes, span_const_u32 const& states, span_const_u32 const& fbos, u32 count)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glListDrawCommandsStatesClientNV)
                Throw(undefined_behavior(
                    "unloaded function ListDrawCommandsStatesClientNV"));
    }
    glListDrawCommandsStatesClientNV(list, segment, reinterpret_cast<const void **>(indirects.data()), reinterpret_cast<const GLsizei *>(sizes.data()), reinterpret_cast<const GLuint *>(states.data()), reinterpret_cast<const GLuint *>(fbos.data()), count);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void state_capture_nv(u32 state, GLenum mode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glStateCaptureNV)
                Throw(undefined_behavior(
                    "unloaded function StateCaptureNV"));
    }
    glStateCaptureNV(state, mode);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_command_list
#endif // GL_NV_command_list
#ifdef GL_NV_compute_program5
namespace nv_compute_program5 {
constexpr u32 compute_program_nv = 0x90FB;
constexpr u32 compute_program_parameter_buffer_nv = 0x90FC;
} // nv_compute_program5
#endif // GL_NV_compute_program5
#ifdef GL_NV_compute_shader_derivatives
namespace nv_compute_shader_derivatives {
} // nv_compute_shader_derivatives
#endif // GL_NV_compute_shader_derivatives
#ifdef GL_NV_conditional_render
namespace nv_conditional_render {
constexpr u32 query_wait_nv = 0x8E13;
constexpr u32 query_no_wait_nv = 0x8E14;
constexpr u32 query_by_region_wait_nv = 0x8E15;
constexpr u32 query_by_region_no_wait_nv = 0x8E16;
STATICINLINE void begin_conditional_render_nv(u32 id, groups::conditional_render_mode mode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBeginConditionalRenderNV)
                Throw(undefined_behavior(
                    "unloaded function BeginConditionalRenderNV"));
    }
    glBeginConditionalRenderNV(id, static_cast<GLenum>(mode));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void end_conditional_render_nv()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEndConditionalRenderNV)
                Throw(undefined_behavior(
                    "unloaded function EndConditionalRenderNV"));
    }
    glEndConditionalRenderNV();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_conditional_render
#endif // GL_NV_conditional_render
#ifdef GL_NV_conservative_raster
namespace nv_conservative_raster {
constexpr u32 conservative_rasterization_nv = 0x9346;
constexpr u32 subpixel_precision_bias_x_bits_nv = 0x9347;
constexpr u32 subpixel_precision_bias_y_bits_nv = 0x9348;
constexpr u32 max_subpixel_precision_bias_bits_nv = 0x9349;
STATICINLINE void subpixel_precision_bias_nv(u32 xbits, u32 ybits)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSubpixelPrecisionBiasNV)
                Throw(undefined_behavior(
                    "unloaded function SubpixelPrecisionBiasNV"));
    }
    glSubpixelPrecisionBiasNV(xbits, ybits);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_conservative_raster
#endif // GL_NV_conservative_raster
#ifdef GL_NV_conservative_raster_dilate
namespace nv_conservative_raster_dilate {
constexpr u32 conservative_raster_dilate_nv = 0x9379;
constexpr u32 conservative_raster_dilate_range_nv = 0x937A;
constexpr u32 conservative_raster_dilate_granularity_nv = 0x937B;
STATICINLINE void conservative_raster_parameterf_nv(GLenum pname, f32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glConservativeRasterParameterfNV)
                Throw(undefined_behavior(
                    "unloaded function ConservativeRasterParameterfNV"));
    }
    glConservativeRasterParameterfNV(pname, value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_conservative_raster_dilate
#endif // GL_NV_conservative_raster_dilate
#ifdef GL_NV_conservative_raster_pre_snap
namespace nv_conservative_raster_pre_snap {
constexpr u32 conservative_raster_mode_pre_snap_nv = 0x9550;
} // nv_conservative_raster_pre_snap
#endif // GL_NV_conservative_raster_pre_snap
#ifdef GL_NV_conservative_raster_pre_snap_triangles
namespace nv_conservative_raster_pre_snap_triangles {
constexpr u32 conservative_raster_mode_nv = 0x954D;
constexpr u32 conservative_raster_mode_post_snap_nv = 0x954E;
constexpr u32 conservative_raster_mode_pre_snap_triangles_nv = 0x954F;
STATICINLINE void conservative_raster_parameteri_nv(GLenum pname, i32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glConservativeRasterParameteriNV)
                Throw(undefined_behavior(
                    "unloaded function ConservativeRasterParameteriNV"));
    }
    glConservativeRasterParameteriNV(pname, param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_conservative_raster_pre_snap_triangles
#endif // GL_NV_conservative_raster_pre_snap_triangles
#ifdef GL_NV_conservative_raster_underestimation
namespace nv_conservative_raster_underestimation {
} // nv_conservative_raster_underestimation
#endif // GL_NV_conservative_raster_underestimation
#ifdef GL_NV_copy_buffer
namespace nv_copy_buffer {
constexpr u32 copy_read_buffer_nv = 0x8F36;
constexpr u32 copy_write_buffer_nv = 0x8F37;
STATICINLINE void copy_buffer_sub_data_nv(groups::copy_buffer_sub_data_target readTarget, groups::copy_buffer_sub_data_target writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCopyBufferSubDataNV)
                Throw(undefined_behavior(
                    "unloaded function CopyBufferSubDataNV"));
    }
    glCopyBufferSubDataNV(static_cast<GLenum>(readTarget), static_cast<GLenum>(writeTarget), readOffset, writeOffset, size);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_copy_buffer
#endif // GL_NV_copy_buffer
#ifdef GL_NV_copy_depth_to_color
namespace nv_copy_depth_to_color {
constexpr u32 depth_stencil_to_rgba_nv = 0x886E;
constexpr u32 depth_stencil_to_bgra_nv = 0x886F;
} // nv_copy_depth_to_color
#endif // GL_NV_copy_depth_to_color
#ifdef GL_NV_copy_image
namespace nv_copy_image {
template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void copy_image_sub_data_nv(u32 srcName, groups::copy_buffer_sub_data_target srcTarget, i32 srcLevel, i32 srcX, i32 srcY, i32 srcZ, u32 dstName, groups::copy_buffer_sub_data_target dstTarget, i32 dstLevel, i32 dstX, i32 dstY, i32 dstZ, vec_3_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCopyImageSubDataNV)
                Throw(undefined_behavior(
                    "unloaded function CopyImageSubDataNV"));
    }
    glCopyImageSubDataNV(srcName, static_cast<GLenum>(srcTarget), srcLevel, srcX, srcY, srcZ, dstName, static_cast<GLenum>(dstTarget), dstLevel, dstX, dstY, dstZ, width[0], width[1], width[2]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_copy_image
#endif // GL_NV_copy_image
#ifdef GL_NV_coverage_sample
namespace nv_coverage_sample {
constexpr u32 coverage_buffer_bit_nv = 0x00008000;
constexpr u32 coverage_component_nv = 0x8ED0;
constexpr u32 coverage_component4_nv = 0x8ED1;
constexpr u32 coverage_attachment_nv = 0x8ED2;
constexpr u32 coverage_buffers_nv = 0x8ED3;
constexpr u32 coverage_samples_nv = 0x8ED4;
constexpr u32 coverage_all_fragments_nv = 0x8ED5;
constexpr u32 coverage_edge_fragments_nv = 0x8ED6;
constexpr u32 coverage_automatic_nv = 0x8ED7;
STATICINLINE void coverage_mask_nv(bool mask)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCoverageMaskNV)
                Throw(undefined_behavior(
                    "unloaded function CoverageMaskNV"));
    }
    glCoverageMaskNV(mask);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void coverage_operation_nv(GLenum operation)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCoverageOperationNV)
                Throw(undefined_behavior(
                    "unloaded function CoverageOperationNV"));
    }
    glCoverageOperationNV(operation);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_coverage_sample
#endif // GL_NV_coverage_sample
#ifdef GL_NV_deep_texture3D
namespace nv_deep_texture3d {
constexpr u32 max_deep_3d_texture_width_height_nv = 0x90D0;
constexpr u32 max_deep_3d_texture_depth_nv = 0x90D1;
} // nv_deep_texture3d
#endif // GL_NV_deep_texture3D
#ifdef GL_NV_depth_buffer_float
namespace nv_depth_buffer_float {
constexpr u32 depth_component32f_nv = 0x8DAB;
constexpr u32 depth32f_stencil8_nv = 0x8DAC;
constexpr u32 float_32_unsigned_int_24_8_rev_nv = 0x8DAD;
constexpr u32 depth_buffer_float_mode_nv = 0x8DAF;
STATICINLINE void clear_depthd_nv(f64 depth)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClearDepthdNV)
                Throw(undefined_behavior(
                    "unloaded function ClearDepthdNV"));
    }
    glClearDepthdNV(depth);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void depth_boundsd_nv(f64 zmin, f64 zmax)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDepthBoundsdNV)
                Throw(undefined_behavior(
                    "unloaded function DepthBoundsdNV"));
    }
    glDepthBoundsdNV(zmin, zmax);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void depth_ranged_nv(f64 zNear, f64 zFar)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDepthRangedNV)
                Throw(undefined_behavior(
                    "unloaded function DepthRangedNV"));
    }
    glDepthRangedNV(zNear, zFar);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_depth_buffer_float
#endif // GL_NV_depth_buffer_float
#ifdef GL_NV_depth_clamp
namespace nv_depth_clamp {
constexpr u32 depth_clamp_nv = 0x864F;
} // nv_depth_clamp
#endif // GL_NV_depth_clamp
#ifdef GL_NV_depth_nonlinear
namespace nv_depth_nonlinear {
constexpr u32 depth_component16_nonlinear_nv = 0x8E2C;
} // nv_depth_nonlinear
#endif // GL_NV_depth_nonlinear
#ifdef GL_NV_draw_buffers
namespace nv_draw_buffers {
constexpr u32 max_draw_buffers_nv = 0x8824;
constexpr u32 draw_buffer0_nv = 0x8825;
constexpr u32 draw_buffer1_nv = 0x8826;
constexpr u32 draw_buffer2_nv = 0x8827;
constexpr u32 draw_buffer3_nv = 0x8828;
constexpr u32 draw_buffer4_nv = 0x8829;
constexpr u32 draw_buffer5_nv = 0x882A;
constexpr u32 draw_buffer6_nv = 0x882B;
constexpr u32 draw_buffer7_nv = 0x882C;
constexpr u32 draw_buffer8_nv = 0x882D;
constexpr u32 draw_buffer9_nv = 0x882E;
constexpr u32 draw_buffer10_nv = 0x882F;
constexpr u32 draw_buffer11_nv = 0x8830;
constexpr u32 draw_buffer12_nv = 0x8831;
constexpr u32 draw_buffer13_nv = 0x8832;
constexpr u32 draw_buffer14_nv = 0x8833;
constexpr u32 draw_buffer15_nv = 0x8834;
constexpr u32 color_attachment0_nv = 0x8CE0;
constexpr u32 color_attachment1_nv = 0x8CE1;
constexpr u32 color_attachment2_nv = 0x8CE2;
constexpr u32 color_attachment3_nv = 0x8CE3;
constexpr u32 color_attachment4_nv = 0x8CE4;
constexpr u32 color_attachment5_nv = 0x8CE5;
constexpr u32 color_attachment6_nv = 0x8CE6;
constexpr u32 color_attachment7_nv = 0x8CE7;
constexpr u32 color_attachment8_nv = 0x8CE8;
constexpr u32 color_attachment9_nv = 0x8CE9;
constexpr u32 color_attachment10_nv = 0x8CEA;
constexpr u32 color_attachment11_nv = 0x8CEB;
constexpr u32 color_attachment12_nv = 0x8CEC;
constexpr u32 color_attachment13_nv = 0x8CED;
constexpr u32 color_attachment14_nv = 0x8CEE;
constexpr u32 color_attachment15_nv = 0x8CEF;
template<
    class span_const_GLenum
>
requires (
    semantic::concepts::Span<span_const_GLenum> &&
    std::is_same_v<std::decay_t<typename span_const_GLenum::value_type>, GLenum>)
STATICINLINE void draw_buffers_nv(span_const_GLenum const& bufs)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawBuffersNV)
                Throw(undefined_behavior(
                    "unloaded function DrawBuffersNV"));
    }
    glDrawBuffersNV(bufs.size(), reinterpret_cast<const GLenum *>(bufs.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_draw_buffers
#endif // GL_NV_draw_buffers
#ifdef GL_NV_draw_instanced
namespace nv_draw_instanced {
STATICINLINE void draw_arrays_instanced_nv(groups::primitive_type mode, i32 first, i32 count, i32 primcount)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawArraysInstancedNV)
                Throw(undefined_behavior(
                    "unloaded function DrawArraysInstancedNV"));
    }
    glDrawArraysInstancedNV(static_cast<GLenum>(mode), first, count, primcount);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void draw_elements_instanced_nv(groups::primitive_type mode, i32 count, groups::primitive_type type, ptroff indices, i32 primcount)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawElementsInstancedNV)
                Throw(undefined_behavior(
                    "unloaded function DrawElementsInstancedNV"));
    }
    glDrawElementsInstancedNV(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), reinterpret_cast<const void*>(indices), primcount);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_draw_instanced
#endif // GL_NV_draw_instanced
#ifdef GL_NV_draw_texture
namespace nv_draw_texture {
STATICINLINE void draw_texture_nv(u32 texture, u32 sampler, f32 x0, f32 y0, f32 x1, f32 y1, f32 z, f32 s0, f32 t0, f32 s1, f32 t1)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawTextureNV)
                Throw(undefined_behavior(
                    "unloaded function DrawTextureNV"));
        glIsTexture(texture);
        glIsSampler(sampler);
    }
    glDrawTextureNV(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_draw_texture
#endif // GL_NV_draw_texture
#ifdef GL_NV_draw_vulkan_image
namespace nv_draw_vulkan_image {
STATICINLINE void draw_vk_image_nv(u64 vkImage, u32 sampler, f32 x0, f32 y0, f32 x1, f32 y1, f32 z, f32 s0, f32 t0, f32 s1, f32 t1)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawVkImageNV)
                Throw(undefined_behavior(
                    "unloaded function DrawVkImageNV"));
        glIsSampler(sampler);
    }
    glDrawVkImageNV(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLVULKANPROCNV get_vk_proc_addr_nv(std::string_view const& name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVkProcAddrNV)
                Throw(undefined_behavior(
                    "unloaded function GetVkProcAddrNV"));
    }
    auto out = glGetVkProcAddrNV(name.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void wait_vk_semaphore_nv(u64 vkSemaphore)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWaitVkSemaphoreNV)
                Throw(undefined_behavior(
                    "unloaded function WaitVkSemaphoreNV"));
    }
    glWaitVkSemaphoreNV(vkSemaphore);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void signal_vk_semaphore_nv(u64 vkSemaphore)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSignalVkSemaphoreNV)
                Throw(undefined_behavior(
                    "unloaded function SignalVkSemaphoreNV"));
    }
    glSignalVkSemaphoreNV(vkSemaphore);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void signal_vk_fence_nv(u64 vkFence)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSignalVkFenceNV)
                Throw(undefined_behavior(
                    "unloaded function SignalVkFenceNV"));
    }
    glSignalVkFenceNV(vkFence);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_draw_vulkan_image
#endif // GL_NV_draw_vulkan_image
#ifdef GL_NV_evaluators
namespace nv_evaluators {
constexpr u32 eval_2d_nv = 0x86C0;
constexpr u32 eval_triangular_2d_nv = 0x86C1;
constexpr u32 map_tessellation_nv = 0x86C2;
constexpr u32 map_attrib_u_order_nv = 0x86C3;
constexpr u32 map_attrib_v_order_nv = 0x86C4;
constexpr u32 eval_fractional_tessellation_nv = 0x86C5;
constexpr u32 eval_vertex_attrib0_nv = 0x86C6;
constexpr u32 eval_vertex_attrib1_nv = 0x86C7;
constexpr u32 eval_vertex_attrib2_nv = 0x86C8;
constexpr u32 eval_vertex_attrib3_nv = 0x86C9;
constexpr u32 eval_vertex_attrib4_nv = 0x86CA;
constexpr u32 eval_vertex_attrib5_nv = 0x86CB;
constexpr u32 eval_vertex_attrib6_nv = 0x86CC;
constexpr u32 eval_vertex_attrib7_nv = 0x86CD;
constexpr u32 eval_vertex_attrib8_nv = 0x86CE;
constexpr u32 eval_vertex_attrib9_nv = 0x86CF;
constexpr u32 eval_vertex_attrib10_nv = 0x86D0;
constexpr u32 eval_vertex_attrib11_nv = 0x86D1;
constexpr u32 eval_vertex_attrib12_nv = 0x86D2;
constexpr u32 eval_vertex_attrib13_nv = 0x86D3;
constexpr u32 eval_vertex_attrib14_nv = 0x86D4;
constexpr u32 eval_vertex_attrib15_nv = 0x86D5;
constexpr u32 max_map_tessellation_nv = 0x86D6;
constexpr u32 max_rational_eval_order_nv = 0x86D7;
STATICINLINE void eval_maps_nv(groups::eval_target_nv target, groups::eval_maps_mode_nv mode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEvalMapsNV)
                Throw(undefined_behavior(
                    "unloaded function EvalMapsNV"));
    }
    glEvalMapsNV(static_cast<GLenum>(target), static_cast<GLenum>(mode));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_map_attrib_parameterfv_nv(groups::eval_target_nv target, u32 index, groups::map_attrib_parameter_nv pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetMapAttribParameterfvNV)
                Throw(undefined_behavior(
                    "unloaded function GetMapAttribParameterfvNV"));
    }
    glGetMapAttribParameterfvNV(static_cast<GLenum>(target), index, static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_map_attrib_parameteriv_nv(groups::eval_target_nv target, u32 index, groups::map_attrib_parameter_nv pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetMapAttribParameterivNV)
                Throw(undefined_behavior(
                    "unloaded function GetMapAttribParameterivNV"));
    }
    glGetMapAttribParameterivNV(static_cast<GLenum>(target), index, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_map_control_points_nv(groups::eval_target_nv target, u32 index, groups::map_type_nv type, i32 ustride, i32 vstride, bool packed, span_byte points)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetMapControlPointsNV)
                Throw(undefined_behavior(
                    "unloaded function GetMapControlPointsNV"));
    }
    glGetMapControlPointsNV(static_cast<GLenum>(target), index, static_cast<GLenum>(type), ustride, vstride, packed, reinterpret_cast<void *>(points.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_map_parameterfv_nv(groups::eval_target_nv target, groups::map_parameter_nv pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetMapParameterfvNV)
                Throw(undefined_behavior(
                    "unloaded function GetMapParameterfvNV"));
    }
    glGetMapParameterfvNV(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_map_parameteriv_nv(groups::eval_target_nv target, groups::map_parameter_nv pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetMapParameterivNV)
                Throw(undefined_behavior(
                    "unloaded function GetMapParameterivNV"));
    }
    glGetMapParameterivNV(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void map_control_points_nv(groups::eval_target_nv target, u32 index, groups::map_type_nv type, i32 ustride, i32 vstride, i32 uorder, i32 vorder, bool packed, span_const_byte const& points)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMapControlPointsNV)
                Throw(undefined_behavior(
                    "unloaded function MapControlPointsNV"));
    }
    glMapControlPointsNV(static_cast<GLenum>(target), index, static_cast<GLenum>(type), ustride, vstride, uorder, vorder, packed, reinterpret_cast<const void *>(points.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void map_parameterfv_nv(groups::eval_target_nv target, groups::map_parameter_nv pname, span_const_f32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMapParameterfvNV)
                Throw(undefined_behavior(
                    "unloaded function MapParameterfvNV"));
    }
    glMapParameterfvNV(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<const GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void map_parameteriv_nv(groups::eval_target_nv target, groups::map_parameter_nv pname, span_const_i32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMapParameterivNV)
                Throw(undefined_behavior(
                    "unloaded function MapParameterivNV"));
    }
    glMapParameterivNV(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<const GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_evaluators
#endif // GL_NV_evaluators
#ifdef GL_NV_explicit_attrib_location
namespace nv_explicit_attrib_location {
} // nv_explicit_attrib_location
#endif // GL_NV_explicit_attrib_location
#ifdef GL_NV_explicit_multisample
namespace nv_explicit_multisample {
constexpr u32 sample_position_nv = 0x8E50;
constexpr u32 sample_mask_nv = 0x8E51;
constexpr u32 sample_mask_value_nv = 0x8E52;
constexpr u32 texture_binding_renderbuffer_nv = 0x8E53;
constexpr u32 texture_renderbuffer_data_store_binding_nv = 0x8E54;
constexpr u32 texture_renderbuffer_nv = 0x8E55;
constexpr u32 sampler_renderbuffer_nv = 0x8E56;
constexpr u32 int_sampler_renderbuffer_nv = 0x8E57;
constexpr u32 unsigned_int_sampler_renderbuffer_nv = 0x8E58;
constexpr u32 max_sample_mask_words_nv = 0x8E59;
template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_multisamplefv_nv(groups::get_multisample_prop_nv pname, u32 index, span_f32 val)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetMultisamplefvNV)
                Throw(undefined_behavior(
                    "unloaded function GetMultisamplefvNV"));
    }
    glGetMultisamplefvNV(static_cast<GLenum>(pname), index, reinterpret_cast<GLfloat *>(val.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void sample_mask_indexed_nv(u32 index, groups::sample_mask_nv mask)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSampleMaskIndexedNV)
                Throw(undefined_behavior(
                    "unloaded function SampleMaskIndexedNV"));
    }
    glSampleMaskIndexedNV(index, static_cast<GLenum>(mask));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_renderbuffer_nv(groups::texture_target target, u32 renderbuffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexRenderbufferNV)
                Throw(undefined_behavior(
                    "unloaded function TexRenderbufferNV"));
        glIsRenderbuffer(renderbuffer);
    }
    glTexRenderbufferNV(static_cast<GLenum>(target), renderbuffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_explicit_multisample
#endif // GL_NV_explicit_multisample
#ifdef GL_NV_fbo_color_attachments
namespace nv_fbo_color_attachments {
constexpr u32 max_color_attachments_nv = 0x8CDF;
constexpr u32 color_attachment0_nv = 0x8CE0;
constexpr u32 color_attachment1_nv = 0x8CE1;
constexpr u32 color_attachment2_nv = 0x8CE2;
constexpr u32 color_attachment3_nv = 0x8CE3;
constexpr u32 color_attachment4_nv = 0x8CE4;
constexpr u32 color_attachment5_nv = 0x8CE5;
constexpr u32 color_attachment6_nv = 0x8CE6;
constexpr u32 color_attachment7_nv = 0x8CE7;
constexpr u32 color_attachment8_nv = 0x8CE8;
constexpr u32 color_attachment9_nv = 0x8CE9;
constexpr u32 color_attachment10_nv = 0x8CEA;
constexpr u32 color_attachment11_nv = 0x8CEB;
constexpr u32 color_attachment12_nv = 0x8CEC;
constexpr u32 color_attachment13_nv = 0x8CED;
constexpr u32 color_attachment14_nv = 0x8CEE;
constexpr u32 color_attachment15_nv = 0x8CEF;
} // nv_fbo_color_attachments
#endif // GL_NV_fbo_color_attachments
#ifdef GL_NV_fence
namespace nv_fence {
constexpr u32 all_completed_nv = 0x84F2;
constexpr u32 fence_status_nv = 0x84F3;
constexpr u32 fence_condition_nv = 0x84F4;
template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_fences_nv(span_const_u32 const& fences)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteFencesNV)
                Throw(undefined_behavior(
                    "unloaded function DeleteFencesNV"));
    }
    glDeleteFencesNV(fences.size(), reinterpret_cast<const GLuint *>(fences.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void finish_fence_nv(u32 fence)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFinishFenceNV)
                Throw(undefined_behavior(
                    "unloaded function FinishFenceNV"));
    }
    glFinishFenceNV(fence);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void gen_fences_nv(span_u32 fences)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenFencesNV)
                Throw(undefined_behavior(
                    "unloaded function GenFencesNV"));
    }
    glGenFencesNV(fences.size(), reinterpret_cast<GLuint *>(fences.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_fenceiv_nv(u32 fence, groups::fence_parameter_name_nv pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetFenceivNV)
                Throw(undefined_behavior(
                    "unloaded function GetFenceivNV"));
    }
    glGetFenceivNV(fence, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_fence_nv(u32 fence)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsFenceNV)
                Throw(undefined_behavior(
                    "unloaded function IsFenceNV"));
    }
    auto out = glIsFenceNV(fence);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void set_fence_nv(u32 fence, groups::fence_condition_nv condition)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSetFenceNV)
                Throw(undefined_behavior(
                    "unloaded function SetFenceNV"));
    }
    glSetFenceNV(fence, static_cast<GLenum>(condition));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean test_fence_nv(u32 fence)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTestFenceNV)
                Throw(undefined_behavior(
                    "unloaded function TestFenceNV"));
    }
    auto out = glTestFenceNV(fence);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // nv_fence
#endif // GL_NV_fence
#ifdef GL_NV_fill_rectangle
namespace nv_fill_rectangle {
constexpr u32 fill_rectangle_nv = 0x933C;
} // nv_fill_rectangle
#endif // GL_NV_fill_rectangle
#ifdef GL_NV_float_buffer
namespace nv_float_buffer {
constexpr u32 float_r_nv = 0x8880;
constexpr u32 float_rg_nv = 0x8881;
constexpr u32 float_rgb_nv = 0x8882;
constexpr u32 float_rgba_nv = 0x8883;
constexpr u32 float_r16_nv = 0x8884;
constexpr u32 float_r32_nv = 0x8885;
constexpr u32 float_rg16_nv = 0x8886;
constexpr u32 float_rg32_nv = 0x8887;
constexpr u32 float_rgb16_nv = 0x8888;
constexpr u32 float_rgb32_nv = 0x8889;
constexpr u32 float_rgba16_nv = 0x888A;
constexpr u32 float_rgba32_nv = 0x888B;
constexpr u32 texture_float_components_nv = 0x888C;
constexpr u32 float_clear_color_value_nv = 0x888D;
constexpr u32 float_rgba_mode_nv = 0x888E;
} // nv_float_buffer
#endif // GL_NV_float_buffer
#ifdef GL_NV_fog_distance
namespace nv_fog_distance {
constexpr u32 eye_plane = 0x2502;
constexpr u32 fog_distance_mode_nv = 0x855A;
constexpr u32 eye_radial_nv = 0x855B;
constexpr u32 eye_plane_absolute_nv = 0x855C;
} // nv_fog_distance
#endif // GL_NV_fog_distance
#ifdef GL_NV_fragment_coverage_to_color
namespace nv_fragment_coverage_to_color {
constexpr u32 fragment_coverage_to_color_nv = 0x92DD;
constexpr u32 fragment_coverage_color_nv = 0x92DE;
STATICINLINE void fragment_coverage_color_nv(u32 color)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFragmentCoverageColorNV)
                Throw(undefined_behavior(
                    "unloaded function FragmentCoverageColorNV"));
    }
    glFragmentCoverageColorNV(color);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_fragment_coverage_to_color
#endif // GL_NV_fragment_coverage_to_color
#ifdef GL_NV_fragment_program
namespace nv_fragment_program {
constexpr u32 max_fragment_program_local_parameters_nv = 0x8868;
constexpr u32 fragment_program_nv = 0x8870;
constexpr u32 max_texture_coords_nv = 0x8871;
constexpr u32 max_texture_image_units_nv = 0x8872;
constexpr u32 fragment_program_binding_nv = 0x8873;
constexpr u32 program_error_string_nv = 0x8874;
template<
    class span_const_u8,
    class span_f64
>
requires (
    semantic::concepts::Span<span_const_u8> &&
    std::is_same_v<std::decay_t<typename span_const_u8::value_type>, u8> &&
    semantic::concepts::Span<span_f64> &&
    std::is_same_v<std::decay_t<typename span_f64::value_type>, f64>)
STATICINLINE void get_program_named_parameterdv_nv(u32 id, i32 len, span_const_u8 const& name, span_f64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramNamedParameterdvNV)
                Throw(undefined_behavior(
                    "unloaded function GetProgramNamedParameterdvNV"));
    }
    glGetProgramNamedParameterdvNV(id, len, reinterpret_cast<const GLubyte *>(name.data()), reinterpret_cast<GLdouble *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u8,
    class span_f32
>
requires (
    semantic::concepts::Span<span_const_u8> &&
    std::is_same_v<std::decay_t<typename span_const_u8::value_type>, u8> &&
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_program_named_parameterfv_nv(u32 id, i32 len, span_const_u8 const& name, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramNamedParameterfvNV)
                Throw(undefined_behavior(
                    "unloaded function GetProgramNamedParameterfvNV"));
    }
    glGetProgramNamedParameterfvNV(id, len, reinterpret_cast<const GLubyte *>(name.data()), reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u8,
    class vec_4_f64
>
requires (
    semantic::concepts::Span<span_const_vec_4_u8> &&
    semantic::concepts::Vector<typename span_const_vec_4_u8::value_type, u8, 4> &&
    semantic::concepts::Vector<vec_4_f64, f64, 4>)
STATICINLINE void program_named_parameter4d_nv(u32 id, i32 len, span_const_vec_4_u8 const& name, vec_4_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramNamedParameter4dNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramNamedParameter4dNV"));
    }
    glProgramNamedParameter4dNV(id, len, reinterpret_cast<const GLubyte *>(name.data()), x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f64,
    class span_const_vec_4_u8
>
requires (
    semantic::concepts::Span<span_const_vec_4_u8> &&
    semantic::concepts::Vector<typename span_const_vec_4_u8::value_type, u8, 4> &&
    semantic::concepts::Span<span_const_vec_4_f64> &&
    semantic::concepts::Vector<typename span_const_vec_4_f64::value_type, f64, 4>)
STATICINLINE void program_named_parameter4dv_nv(u32 id, i32 len, span_const_vec_4_u8 const& name, span_const_vec_4_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramNamedParameter4dvNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramNamedParameter4dvNV"));
    }
    glProgramNamedParameter4dvNV(id, len, reinterpret_cast<const GLubyte *>(name.data()), reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u8,
    class vec_4_f32
>
requires (
    semantic::concepts::Span<span_const_vec_4_u8> &&
    semantic::concepts::Vector<typename span_const_vec_4_u8::value_type, u8, 4> &&
    semantic::concepts::Vector<vec_4_f32, f32, 4>)
STATICINLINE void program_named_parameter4f_nv(u32 id, i32 len, span_const_vec_4_u8 const& name, vec_4_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramNamedParameter4fNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramNamedParameter4fNV"));
    }
    glProgramNamedParameter4fNV(id, len, reinterpret_cast<const GLubyte *>(name.data()), x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f32,
    class span_const_vec_4_u8
>
requires (
    semantic::concepts::Span<span_const_vec_4_u8> &&
    semantic::concepts::Vector<typename span_const_vec_4_u8::value_type, u8, 4> &&
    semantic::concepts::Span<span_const_vec_4_f32> &&
    semantic::concepts::Vector<typename span_const_vec_4_f32::value_type, f32, 4>)
STATICINLINE void program_named_parameter4fv_nv(u32 id, i32 len, span_const_vec_4_u8 const& name, span_const_vec_4_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramNamedParameter4fvNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramNamedParameter4fvNV"));
    }
    glProgramNamedParameter4fvNV(id, len, reinterpret_cast<const GLubyte *>(name.data()), reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_fragment_program
#endif // GL_NV_fragment_program
#ifdef GL_NV_fragment_program2
namespace nv_fragment_program2 {
constexpr u32 max_program_exec_instructions_nv = 0x88F4;
constexpr u32 max_program_call_depth_nv = 0x88F5;
constexpr u32 max_program_if_depth_nv = 0x88F6;
constexpr u32 max_program_loop_depth_nv = 0x88F7;
constexpr u32 max_program_loop_count_nv = 0x88F8;
} // nv_fragment_program2
#endif // GL_NV_fragment_program2
#ifdef GL_NV_fragment_program4
namespace nv_fragment_program4 {
} // nv_fragment_program4
#endif // GL_NV_fragment_program4
#ifdef GL_NV_fragment_program_option
namespace nv_fragment_program_option {
} // nv_fragment_program_option
#endif // GL_NV_fragment_program_option
#ifdef GL_NV_fragment_shader_barycentric
namespace nv_fragment_shader_barycentric {
} // nv_fragment_shader_barycentric
#endif // GL_NV_fragment_shader_barycentric
#ifdef GL_NV_fragment_shader_interlock
namespace nv_fragment_shader_interlock {
} // nv_fragment_shader_interlock
#endif // GL_NV_fragment_shader_interlock
#ifdef GL_NV_framebuffer_blit
namespace nv_framebuffer_blit {
constexpr u32 draw_framebuffer_binding_nv = 0x8CA6;
constexpr u32 read_framebuffer_nv = 0x8CA8;
constexpr u32 draw_framebuffer_nv = 0x8CA9;
constexpr u32 read_framebuffer_binding_nv = 0x8CAA;
STATICINLINE void blit_framebuffer_nv(i32 srcX0, i32 srcY0, i32 srcX1, i32 srcY1, i32 dstX0, i32 dstY0, i32 dstX1, i32 dstY1, groups::clear_buffer_mask mask, groups::blit_framebuffer_filter filter)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlitFramebufferNV)
                Throw(undefined_behavior(
                    "unloaded function BlitFramebufferNV"));
    }
    glBlitFramebufferNV(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, static_cast<GLenum>(mask), static_cast<GLenum>(filter));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_framebuffer_blit
#endif // GL_NV_framebuffer_blit
#ifdef GL_NV_framebuffer_mixed_samples
namespace nv_framebuffer_mixed_samples {
constexpr u32 color_samples_nv = 0x8E20;
constexpr u32 raster_multisample_ext = 0x9327;
constexpr u32 raster_samples_ext = 0x9328;
constexpr u32 max_raster_samples_ext = 0x9329;
constexpr u32 raster_fixed_sample_locations_ext = 0x932A;
constexpr u32 multisample_rasterization_allowed_ext = 0x932B;
constexpr u32 effective_raster_samples_ext = 0x932C;
constexpr u32 depth_samples_nv = 0x932D;
constexpr u32 stencil_samples_nv = 0x932E;
constexpr u32 mixed_depth_samples_supported_nv = 0x932F;
constexpr u32 mixed_stencil_samples_supported_nv = 0x9330;
constexpr u32 coverage_modulation_table_nv = 0x9331;
constexpr u32 coverage_modulation_nv = 0x9332;
constexpr u32 coverage_modulation_table_size_nv = 0x9333;
STATICINLINE void coverage_modulation_nv(GLenum components)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCoverageModulationNV)
                Throw(undefined_behavior(
                    "unloaded function CoverageModulationNV"));
    }
    glCoverageModulationNV(components);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void coverage_modulation_table_nv(span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCoverageModulationTableNV)
                Throw(undefined_behavior(
                    "unloaded function CoverageModulationTableNV"));
    }
    glCoverageModulationTableNV(v.size(), reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_coverage_modulation_table_nv(i32 bufSize, span_f32 v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetCoverageModulationTableNV)
                Throw(undefined_behavior(
                    "unloaded function GetCoverageModulationTableNV"));
    }
    glGetCoverageModulationTableNV(bufSize, reinterpret_cast<GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void raster_samples_ext(u32 samples, bool fixedsamplelocations)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glRasterSamplesEXT)
                Throw(undefined_behavior(
                    "unloaded function RasterSamplesEXT"));
    }
    glRasterSamplesEXT(samples, fixedsamplelocations);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_framebuffer_mixed_samples
#endif // GL_NV_framebuffer_mixed_samples
#ifdef GL_NV_framebuffer_multisample
namespace nv_framebuffer_multisample {
constexpr u32 renderbuffer_samples_nv = 0x8CAB;
constexpr u32 framebuffer_incomplete_multisample_nv = 0x8D56;
constexpr u32 max_samples_nv = 0x8D57;
template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void renderbuffer_storage_multisample_nv(groups::renderbuffer_target target, i32 samples, groups::internal_format internalformat, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glRenderbufferStorageMultisampleNV)
                Throw(undefined_behavior(
                    "unloaded function RenderbufferStorageMultisampleNV"));
    }
    glRenderbufferStorageMultisampleNV(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_framebuffer_multisample
#endif // GL_NV_framebuffer_multisample
#ifdef GL_NV_framebuffer_multisample_coverage
namespace nv_framebuffer_multisample_coverage {
constexpr u32 renderbuffer_coverage_samples_nv = 0x8CAB;
constexpr u32 renderbuffer_color_samples_nv = 0x8E10;
constexpr u32 max_multisample_coverage_modes_nv = 0x8E11;
constexpr u32 multisample_coverage_modes_nv = 0x8E12;
template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void renderbuffer_storage_multisample_coverage_nv(groups::renderbuffer_target target, i32 coverageSamples, i32 colorSamples, groups::internal_format internalformat, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glRenderbufferStorageMultisampleCoverageNV)
                Throw(undefined_behavior(
                    "unloaded function RenderbufferStorageMultisampleCoverageNV"));
    }
    glRenderbufferStorageMultisampleCoverageNV(static_cast<GLenum>(target), coverageSamples, colorSamples, static_cast<GLenum>(internalformat), width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_framebuffer_multisample_coverage
#endif // GL_NV_framebuffer_multisample_coverage
#ifdef GL_NV_generate_mipmap_sRGB
namespace nv_generate_mipmap_srgb {
} // nv_generate_mipmap_srgb
#endif // GL_NV_generate_mipmap_sRGB
#ifdef GL_NV_geometry_program4
namespace nv_geometry_program4 {
constexpr u32 lines_adjacency_ext = 0x000A;
constexpr u32 line_strip_adjacency_ext = 0x000B;
constexpr u32 triangles_adjacency_ext = 0x000C;
constexpr u32 triangle_strip_adjacency_ext = 0x000D;
constexpr u32 program_point_size_ext = 0x8642;
constexpr u32 geometry_program_nv = 0x8C26;
constexpr u32 max_program_output_vertices_nv = 0x8C27;
constexpr u32 max_program_total_output_components_nv = 0x8C28;
constexpr u32 max_geometry_texture_image_units_ext = 0x8C29;
constexpr u32 framebuffer_attachment_texture_layer_ext = 0x8CD4;
constexpr u32 framebuffer_attachment_layered_ext = 0x8DA7;
constexpr u32 framebuffer_incomplete_layer_targets_ext = 0x8DA8;
constexpr u32 framebuffer_incomplete_layer_count_ext = 0x8DA9;
constexpr u32 geometry_vertices_out_ext = 0x8DDA;
constexpr u32 geometry_input_type_ext = 0x8DDB;
constexpr u32 geometry_output_type_ext = 0x8DDC;
STATICINLINE void framebuffer_texture_ext(groups::framebuffer_target target, groups::framebuffer_attachment attachment, u32 texture, i32 level)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferTextureEXT)
                Throw(undefined_behavior(
                    "unloaded function FramebufferTextureEXT"));
        glIsTexture(texture);
    }
    glFramebufferTextureEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void framebuffer_texture_face_ext(groups::framebuffer_target target, groups::framebuffer_attachment attachment, u32 texture, i32 level, groups::texture_target face)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferTextureFaceEXT)
                Throw(undefined_behavior(
                    "unloaded function FramebufferTextureFaceEXT"));
        glIsTexture(texture);
    }
    glFramebufferTextureFaceEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, static_cast<GLenum>(face));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void framebuffer_texture_layer_ext(groups::framebuffer_target target, groups::framebuffer_attachment attachment, u32 texture, i32 level, i32 layer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferTextureLayerEXT)
                Throw(undefined_behavior(
                    "unloaded function FramebufferTextureLayerEXT"));
        glIsTexture(texture);
    }
    glFramebufferTextureLayerEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, layer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void program_vertex_limit_nv(groups::program_target target, i32 limit)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramVertexLimitNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramVertexLimitNV"));
    }
    glProgramVertexLimitNV(static_cast<GLenum>(target), limit);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_geometry_program4
#endif // GL_NV_geometry_program4
#ifdef GL_NV_geometry_shader4
namespace nv_geometry_shader4 {
} // nv_geometry_shader4
#endif // GL_NV_geometry_shader4
#ifdef GL_NV_geometry_shader_passthrough
namespace nv_geometry_shader_passthrough {
} // nv_geometry_shader_passthrough
#endif // GL_NV_geometry_shader_passthrough
#ifdef GL_NV_gpu_program4
namespace nv_gpu_program4 {
constexpr u32 min_program_texel_offset_nv = 0x8904;
constexpr u32 max_program_texel_offset_nv = 0x8905;
constexpr u32 program_attrib_components_nv = 0x8906;
constexpr u32 program_result_components_nv = 0x8907;
constexpr u32 max_program_attrib_components_nv = 0x8908;
constexpr u32 max_program_result_components_nv = 0x8909;
constexpr u32 max_program_generic_attribs_nv = 0x8DA5;
constexpr u32 max_program_generic_results_nv = 0x8DA6;
template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_program_env_parameter_iiv_nv(groups::program_target target, u32 index, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramEnvParameterIivNV)
                Throw(undefined_behavior(
                    "unloaded function GetProgramEnvParameterIivNV"));
    }
    glGetProgramEnvParameterIivNV(static_cast<GLenum>(target), index, reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_program_env_parameter_iuiv_nv(groups::program_target target, u32 index, span_u32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramEnvParameterIuivNV)
                Throw(undefined_behavior(
                    "unloaded function GetProgramEnvParameterIuivNV"));
    }
    glGetProgramEnvParameterIuivNV(static_cast<GLenum>(target), index, reinterpret_cast<GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_program_local_parameter_iiv_nv(groups::program_target target, u32 index, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramLocalParameterIivNV)
                Throw(undefined_behavior(
                    "unloaded function GetProgramLocalParameterIivNV"));
    }
    glGetProgramLocalParameterIivNV(static_cast<GLenum>(target), index, reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_program_local_parameter_iuiv_nv(groups::program_target target, u32 index, span_u32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramLocalParameterIuivNV)
                Throw(undefined_behavior(
                    "unloaded function GetProgramLocalParameterIuivNV"));
    }
    glGetProgramLocalParameterIuivNV(static_cast<GLenum>(target), index, reinterpret_cast<GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_i32
>
requires (
    semantic::concepts::Vector<vec_4_i32, i32, 4>)
STATICINLINE void program_env_parameter_i4i_nv(groups::program_target target, u32 index, vec_4_i32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramEnvParameterI4iNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramEnvParameterI4iNV"));
    }
    glProgramEnvParameterI4iNV(static_cast<GLenum>(target), index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_i32
>
requires (
    semantic::concepts::Span<span_const_vec_4_i32> &&
    semantic::concepts::Vector<typename span_const_vec_4_i32::value_type, i32, 4>)
STATICINLINE void program_env_parameter_i4iv_nv(groups::program_target target, u32 index, span_const_vec_4_i32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramEnvParameterI4ivNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramEnvParameterI4ivNV"));
    }
    glProgramEnvParameterI4ivNV(static_cast<GLenum>(target), index, reinterpret_cast<const GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_u32
>
requires (
    semantic::concepts::Vector<vec_4_u32, u32, 4>)
STATICINLINE void program_env_parameter_i4ui_nv(groups::program_target target, u32 index, vec_4_u32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramEnvParameterI4uiNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramEnvParameterI4uiNV"));
    }
    glProgramEnvParameterI4uiNV(static_cast<GLenum>(target), index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u32
>
requires (
    semantic::concepts::Span<span_const_vec_4_u32> &&
    semantic::concepts::Vector<typename span_const_vec_4_u32::value_type, u32, 4>)
STATICINLINE void program_env_parameter_i4uiv_nv(groups::program_target target, u32 index, span_const_vec_4_u32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramEnvParameterI4uivNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramEnvParameterI4uivNV"));
    }
    glProgramEnvParameterI4uivNV(static_cast<GLenum>(target), index, reinterpret_cast<const GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_i32
>
requires (
    semantic::concepts::Span<span_const_vec_4_i32> &&
    semantic::concepts::Vector<typename span_const_vec_4_i32::value_type, i32, 4>)
STATICINLINE void program_env_parameters_i4iv_nv(groups::program_target target, u32 index, i32 count, span_const_vec_4_i32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramEnvParametersI4ivNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramEnvParametersI4ivNV"));
    }
    glProgramEnvParametersI4ivNV(static_cast<GLenum>(target), index, count, reinterpret_cast<const GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u32
>
requires (
    semantic::concepts::Span<span_const_vec_4_u32> &&
    semantic::concepts::Vector<typename span_const_vec_4_u32::value_type, u32, 4>)
STATICINLINE void program_env_parameters_i4uiv_nv(groups::program_target target, u32 index, i32 count, span_const_vec_4_u32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramEnvParametersI4uivNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramEnvParametersI4uivNV"));
    }
    glProgramEnvParametersI4uivNV(static_cast<GLenum>(target), index, count, reinterpret_cast<const GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_i32
>
requires (
    semantic::concepts::Vector<vec_4_i32, i32, 4>)
STATICINLINE void program_local_parameter_i4i_nv(groups::program_target target, u32 index, vec_4_i32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramLocalParameterI4iNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramLocalParameterI4iNV"));
    }
    glProgramLocalParameterI4iNV(static_cast<GLenum>(target), index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_i32
>
requires (
    semantic::concepts::Span<span_const_vec_4_i32> &&
    semantic::concepts::Vector<typename span_const_vec_4_i32::value_type, i32, 4>)
STATICINLINE void program_local_parameter_i4iv_nv(groups::program_target target, u32 index, span_const_vec_4_i32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramLocalParameterI4ivNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramLocalParameterI4ivNV"));
    }
    glProgramLocalParameterI4ivNV(static_cast<GLenum>(target), index, reinterpret_cast<const GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_u32
>
requires (
    semantic::concepts::Vector<vec_4_u32, u32, 4>)
STATICINLINE void program_local_parameter_i4ui_nv(groups::program_target target, u32 index, vec_4_u32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramLocalParameterI4uiNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramLocalParameterI4uiNV"));
    }
    glProgramLocalParameterI4uiNV(static_cast<GLenum>(target), index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u32
>
requires (
    semantic::concepts::Span<span_const_vec_4_u32> &&
    semantic::concepts::Vector<typename span_const_vec_4_u32::value_type, u32, 4>)
STATICINLINE void program_local_parameter_i4uiv_nv(groups::program_target target, u32 index, span_const_vec_4_u32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramLocalParameterI4uivNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramLocalParameterI4uivNV"));
    }
    glProgramLocalParameterI4uivNV(static_cast<GLenum>(target), index, reinterpret_cast<const GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_i32
>
requires (
    semantic::concepts::Span<span_const_vec_4_i32> &&
    semantic::concepts::Vector<typename span_const_vec_4_i32::value_type, i32, 4>)
STATICINLINE void program_local_parameters_i4iv_nv(groups::program_target target, u32 index, i32 count, span_const_vec_4_i32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramLocalParametersI4ivNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramLocalParametersI4ivNV"));
    }
    glProgramLocalParametersI4ivNV(static_cast<GLenum>(target), index, count, reinterpret_cast<const GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_u32
>
requires (
    semantic::concepts::Span<span_const_vec_4_u32> &&
    semantic::concepts::Vector<typename span_const_vec_4_u32::value_type, u32, 4>)
STATICINLINE void program_local_parameters_i4uiv_nv(groups::program_target target, u32 index, i32 count, span_const_vec_4_u32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramLocalParametersI4uivNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramLocalParametersI4uivNV"));
    }
    glProgramLocalParametersI4uivNV(static_cast<GLenum>(target), index, count, reinterpret_cast<const GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_gpu_program4
#endif // GL_NV_gpu_program4
#ifdef GL_NV_gpu_program5
namespace nv_gpu_program5 {
constexpr u32 max_geometry_program_invocations_nv = 0x8E5A;
constexpr u32 min_fragment_interpolation_offset_nv = 0x8E5B;
constexpr u32 max_fragment_interpolation_offset_nv = 0x8E5C;
constexpr u32 fragment_program_interpolation_offset_bits_nv = 0x8E5D;
constexpr u32 min_program_texture_gather_offset_nv = 0x8E5E;
constexpr u32 max_program_texture_gather_offset_nv = 0x8E5F;
constexpr u32 max_program_subroutine_parameters_nv = 0x8F44;
constexpr u32 max_program_subroutine_num_nv = 0x8F45;
template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_program_subroutine_parameteruiv_nv(GLenum target, u32 index, span_u32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramSubroutineParameteruivNV)
                Throw(undefined_behavior(
                    "unloaded function GetProgramSubroutineParameteruivNV"));
    }
    glGetProgramSubroutineParameteruivNV(target, index, reinterpret_cast<GLuint *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void program_subroutine_parametersuiv_nv(GLenum target, span_const_u32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramSubroutineParametersuivNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramSubroutineParametersuivNV"));
    }
    glProgramSubroutineParametersuivNV(target, params.size(), reinterpret_cast<const GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_gpu_program5
#endif // GL_NV_gpu_program5
#ifdef GL_NV_gpu_program5_mem_extended
namespace nv_gpu_program5_mem_extended {
} // nv_gpu_program5_mem_extended
#endif // GL_NV_gpu_program5_mem_extended
#ifdef GL_NV_gpu_shader5
namespace nv_gpu_shader5 {
constexpr u32 patches = 0x000E;
constexpr u32 int64_nv = 0x140E;
constexpr u32 unsigned_int64_nv = 0x140F;
constexpr u32 int8_nv = 0x8FE0;
constexpr u32 int8_vec2_nv = 0x8FE1;
constexpr u32 int8_vec3_nv = 0x8FE2;
constexpr u32 int8_vec4_nv = 0x8FE3;
constexpr u32 int16_nv = 0x8FE4;
constexpr u32 int16_vec2_nv = 0x8FE5;
constexpr u32 int16_vec3_nv = 0x8FE6;
constexpr u32 int16_vec4_nv = 0x8FE7;
constexpr u32 int64_vec2_nv = 0x8FE9;
constexpr u32 int64_vec3_nv = 0x8FEA;
constexpr u32 int64_vec4_nv = 0x8FEB;
constexpr u32 unsigned_int8_nv = 0x8FEC;
constexpr u32 unsigned_int8_vec2_nv = 0x8FED;
constexpr u32 unsigned_int8_vec3_nv = 0x8FEE;
constexpr u32 unsigned_int8_vec4_nv = 0x8FEF;
constexpr u32 unsigned_int16_nv = 0x8FF0;
constexpr u32 unsigned_int16_vec2_nv = 0x8FF1;
constexpr u32 unsigned_int16_vec3_nv = 0x8FF2;
constexpr u32 unsigned_int16_vec4_nv = 0x8FF3;
constexpr u32 unsigned_int64_vec2_nv = 0x8FF5;
constexpr u32 unsigned_int64_vec3_nv = 0x8FF6;
constexpr u32 unsigned_int64_vec4_nv = 0x8FF7;
constexpr u32 float16_nv = 0x8FF8;
constexpr u32 float16_vec2_nv = 0x8FF9;
constexpr u32 float16_vec3_nv = 0x8FFA;
constexpr u32 float16_vec4_nv = 0x8FFB;
template<
    class span_GLint64EXT
>
requires (
    semantic::concepts::Span<span_GLint64EXT> &&
    std::is_same_v<std::decay_t<typename span_GLint64EXT::value_type>, GLint64EXT>)
STATICINLINE void get_uniformi64v_nv(u32 program, i32 location, span_GLint64EXT params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetUniformi64vNV)
                Throw(undefined_behavior(
                    "unloaded function GetUniformi64vNV"));
        glIsProgram(program);
    }
    glGetUniformi64vNV(program, location, reinterpret_cast<GLint64EXT *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void uniform(i32 location, GLint64EXT x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1i64NV)
                Throw(undefined_behavior(
                    "unloaded function Uniform1i64NV"));
    }
    glUniform1i64NV(location, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_GLint64EXT> &&
    std::is_same_v<std::decay_t<typename span_const_GLint64EXT::value_type>, GLint64EXT>)
STATICINLINE void uniform(i32 location, i32 count, span_const_GLint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1i64vNV)
                Throw(undefined_behavior(
                    "unloaded function Uniform1i64vNV"));
    }
    glUniform1i64vNV(location, count, reinterpret_cast<const GLint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void uniform(i32 location, GLuint64EXT x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1ui64NV)
                Throw(undefined_behavior(
                    "unloaded function Uniform1ui64NV"));
    }
    glUniform1ui64NV(location, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_const_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE void uniform(i32 location, i32 count, span_const_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform1ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function Uniform1ui64vNV"));
    }
    glUniform1ui64vNV(location, count, reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_GLint64EXT
>
requires (
    semantic::concepts::Vector<vec_2_GLint64EXT, GLint64EXT, 2>)
STATICINLINE void uniform(i32 location, vec_2_GLint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2i64NV)
                Throw(undefined_behavior(
                    "unloaded function Uniform2i64NV"));
    }
    glUniform2i64NV(location, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_2_GLint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_2_GLint64EXT::value_type, GLint64EXT, 2>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_2_GLint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2i64vNV)
                Throw(undefined_behavior(
                    "unloaded function Uniform2i64vNV"));
    }
    glUniform2i64vNV(location, count, reinterpret_cast<const GLint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_GLuint64EXT
>
requires (
    semantic::concepts::Vector<vec_2_GLuint64EXT, GLuint64EXT, 2>)
STATICINLINE void uniform(i32 location, vec_2_GLuint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2ui64NV)
                Throw(undefined_behavior(
                    "unloaded function Uniform2ui64NV"));
    }
    glUniform2ui64NV(location, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_2_GLuint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_2_GLuint64EXT::value_type, GLuint64EXT, 2>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_2_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform2ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function Uniform2ui64vNV"));
    }
    glUniform2ui64vNV(location, count, reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLint64EXT
>
requires (
    semantic::concepts::Vector<vec_3_GLint64EXT, GLint64EXT, 3>)
STATICINLINE void uniform(i32 location, vec_3_GLint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3i64NV)
                Throw(undefined_behavior(
                    "unloaded function Uniform3i64NV"));
    }
    glUniform3i64NV(location, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_3_GLint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_3_GLint64EXT::value_type, GLint64EXT, 3>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_3_GLint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3i64vNV)
                Throw(undefined_behavior(
                    "unloaded function Uniform3i64vNV"));
    }
    glUniform3i64vNV(location, count, reinterpret_cast<const GLint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLuint64EXT
>
requires (
    semantic::concepts::Vector<vec_3_GLuint64EXT, GLuint64EXT, 3>)
STATICINLINE void uniform(i32 location, vec_3_GLuint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3ui64NV)
                Throw(undefined_behavior(
                    "unloaded function Uniform3ui64NV"));
    }
    glUniform3ui64NV(location, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_3_GLuint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_3_GLuint64EXT::value_type, GLuint64EXT, 3>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_3_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform3ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function Uniform3ui64vNV"));
    }
    glUniform3ui64vNV(location, count, reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLint64EXT
>
requires (
    semantic::concepts::Vector<vec_4_GLint64EXT, GLint64EXT, 4>)
STATICINLINE void uniform(i32 location, vec_4_GLint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4i64NV)
                Throw(undefined_behavior(
                    "unloaded function Uniform4i64NV"));
    }
    glUniform4i64NV(location, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_4_GLint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_4_GLint64EXT::value_type, GLint64EXT, 4>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_4_GLint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4i64vNV)
                Throw(undefined_behavior(
                    "unloaded function Uniform4i64vNV"));
    }
    glUniform4i64vNV(location, count, reinterpret_cast<const GLint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLuint64EXT
>
requires (
    semantic::concepts::Vector<vec_4_GLuint64EXT, GLuint64EXT, 4>)
STATICINLINE void uniform(i32 location, vec_4_GLuint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4ui64NV)
                Throw(undefined_behavior(
                    "unloaded function Uniform4ui64NV"));
    }
    glUniform4ui64NV(location, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_4_GLuint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_4_GLuint64EXT::value_type, GLuint64EXT, 4>)
STATICINLINE void uniform(i32 location, i32 count, span_const_vec_4_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniform4ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function Uniform4ui64vNV"));
    }
    glUniform4ui64vNV(location, count, reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void program_uniform(u32 program, i32 location, GLint64EXT x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1i64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1i64NV"));
        glIsProgram(program);
    }
    glProgramUniform1i64NV(program, location, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_GLint64EXT> &&
    std::is_same_v<std::decay_t<typename span_const_GLint64EXT::value_type>, GLint64EXT>)
STATICINLINE void program_uniform(u32 program, i32 location, span_const_GLint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1i64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1i64vNV"));
        glIsProgram(program);
    }
    glProgramUniform1i64vNV(program, location, value.size(), reinterpret_cast<const GLint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void program_uniform(u32 program, i32 location, GLuint64EXT x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1ui64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1ui64NV"));
        glIsProgram(program);
    }
    glProgramUniform1ui64NV(program, location, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_const_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE void program_uniform(u32 program, i32 location, span_const_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform1ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform1ui64vNV"));
        glIsProgram(program);
    }
    glProgramUniform1ui64vNV(program, location, value.size(), reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_GLint64EXT
>
requires (
    semantic::concepts::Vector<vec_2_GLint64EXT, GLint64EXT, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_2_GLint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2i64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2i64NV"));
        glIsProgram(program);
    }
    glProgramUniform2i64NV(program, location, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_2_GLint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_2_GLint64EXT::value_type, GLint64EXT, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_2_GLint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2i64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2i64vNV"));
        glIsProgram(program);
    }
    glProgramUniform2i64vNV(program, location, count, reinterpret_cast<const GLint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_GLuint64EXT
>
requires (
    semantic::concepts::Vector<vec_2_GLuint64EXT, GLuint64EXT, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_2_GLuint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2ui64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2ui64NV"));
        glIsProgram(program);
    }
    glProgramUniform2ui64NV(program, location, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_2_GLuint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_2_GLuint64EXT::value_type, GLuint64EXT, 2>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_2_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform2ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform2ui64vNV"));
        glIsProgram(program);
    }
    glProgramUniform2ui64vNV(program, location, count, reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLint64EXT
>
requires (
    semantic::concepts::Vector<vec_3_GLint64EXT, GLint64EXT, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_3_GLint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3i64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3i64NV"));
        glIsProgram(program);
    }
    glProgramUniform3i64NV(program, location, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_3_GLint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_3_GLint64EXT::value_type, GLint64EXT, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_3_GLint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3i64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3i64vNV"));
        glIsProgram(program);
    }
    glProgramUniform3i64vNV(program, location, count, reinterpret_cast<const GLint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLuint64EXT
>
requires (
    semantic::concepts::Vector<vec_3_GLuint64EXT, GLuint64EXT, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_3_GLuint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3ui64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3ui64NV"));
        glIsProgram(program);
    }
    glProgramUniform3ui64NV(program, location, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_3_GLuint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_3_GLuint64EXT::value_type, GLuint64EXT, 3>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_3_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform3ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform3ui64vNV"));
        glIsProgram(program);
    }
    glProgramUniform3ui64vNV(program, location, count, reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLint64EXT
>
requires (
    semantic::concepts::Vector<vec_4_GLint64EXT, GLint64EXT, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_4_GLint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4i64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4i64NV"));
        glIsProgram(program);
    }
    glProgramUniform4i64NV(program, location, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_4_GLint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_4_GLint64EXT::value_type, GLint64EXT, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_4_GLint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4i64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4i64vNV"));
        glIsProgram(program);
    }
    glProgramUniform4i64vNV(program, location, count, reinterpret_cast<const GLint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLuint64EXT
>
requires (
    semantic::concepts::Vector<vec_4_GLuint64EXT, GLuint64EXT, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, vec_4_GLuint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4ui64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4ui64NV"));
        glIsProgram(program);
    }
    glProgramUniform4ui64NV(program, location, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_4_GLuint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_4_GLuint64EXT::value_type, GLuint64EXT, 4>)
STATICINLINE void program_uniform(u32 program, i32 location, i32 count, span_const_vec_4_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniform4ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniform4ui64vNV"));
        glIsProgram(program);
    }
    glProgramUniform4ui64vNV(program, location, count, reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_gpu_shader5
#endif // GL_NV_gpu_shader5
#ifdef GL_NV_half_float
namespace nv_half_float {
constexpr u32 half_float_nv = 0x140B;
template<
    class vec_3_GLhalfNV
>
requires (
    semantic::concepts::Vector<vec_3_GLhalfNV, GLhalfNV, 3>)
STATICINLINE void color3h_nv(vec_3_GLhalfNV const& red)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColor3hNV)
                Throw(undefined_behavior(
                    "unloaded function Color3hNV"));
    }
    glColor3hNV(red.x(), red.y(), red.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void color3hv_nv(span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColor3hvNV)
                Throw(undefined_behavior(
                    "unloaded function Color3hvNV"));
    }
    glColor3hvNV(reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLhalfNV
>
requires (
    semantic::concepts::Vector<vec_4_GLhalfNV, GLhalfNV, 4>)
STATICINLINE void color4h_nv(vec_4_GLhalfNV const& red)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColor4hNV)
                Throw(undefined_behavior(
                    "unloaded function Color4hNV"));
    }
    glColor4hNV(red.x(), red.y(), red.z(), red.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void color4hv_nv(span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColor4hvNV)
                Throw(undefined_behavior(
                    "unloaded function Color4hvNV"));
    }
    glColor4hvNV(reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void fog_coordh_nv(GLhalfNV fog)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFogCoordhNV)
                Throw(undefined_behavior(
                    "unloaded function FogCoordhNV"));
    }
    glFogCoordhNV(fog);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void fog_coordhv_nv(span_const_GLhalfNV const& fog)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFogCoordhvNV)
                Throw(undefined_behavior(
                    "unloaded function FogCoordhvNV"));
    }
    glFogCoordhvNV(reinterpret_cast<const GLhalfNV *>(fog.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord1h_nv(groups::texture_unit target, GLhalfNV s)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord1hNV)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord1hNV"));
    }
    glMultiTexCoord1hNV(static_cast<GLenum>(target), s);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void multi_tex_coord1hv_nv(groups::texture_unit target, span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord1hvNV)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord1hvNV"));
    }
    glMultiTexCoord1hvNV(static_cast<GLenum>(target), reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord2h_nv(groups::texture_unit target, GLhalfNV s, GLhalfNV t)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord2hNV)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord2hNV"));
    }
    glMultiTexCoord2hNV(static_cast<GLenum>(target), s, t);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void multi_tex_coord2hv_nv(groups::texture_unit target, span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord2hvNV)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord2hvNV"));
    }
    glMultiTexCoord2hvNV(static_cast<GLenum>(target), reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord3h_nv(groups::texture_unit target, GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord3hNV)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord3hNV"));
    }
    glMultiTexCoord3hNV(static_cast<GLenum>(target), s, t, r);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void multi_tex_coord3hv_nv(groups::texture_unit target, span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord3hvNV)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord3hvNV"));
    }
    glMultiTexCoord3hvNV(static_cast<GLenum>(target), reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord4h_nv(groups::texture_unit target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord4hNV)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord4hNV"));
    }
    glMultiTexCoord4hNV(static_cast<GLenum>(target), s, t, r, q);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void multi_tex_coord4hv_nv(groups::texture_unit target, span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord4hvNV)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord4hvNV"));
    }
    glMultiTexCoord4hvNV(static_cast<GLenum>(target), reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void normal3h_nv(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNormal3hNV)
                Throw(undefined_behavior(
                    "unloaded function Normal3hNV"));
    }
    glNormal3hNV(nx, ny, nz);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void normal3hv_nv(span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNormal3hvNV)
                Throw(undefined_behavior(
                    "unloaded function Normal3hvNV"));
    }
    glNormal3hvNV(reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLhalfNV
>
requires (
    semantic::concepts::Vector<vec_3_GLhalfNV, GLhalfNV, 3>)
STATICINLINE void secondary_color3h_nv(vec_3_GLhalfNV const& red)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSecondaryColor3hNV)
                Throw(undefined_behavior(
                    "unloaded function SecondaryColor3hNV"));
    }
    glSecondaryColor3hNV(red.x(), red.y(), red.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void secondary_color3hv_nv(span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSecondaryColor3hvNV)
                Throw(undefined_behavior(
                    "unloaded function SecondaryColor3hvNV"));
    }
    glSecondaryColor3hvNV(reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_coord1h_nv(GLhalfNV s)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord1hNV)
                Throw(undefined_behavior(
                    "unloaded function TexCoord1hNV"));
    }
    glTexCoord1hNV(s);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void tex_coord1hv_nv(span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord1hvNV)
                Throw(undefined_behavior(
                    "unloaded function TexCoord1hvNV"));
    }
    glTexCoord1hvNV(reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_coord2h_nv(GLhalfNV s, GLhalfNV t)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord2hNV)
                Throw(undefined_behavior(
                    "unloaded function TexCoord2hNV"));
    }
    glTexCoord2hNV(s, t);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void tex_coord2hv_nv(span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord2hvNV)
                Throw(undefined_behavior(
                    "unloaded function TexCoord2hvNV"));
    }
    glTexCoord2hvNV(reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_coord3h_nv(GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord3hNV)
                Throw(undefined_behavior(
                    "unloaded function TexCoord3hNV"));
    }
    glTexCoord3hNV(s, t, r);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void tex_coord3hv_nv(span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord3hvNV)
                Throw(undefined_behavior(
                    "unloaded function TexCoord3hvNV"));
    }
    glTexCoord3hvNV(reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_coord4h_nv(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord4hNV)
                Throw(undefined_behavior(
                    "unloaded function TexCoord4hNV"));
    }
    glTexCoord4hNV(s, t, r, q);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void tex_coord4hv_nv(span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord4hvNV)
                Throw(undefined_behavior(
                    "unloaded function TexCoord4hvNV"));
    }
    glTexCoord4hvNV(reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_GLhalfNV
>
requires (
    semantic::concepts::Vector<vec_2_GLhalfNV, GLhalfNV, 2>)
STATICINLINE void vertex2h_nv(vec_2_GLhalfNV const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex2hNV)
                Throw(undefined_behavior(
                    "unloaded function Vertex2hNV"));
    }
    glVertex2hNV(x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void vertex2hv_nv(span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex2hvNV)
                Throw(undefined_behavior(
                    "unloaded function Vertex2hvNV"));
    }
    glVertex2hvNV(reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLhalfNV
>
requires (
    semantic::concepts::Vector<vec_3_GLhalfNV, GLhalfNV, 3>)
STATICINLINE void vertex3h_nv(vec_3_GLhalfNV const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex3hNV)
                Throw(undefined_behavior(
                    "unloaded function Vertex3hNV"));
    }
    glVertex3hNV(x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void vertex3hv_nv(span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex3hvNV)
                Throw(undefined_behavior(
                    "unloaded function Vertex3hvNV"));
    }
    glVertex3hvNV(reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLhalfNV
>
requires (
    semantic::concepts::Vector<vec_4_GLhalfNV, GLhalfNV, 4>)
STATICINLINE void vertex4h_nv(vec_4_GLhalfNV const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex4hNV)
                Throw(undefined_behavior(
                    "unloaded function Vertex4hNV"));
    }
    glVertex4hNV(x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void vertex4hv_nv(span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex4hvNV)
                Throw(undefined_behavior(
                    "unloaded function Vertex4hvNV"));
    }
    glVertex4hvNV(reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib1h_nv(u32 index, GLhalfNV x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1hNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1hNV"));
    }
    glVertexAttrib1hNV(index, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void vertex_attrib1hv_nv(u32 index, span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1hvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1hvNV"));
    }
    glVertexAttrib1hvNV(index, reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_GLhalfNV
>
requires (
    semantic::concepts::Vector<vec_2_GLhalfNV, GLhalfNV, 2>)
STATICINLINE void vertex_attrib2h_nv(u32 index, vec_2_GLhalfNV const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2hNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2hNV"));
    }
    glVertexAttrib2hNV(index, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void vertex_attrib2hv_nv(u32 index, span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2hvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2hvNV"));
    }
    glVertexAttrib2hvNV(index, reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLhalfNV
>
requires (
    semantic::concepts::Vector<vec_3_GLhalfNV, GLhalfNV, 3>)
STATICINLINE void vertex_attrib3h_nv(u32 index, vec_3_GLhalfNV const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3hNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3hNV"));
    }
    glVertexAttrib3hNV(index, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void vertex_attrib3hv_nv(u32 index, span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3hvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3hvNV"));
    }
    glVertexAttrib3hvNV(index, reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLhalfNV
>
requires (
    semantic::concepts::Vector<vec_4_GLhalfNV, GLhalfNV, 4>)
STATICINLINE void vertex_attrib4h_nv(u32 index, vec_4_GLhalfNV const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4hNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4hNV"));
    }
    glVertexAttrib4hNV(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void vertex_attrib4hv_nv(u32 index, span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4hvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4hvNV"));
    }
    glVertexAttrib4hvNV(index, reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void vertex_attribs1hv_nv(u32 index, span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribs1hvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribs1hvNV"));
    }
    glVertexAttribs1hvNV(index, v.size(), reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void vertex_attribs2hv_nv(u32 index, span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribs2hvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribs2hvNV"));
    }
    glVertexAttribs2hvNV(index, v.size(), reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void vertex_attribs3hv_nv(u32 index, span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribs3hvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribs3hvNV"));
    }
    glVertexAttribs3hvNV(index, v.size(), reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void vertex_attribs4hv_nv(u32 index, span_const_GLhalfNV const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribs4hvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribs4hvNV"));
    }
    glVertexAttribs4hvNV(index, v.size(), reinterpret_cast<const GLhalfNV *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_weighth_nv(GLhalfNV weight)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexWeighthNV)
                Throw(undefined_behavior(
                    "unloaded function VertexWeighthNV"));
    }
    glVertexWeighthNV(weight);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLhalfNV
>
requires (
    semantic::concepts::Span<span_const_GLhalfNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLhalfNV::value_type>, GLhalfNV>)
STATICINLINE void vertex_weighthv_nv(span_const_GLhalfNV const& weight)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexWeighthvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexWeighthvNV"));
    }
    glVertexWeighthvNV(reinterpret_cast<const GLhalfNV *>(weight.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_half_float
#endif // GL_NV_half_float
#ifdef GL_NV_image_formats
namespace nv_image_formats {
} // nv_image_formats
#endif // GL_NV_image_formats
#ifdef GL_NV_instanced_arrays
namespace nv_instanced_arrays {
constexpr u32 vertex_attrib_array_divisor_nv = 0x88FE;
STATICINLINE void vertex_attrib_divisor_nv(u32 index, u32 divisor)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribDivisorNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribDivisorNV"));
    }
    glVertexAttribDivisorNV(index, divisor);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_instanced_arrays
#endif // GL_NV_instanced_arrays
#ifdef GL_NV_internalformat_sample_query
namespace nv_internalformat_sample_query {
constexpr u32 renderbuffer = 0x8D41;
constexpr u32 texture_2d_multisample = 0x9100;
constexpr u32 texture_2d_multisample_array = 0x9102;
constexpr u32 multisamples_nv = 0x9371;
constexpr u32 supersample_scale_x_nv = 0x9372;
constexpr u32 supersample_scale_y_nv = 0x9373;
constexpr u32 conformant_nv = 0x9374;
template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_internalformat_sampleiv_nv(groups::texture_target target, groups::internal_format internalformat, i32 samples, groups::internal_format_prop pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetInternalformatSampleivNV)
                Throw(undefined_behavior(
                    "unloaded function GetInternalformatSampleivNV"));
    }
    glGetInternalformatSampleivNV(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), samples, static_cast<GLenum>(pname), params.size(), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_internalformat_sample_query
#endif // GL_NV_internalformat_sample_query
#ifdef GL_NV_light_max_exponent
namespace nv_light_max_exponent {
constexpr u32 max_shininess_nv = 0x8504;
constexpr u32 max_spot_exponent_nv = 0x8505;
} // nv_light_max_exponent
#endif // GL_NV_light_max_exponent
#ifdef GL_NV_gpu_multicast
namespace nv_gpu_multicast {
constexpr u32 per_gpu_storage_bit_nv = 0x0800;
constexpr u32 multicast_gpus_nv = 0x92BA;
constexpr u32 per_gpu_storage_nv = 0x9548;
constexpr u32 multicast_programmable_sample_location_nv = 0x9549;
constexpr u32 render_gpu_mask_nv = 0x9558;
STATICINLINE void multicast_barrier_nv()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMulticastBarrierNV)
                Throw(undefined_behavior(
                    "unloaded function MulticastBarrierNV"));
    }
    glMulticastBarrierNV();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multicast_blit_framebuffer_nv(u32 srcGpu, u32 dstGpu, i32 srcX0, i32 srcY0, i32 srcX1, i32 srcY1, i32 dstX0, i32 dstY0, i32 dstX1, i32 dstY1, groups::clear_buffer_mask mask, GLenum filter)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMulticastBlitFramebufferNV)
                Throw(undefined_behavior(
                    "unloaded function MulticastBlitFramebufferNV"));
    }
    glMulticastBlitFramebufferNV(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, static_cast<GLenum>(mask), filter);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void multicast_buffer_sub_data_nv(GLbitfield gpuMask, u32 buffer, GLintptr offset, GLsizeiptr size, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMulticastBufferSubDataNV)
                Throw(undefined_behavior(
                    "unloaded function MulticastBufferSubDataNV"));
        glIsBuffer(buffer);
    }
    glMulticastBufferSubDataNV(gpuMask, buffer, offset, size, reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multicast_copy_buffer_sub_data_nv(u32 readGpu, GLbitfield writeGpuMask, u32 readBuffer, u32 writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMulticastCopyBufferSubDataNV)
                Throw(undefined_behavior(
                    "unloaded function MulticastCopyBufferSubDataNV"));
    }
    glMulticastCopyBufferSubDataNV(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multicast_copy_image_sub_data_nv(u32 srcGpu, GLbitfield dstGpuMask, u32 srcName, GLenum srcTarget, i32 srcLevel, i32 srcX, i32 srcY, i32 srcZ, u32 dstName, GLenum dstTarget, i32 dstLevel, i32 dstX, i32 dstY, i32 dstZ, i32 srcWidth, i32 srcHeight, i32 srcDepth)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMulticastCopyImageSubDataNV)
                Throw(undefined_behavior(
                    "unloaded function MulticastCopyImageSubDataNV"));
    }
    glMulticastCopyImageSubDataNV(srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void multicast_framebuffer_sample_locationsfv_nv(u32 gpu, u32 framebuffer, u32 start, i32 count, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMulticastFramebufferSampleLocationsfvNV)
                Throw(undefined_behavior(
                    "unloaded function MulticastFramebufferSampleLocationsfvNV"));
        glIsFramebuffer(framebuffer);
    }
    glMulticastFramebufferSampleLocationsfvNV(gpu, framebuffer, start, count, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i64
>
requires (
    semantic::concepts::Span<span_i64> &&
    std::is_same_v<std::decay_t<typename span_i64::value_type>, i64>)
STATICINLINE void multicast_get_query_objecti64v_nv(u32 gpu, u32 id, GLenum pname, span_i64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMulticastGetQueryObjecti64vNV)
                Throw(undefined_behavior(
                    "unloaded function MulticastGetQueryObjecti64vNV"));
    }
    glMulticastGetQueryObjecti64vNV(gpu, id, pname, reinterpret_cast<GLint64 *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void multicast_get_query_objectiv_nv(u32 gpu, u32 id, GLenum pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMulticastGetQueryObjectivNV)
                Throw(undefined_behavior(
                    "unloaded function MulticastGetQueryObjectivNV"));
    }
    glMulticastGetQueryObjectivNV(gpu, id, pname, reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u64
>
requires (
    semantic::concepts::Span<span_u64> &&
    std::is_same_v<std::decay_t<typename span_u64::value_type>, u64>)
STATICINLINE void multicast_get_query_objectui64v_nv(u32 gpu, u32 id, GLenum pname, span_u64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMulticastGetQueryObjectui64vNV)
                Throw(undefined_behavior(
                    "unloaded function MulticastGetQueryObjectui64vNV"));
    }
    glMulticastGetQueryObjectui64vNV(gpu, id, pname, reinterpret_cast<GLuint64 *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void multicast_get_query_objectuiv_nv(u32 gpu, u32 id, GLenum pname, span_u32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMulticastGetQueryObjectuivNV)
                Throw(undefined_behavior(
                    "unloaded function MulticastGetQueryObjectuivNV"));
    }
    glMulticastGetQueryObjectuivNV(gpu, id, pname, reinterpret_cast<GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multicast_wait_sync_nv(u32 signalGpu, GLbitfield waitGpuMask)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMulticastWaitSyncNV)
                Throw(undefined_behavior(
                    "unloaded function MulticastWaitSyncNV"));
    }
    glMulticastWaitSyncNV(signalGpu, waitGpuMask);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void render_gpu_mask_nv(GLbitfield mask)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glRenderGpuMaskNV)
                Throw(undefined_behavior(
                    "unloaded function RenderGpuMaskNV"));
    }
    glRenderGpuMaskNV(mask);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_gpu_multicast
#endif // GL_NV_gpu_multicast
#ifdef GL_NVX_gpu_multicast2
namespace nvx_gpu_multicast2 {
constexpr u32 upload_gpu_mask_nvx = 0x954A;
template<
    class span_const_u32,
    class span_const_u64
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32> &&
    semantic::concepts::Span<span_const_u64> &&
    std::is_same_v<std::decay_t<typename span_const_u64::value_type>, u64>)
STATICINLINE GLuint async_copy_buffer_sub_data_nvx(span_const_u32 const& waitSemaphoreArray, span_const_u64 const& fenceValueArray, u32 readGpu, GLbitfield writeGpuMask, u32 readBuffer, u32 writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, span_const_u32 const& signalSemaphoreArray, span_const_u64 const& signalValueArray)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glAsyncCopyBufferSubDataNVX)
                Throw(undefined_behavior(
                    "unloaded function AsyncCopyBufferSubDataNVX"));
    }
    auto out = glAsyncCopyBufferSubDataNVX(waitSemaphoreArray.size(), reinterpret_cast<const GLuint *>(waitSemaphoreArray.data()), reinterpret_cast<const GLuint64 *>(fenceValueArray.data()), readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreArray.size(), reinterpret_cast<const GLuint *>(signalSemaphoreArray.data()), reinterpret_cast<const GLuint64 *>(signalValueArray.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_u32,
    class span_const_u64
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32> &&
    semantic::concepts::Span<span_const_u64> &&
    std::is_same_v<std::decay_t<typename span_const_u64::value_type>, u64>)
STATICINLINE GLuint async_copy_image_sub_data_nvx(span_const_u32 const& waitSemaphoreArray, span_const_u64 const& waitValueArray, u32 srcGpu, GLbitfield dstGpuMask, u32 srcName, GLenum srcTarget, i32 srcLevel, i32 srcX, i32 srcY, i32 srcZ, u32 dstName, GLenum dstTarget, i32 dstLevel, i32 dstX, i32 dstY, i32 dstZ, i32 srcWidth, i32 srcHeight, i32 srcDepth, span_const_u32 const& signalSemaphoreArray, span_const_u64 const& signalValueArray)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glAsyncCopyImageSubDataNVX)
                Throw(undefined_behavior(
                    "unloaded function AsyncCopyImageSubDataNVX"));
    }
    auto out = glAsyncCopyImageSubDataNVX(waitSemaphoreArray.size(), reinterpret_cast<const GLuint *>(waitSemaphoreArray.data()), reinterpret_cast<const GLuint64 *>(waitValueArray.data()), srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreArray.size(), reinterpret_cast<const GLuint *>(signalSemaphoreArray.data()), reinterpret_cast<const GLuint64 *>(signalValueArray.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void multicast_scissor_arrayv_nvx(u32 gpu, u32 first, i32 count, span_const_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMulticastScissorArrayvNVX)
                Throw(undefined_behavior(
                    "unloaded function MulticastScissorArrayvNVX"));
    }
    glMulticastScissorArrayvNVX(gpu, first, count, reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void multicast_viewport_arrayv_nvx(u32 gpu, u32 first, i32 count, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMulticastViewportArrayvNVX)
                Throw(undefined_behavior(
                    "unloaded function MulticastViewportArrayvNVX"));
    }
    glMulticastViewportArrayvNVX(gpu, first, count, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multicast_viewport_position_w_scale_nvx(u32 gpu, u32 index, f32 xcoeff, f32 ycoeff)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMulticastViewportPositionWScaleNVX)
                Throw(undefined_behavior(
                    "unloaded function MulticastViewportPositionWScaleNVX"));
    }
    glMulticastViewportPositionWScaleNVX(gpu, index, xcoeff, ycoeff);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void upload_gpu_mask_nvx(GLbitfield mask)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUploadGpuMaskNVX)
                Throw(undefined_behavior(
                    "unloaded function UploadGpuMaskNVX"));
    }
    glUploadGpuMaskNVX(mask);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nvx_gpu_multicast2
#endif // GL_NVX_gpu_multicast2
#ifdef GL_NVX_progress_fence
namespace nvx_progress_fence {
template<
    class span_const_u32,
    class span_const_u64
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32> &&
    semantic::concepts::Span<span_const_u64> &&
    std::is_same_v<std::decay_t<typename span_const_u64::value_type>, u64>)
STATICINLINE void client_wait_semaphoreui64_nvx(span_const_u32 const& semaphoreArray, span_const_u64 const& fenceValueArray)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClientWaitSemaphoreui64NVX)
                Throw(undefined_behavior(
                    "unloaded function ClientWaitSemaphoreui64NVX"));
    }
    glClientWaitSemaphoreui64NVX(semaphoreArray.size(), reinterpret_cast<const GLuint *>(semaphoreArray.data()), reinterpret_cast<const GLuint64 *>(fenceValueArray.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLuint create_progress_fence_nvx()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCreateProgressFenceNVX)
                Throw(undefined_behavior(
                    "unloaded function CreateProgressFenceNVX"));
    }
    auto out = glCreateProgressFenceNVX();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_u32,
    class span_const_u64
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32> &&
    semantic::concepts::Span<span_const_u64> &&
    std::is_same_v<std::decay_t<typename span_const_u64::value_type>, u64>)
STATICINLINE void signal_semaphoreui64_nvx(u32 signalGpu, span_const_u32 const& semaphoreArray, span_const_u64 const& fenceValueArray)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSignalSemaphoreui64NVX)
                Throw(undefined_behavior(
                    "unloaded function SignalSemaphoreui64NVX"));
    }
    glSignalSemaphoreui64NVX(signalGpu, semaphoreArray.size(), reinterpret_cast<const GLuint *>(semaphoreArray.data()), reinterpret_cast<const GLuint64 *>(fenceValueArray.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32,
    class span_const_u64
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32> &&
    semantic::concepts::Span<span_const_u64> &&
    std::is_same_v<std::decay_t<typename span_const_u64::value_type>, u64>)
STATICINLINE void wait_semaphoreui64_nvx(u32 waitGpu, span_const_u32 const& semaphoreArray, span_const_u64 const& fenceValueArray)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWaitSemaphoreui64NVX)
                Throw(undefined_behavior(
                    "unloaded function WaitSemaphoreui64NVX"));
    }
    glWaitSemaphoreui64NVX(waitGpu, semaphoreArray.size(), reinterpret_cast<const GLuint *>(semaphoreArray.data()), reinterpret_cast<const GLuint64 *>(fenceValueArray.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nvx_progress_fence
#endif // GL_NVX_progress_fence
#ifdef GL_NV_memory_attachment
namespace nv_memory_attachment {
constexpr u32 attached_memory_object_nv = 0x95A4;
constexpr u32 attached_memory_offset_nv = 0x95A5;
constexpr u32 memory_attachable_alignment_nv = 0x95A6;
constexpr u32 memory_attachable_size_nv = 0x95A7;
constexpr u32 memory_attachable_nv = 0x95A8;
constexpr u32 detached_memory_incarnation_nv = 0x95A9;
constexpr u32 detached_textures_nv = 0x95AA;
constexpr u32 detached_buffers_nv = 0x95AB;
constexpr u32 max_detached_textures_nv = 0x95AC;
constexpr u32 max_detached_buffers_nv = 0x95AD;
STATICINLINE void buffer_attach_memory_nv(groups::buffer_target_arb target, u32 memory, u64 offset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBufferAttachMemoryNV)
                Throw(undefined_behavior(
                    "unloaded function BufferAttachMemoryNV"));
    }
    glBufferAttachMemoryNV(static_cast<GLenum>(target), memory, offset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_memory_object_detached_resourcesuiv_nv(u32 memory, GLenum pname, i32 first, i32 count, span_u32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetMemoryObjectDetachedResourcesuivNV)
                Throw(undefined_behavior(
                    "unloaded function GetMemoryObjectDetachedResourcesuivNV"));
    }
    glGetMemoryObjectDetachedResourcesuivNV(memory, pname, first, count, reinterpret_cast<GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void reset_memory_object_parameter_nv(u32 memory, GLenum pname)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glResetMemoryObjectParameterNV)
                Throw(undefined_behavior(
                    "unloaded function ResetMemoryObjectParameterNV"));
    }
    glResetMemoryObjectParameterNV(memory, pname);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_attach_memory_nv(groups::texture_target target, u32 memory, u64 offset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexAttachMemoryNV)
                Throw(undefined_behavior(
                    "unloaded function TexAttachMemoryNV"));
    }
    glTexAttachMemoryNV(static_cast<GLenum>(target), memory, offset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void named_buffer_attach_memory_nv(u32 buffer, u32 memory, u64 offset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedBufferAttachMemoryNV)
                Throw(undefined_behavior(
                    "unloaded function NamedBufferAttachMemoryNV"));
        glIsBuffer(buffer);
    }
    glNamedBufferAttachMemoryNV(buffer, memory, offset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void texture_attach_memory_nv(u32 texture, u32 memory, u64 offset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureAttachMemoryNV)
                Throw(undefined_behavior(
                    "unloaded function TextureAttachMemoryNV"));
        glIsTexture(texture);
    }
    glTextureAttachMemoryNV(texture, memory, offset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_memory_attachment
#endif // GL_NV_memory_attachment
#ifdef GL_NV_memory_object_sparse
namespace nv_memory_object_sparse {
STATICINLINE void buffer_page_commitment_mem_nv(groups::buffer_storage_target target, GLintptr offset, GLsizeiptr size, u32 memory, u64 memOffset, bool commit)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBufferPageCommitmentMemNV)
                Throw(undefined_behavior(
                    "unloaded function BufferPageCommitmentMemNV"));
    }
    glBufferPageCommitmentMemNV(static_cast<GLenum>(target), offset, size, memory, memOffset, commit);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void tex_page_commitment_mem_nv(groups::texture_target target, i32 layer, i32 level, vec_3_i32 const& xoffset, vec_3_i32 const& width, u32 memory, u64 offset, bool commit)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexPageCommitmentMemNV)
                Throw(undefined_behavior(
                    "unloaded function TexPageCommitmentMemNV"));
    }
    glTexPageCommitmentMemNV(static_cast<GLenum>(target), layer, level, xoffset.x(), xoffset.y(), xoffset.z(), width[0], width[1], width[2], memory, offset, commit);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void named_buffer_page_commitment_mem_nv(u32 buffer, GLintptr offset, GLsizeiptr size, u32 memory, u64 memOffset, bool commit)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedBufferPageCommitmentMemNV)
                Throw(undefined_behavior(
                    "unloaded function NamedBufferPageCommitmentMemNV"));
        glIsBuffer(buffer);
    }
    glNamedBufferPageCommitmentMemNV(buffer, offset, size, memory, memOffset, commit);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void texture_page_commitment_mem_nv(u32 texture, i32 layer, i32 level, vec_3_i32 const& xoffset, vec_3_i32 const& width, u32 memory, u64 offset, bool commit)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexturePageCommitmentMemNV)
                Throw(undefined_behavior(
                    "unloaded function TexturePageCommitmentMemNV"));
        glIsTexture(texture);
    }
    glTexturePageCommitmentMemNV(texture, layer, level, xoffset.x(), xoffset.y(), xoffset.z(), width[0], width[1], width[2], memory, offset, commit);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_memory_object_sparse
#endif // GL_NV_memory_object_sparse
#ifdef GL_NV_mesh_shader
namespace nv_mesh_shader {
constexpr u32 mesh_shader_bit_nv = 0x00000040;
constexpr u32 task_shader_bit_nv = 0x00000080;
constexpr u32 max_mesh_uniform_blocks_nv = 0x8E60;
constexpr u32 max_mesh_texture_image_units_nv = 0x8E61;
constexpr u32 max_mesh_image_uniforms_nv = 0x8E62;
constexpr u32 max_mesh_uniform_components_nv = 0x8E63;
constexpr u32 max_mesh_atomic_counter_buffers_nv = 0x8E64;
constexpr u32 max_mesh_atomic_counters_nv = 0x8E65;
constexpr u32 max_mesh_shader_storage_blocks_nv = 0x8E66;
constexpr u32 max_combined_mesh_uniform_components_nv = 0x8E67;
constexpr u32 max_task_uniform_blocks_nv = 0x8E68;
constexpr u32 max_task_texture_image_units_nv = 0x8E69;
constexpr u32 max_task_image_uniforms_nv = 0x8E6A;
constexpr u32 max_task_uniform_components_nv = 0x8E6B;
constexpr u32 max_task_atomic_counter_buffers_nv = 0x8E6C;
constexpr u32 max_task_atomic_counters_nv = 0x8E6D;
constexpr u32 max_task_shader_storage_blocks_nv = 0x8E6E;
constexpr u32 max_combined_task_uniform_components_nv = 0x8E6F;
constexpr u32 mesh_output_per_vertex_granularity_nv = 0x92DF;
constexpr u32 max_mesh_total_memory_size_nv = 0x9536;
constexpr u32 max_task_total_memory_size_nv = 0x9537;
constexpr u32 max_mesh_output_vertices_nv = 0x9538;
constexpr u32 max_mesh_output_primitives_nv = 0x9539;
constexpr u32 max_task_output_count_nv = 0x953A;
constexpr u32 max_mesh_work_group_size_nv = 0x953B;
constexpr u32 max_task_work_group_size_nv = 0x953C;
constexpr u32 max_draw_mesh_tasks_count_nv = 0x953D;
constexpr u32 mesh_work_group_size_nv = 0x953E;
constexpr u32 task_work_group_size_nv = 0x953F;
constexpr u32 mesh_output_per_primitive_granularity_nv = 0x9543;
constexpr u32 max_mesh_views_nv = 0x9557;
constexpr u32 mesh_shader_nv = 0x9559;
constexpr u32 task_shader_nv = 0x955A;
constexpr u32 mesh_vertices_out_nv = 0x9579;
constexpr u32 mesh_primitives_out_nv = 0x957A;
constexpr u32 mesh_output_type_nv = 0x957B;
constexpr u32 mesh_subroutine_nv = 0x957C;
constexpr u32 task_subroutine_nv = 0x957D;
constexpr u32 mesh_subroutine_uniform_nv = 0x957E;
constexpr u32 task_subroutine_uniform_nv = 0x957F;
constexpr u32 uniform_block_referenced_by_mesh_shader_nv = 0x959C;
constexpr u32 uniform_block_referenced_by_task_shader_nv = 0x959D;
constexpr u32 atomic_counter_buffer_referenced_by_mesh_shader_nv = 0x959E;
constexpr u32 atomic_counter_buffer_referenced_by_task_shader_nv = 0x959F;
constexpr u32 referenced_by_mesh_shader_nv = 0x95A0;
constexpr u32 referenced_by_task_shader_nv = 0x95A1;
constexpr u32 max_mesh_work_group_invocations_nv = 0x95A2;
constexpr u32 max_task_work_group_invocations_nv = 0x95A3;
STATICINLINE void draw_mesh_tasks_nv(u32 first, u32 count)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawMeshTasksNV)
                Throw(undefined_behavior(
                    "unloaded function DrawMeshTasksNV"));
    }
    glDrawMeshTasksNV(first, count);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void draw_mesh_tasks_indirect_nv(GLintptr indirect)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawMeshTasksIndirectNV)
                Throw(undefined_behavior(
                    "unloaded function DrawMeshTasksIndirectNV"));
    }
    glDrawMeshTasksIndirectNV(indirect);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_draw_mesh_tasks_indirect_nv(GLintptr indirect, i32 drawcount, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiDrawMeshTasksIndirectNV)
                Throw(undefined_behavior(
                    "unloaded function MultiDrawMeshTasksIndirectNV"));
    }
    glMultiDrawMeshTasksIndirectNV(indirect, drawcount, stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_draw_mesh_tasks_indirect_count_nv(GLintptr indirect, GLintptr drawcount, i32 maxdrawcount, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiDrawMeshTasksIndirectCountNV)
                Throw(undefined_behavior(
                    "unloaded function MultiDrawMeshTasksIndirectCountNV"));
    }
    glMultiDrawMeshTasksIndirectCountNV(indirect, drawcount, maxdrawcount, stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_mesh_shader
#endif // GL_NV_mesh_shader
#ifdef GL_NV_multisample_coverage
namespace nv_multisample_coverage {
constexpr u32 samples_arb = 0x80A9;
constexpr u32 color_samples_nv = 0x8E20;
} // nv_multisample_coverage
#endif // GL_NV_multisample_coverage
#ifdef GL_NV_multisample_filter_hint
namespace nv_multisample_filter_hint {
constexpr u32 multisample_filter_hint_nv = 0x8534;
} // nv_multisample_filter_hint
#endif // GL_NV_multisample_filter_hint
#ifdef GL_NV_non_square_matrices
namespace nv_non_square_matrices {
constexpr u32 float_mat2x3_nv = 0x8B65;
constexpr u32 float_mat2x4_nv = 0x8B66;
constexpr u32 float_mat3x2_nv = 0x8B67;
constexpr u32 float_mat3x4_nv = 0x8B68;
constexpr u32 float_mat4x2_nv = 0x8B69;
constexpr u32 float_mat4x3_nv = 0x8B6A;
template<
    class span_const_mat_2x3_f32
>
requires (
    semantic::concepts::Span<span_const_mat_2x3_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_2x3_f32::value_type, f32, 2, 3>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_2x3_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix2x3fvNV)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix2x3fvNV"));
    }
    glUniformMatrix2x3fvNV(location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_2x4_f32
>
requires (
    semantic::concepts::Span<span_const_mat_2x4_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_2x4_f32::value_type, f32, 2, 4>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_2x4_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix2x4fvNV)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix2x4fvNV"));
    }
    glUniformMatrix2x4fvNV(location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x2_f32
>
requires (
    semantic::concepts::Span<span_const_mat_3x2_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_3x2_f32::value_type, f32, 3, 2>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_3x2_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix3x2fvNV)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix3x2fvNV"));
    }
    glUniformMatrix3x2fvNV(location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x4_f32
>
requires (
    semantic::concepts::Span<span_const_mat_3x4_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_3x4_f32::value_type, f32, 3, 4>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_3x4_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix3x4fvNV)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix3x4fvNV"));
    }
    glUniformMatrix3x4fvNV(location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_4x2_f32
>
requires (
    semantic::concepts::Span<span_const_mat_4x2_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_4x2_f32::value_type, f32, 4, 2>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_4x2_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix4x2fvNV)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix4x2fvNV"));
    }
    glUniformMatrix4x2fvNV(location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_4x3_f32
>
requires (
    semantic::concepts::Span<span_const_mat_4x3_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_4x3_f32::value_type, f32, 4, 3>)
STATICINLINE void uniform(i32 location, i32 count, bool transpose, span_const_mat_4x3_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformMatrix4x3fvNV)
                Throw(undefined_behavior(
                    "unloaded function UniformMatrix4x3fvNV"));
    }
    glUniformMatrix4x3fvNV(location, count, transpose, reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_non_square_matrices
#endif // GL_NV_non_square_matrices
#ifdef GL_NV_occlusion_query
namespace nv_occlusion_query {
constexpr u32 pixel_counter_bits_nv = 0x8864;
constexpr u32 current_occlusion_query_id_nv = 0x8865;
constexpr u32 pixel_count_nv = 0x8866;
constexpr u32 pixel_count_available_nv = 0x8867;
STATICINLINE void begin_occlusion_query_nv(u32 id)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBeginOcclusionQueryNV)
                Throw(undefined_behavior(
                    "unloaded function BeginOcclusionQueryNV"));
    }
    glBeginOcclusionQueryNV(id);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_occlusion_queries_nv(span_const_u32 const& ids)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteOcclusionQueriesNV)
                Throw(undefined_behavior(
                    "unloaded function DeleteOcclusionQueriesNV"));
    }
    glDeleteOcclusionQueriesNV(ids.size(), reinterpret_cast<const GLuint *>(ids.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void end_occlusion_query_nv()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEndOcclusionQueryNV)
                Throw(undefined_behavior(
                    "unloaded function EndOcclusionQueryNV"));
    }
    glEndOcclusionQueryNV();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void gen_occlusion_queries_nv(span_u32 ids)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenOcclusionQueriesNV)
                Throw(undefined_behavior(
                    "unloaded function GenOcclusionQueriesNV"));
    }
    glGenOcclusionQueriesNV(ids.size(), reinterpret_cast<GLuint *>(ids.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_occlusion_queryiv_nv(u32 id, groups::occlusion_query_parameter_name_nv pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetOcclusionQueryivNV)
                Throw(undefined_behavior(
                    "unloaded function GetOcclusionQueryivNV"));
    }
    glGetOcclusionQueryivNV(id, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_occlusion_queryuiv_nv(u32 id, groups::occlusion_query_parameter_name_nv pname, span_u32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetOcclusionQueryuivNV)
                Throw(undefined_behavior(
                    "unloaded function GetOcclusionQueryuivNV"));
    }
    glGetOcclusionQueryuivNV(id, static_cast<GLenum>(pname), reinterpret_cast<GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_occlusion_query_nv(u32 id)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsOcclusionQueryNV)
                Throw(undefined_behavior(
                    "unloaded function IsOcclusionQueryNV"));
    }
    auto out = glIsOcclusionQueryNV(id);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // nv_occlusion_query
#endif // GL_NV_occlusion_query
#ifdef GL_NV_packed_depth_stencil
namespace nv_packed_depth_stencil {
constexpr u32 depth_stencil_nv = 0x84F9;
constexpr u32 unsigned_int_24_8_nv = 0x84FA;
} // nv_packed_depth_stencil
#endif // GL_NV_packed_depth_stencil
#ifdef GL_NV_parameter_buffer_object
namespace nv_parameter_buffer_object {
constexpr u32 max_program_parameter_buffer_bindings_nv = 0x8DA0;
constexpr u32 max_program_parameter_buffer_size_nv = 0x8DA1;
constexpr u32 vertex_program_parameter_buffer_nv = 0x8DA2;
constexpr u32 geometry_program_parameter_buffer_nv = 0x8DA3;
constexpr u32 fragment_program_parameter_buffer_nv = 0x8DA4;
template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void program_buffer_parameters_iiv_nv(groups::program_target target, u32 bindingIndex, u32 wordIndex, span_const_i32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramBufferParametersIivNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramBufferParametersIivNV"));
    }
    glProgramBufferParametersIivNV(static_cast<GLenum>(target), bindingIndex, wordIndex, params.size(), reinterpret_cast<const GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void program_buffer_parameters_iuiv_nv(groups::program_target target, u32 bindingIndex, u32 wordIndex, span_const_u32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramBufferParametersIuivNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramBufferParametersIuivNV"));
    }
    glProgramBufferParametersIuivNV(static_cast<GLenum>(target), bindingIndex, wordIndex, params.size(), reinterpret_cast<const GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void program_buffer_parametersfv_nv(groups::program_target target, u32 bindingIndex, u32 wordIndex, span_const_f32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramBufferParametersfvNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramBufferParametersfvNV"));
    }
    glProgramBufferParametersfvNV(static_cast<GLenum>(target), bindingIndex, wordIndex, params.size(), reinterpret_cast<const GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_parameter_buffer_object
#endif // GL_NV_parameter_buffer_object
#ifdef GL_NV_parameter_buffer_object2
namespace nv_parameter_buffer_object2 {
} // nv_parameter_buffer_object2
#endif // GL_NV_parameter_buffer_object2
#ifdef GL_NV_path_rendering
namespace nv_path_rendering {
constexpr u32 bold_bit_nv = 0x01;
constexpr u32 italic_bit_nv = 0x02;
constexpr u32 glyph_width_bit_nv = 0x01;
constexpr u32 glyph_height_bit_nv = 0x02;
constexpr u32 glyph_horizontal_bearing_x_bit_nv = 0x04;
constexpr u32 glyph_horizontal_bearing_y_bit_nv = 0x08;
constexpr u32 glyph_horizontal_bearing_advance_bit_nv = 0x10;
constexpr u32 glyph_vertical_bearing_x_bit_nv = 0x20;
constexpr u32 glyph_vertical_bearing_y_bit_nv = 0x40;
constexpr u32 glyph_vertical_bearing_advance_bit_nv = 0x80;
constexpr u32 glyph_has_kerning_bit_nv = 0x100;
constexpr u32 font_x_min_bounds_bit_nv = 0x00010000;
constexpr u32 font_y_min_bounds_bit_nv = 0x00020000;
constexpr u32 font_x_max_bounds_bit_nv = 0x00040000;
constexpr u32 font_y_max_bounds_bit_nv = 0x00080000;
constexpr u32 font_units_per_em_bit_nv = 0x00100000;
constexpr u32 font_ascender_bit_nv = 0x00200000;
constexpr u32 font_descender_bit_nv = 0x00400000;
constexpr u32 font_height_bit_nv = 0x00800000;
constexpr u32 font_max_advance_width_bit_nv = 0x01000000;
constexpr u32 font_max_advance_height_bit_nv = 0x02000000;
constexpr u32 font_underline_position_bit_nv = 0x04000000;
constexpr u32 font_underline_thickness_bit_nv = 0x08000000;
constexpr u32 font_has_kerning_bit_nv = 0x10000000;
constexpr u32 font_num_glyph_indices_bit_nv = 0x20000000;
constexpr u32 close_path_nv = 0x00;
constexpr u32 move_to_nv = 0x02;
constexpr u32 relative_move_to_nv = 0x03;
constexpr u32 line_to_nv = 0x04;
constexpr u32 relative_line_to_nv = 0x05;
constexpr u32 horizontal_line_to_nv = 0x06;
constexpr u32 relative_horizontal_line_to_nv = 0x07;
constexpr u32 vertical_line_to_nv = 0x08;
constexpr u32 relative_vertical_line_to_nv = 0x09;
constexpr u32 quadratic_curve_to_nv = 0x0A;
constexpr u32 relative_quadratic_curve_to_nv = 0x0B;
constexpr u32 cubic_curve_to_nv = 0x0C;
constexpr u32 relative_cubic_curve_to_nv = 0x0D;
constexpr u32 smooth_quadratic_curve_to_nv = 0x0E;
constexpr u32 relative_smooth_quadratic_curve_to_nv = 0x0F;
constexpr u32 smooth_cubic_curve_to_nv = 0x10;
constexpr u32 relative_smooth_cubic_curve_to_nv = 0x11;
constexpr u32 small_ccw_arc_to_nv = 0x12;
constexpr u32 relative_small_ccw_arc_to_nv = 0x13;
constexpr u32 small_cw_arc_to_nv = 0x14;
constexpr u32 relative_small_cw_arc_to_nv = 0x15;
constexpr u32 large_ccw_arc_to_nv = 0x16;
constexpr u32 relative_large_ccw_arc_to_nv = 0x17;
constexpr u32 large_cw_arc_to_nv = 0x18;
constexpr u32 relative_large_cw_arc_to_nv = 0x19;
constexpr u32 conic_curve_to_nv = 0x1A;
constexpr u32 relative_conic_curve_to_nv = 0x1B;
constexpr u32 rounded_rect_nv = 0xE8;
constexpr u32 relative_rounded_rect_nv = 0xE9;
constexpr u32 rounded_rect2_nv = 0xEA;
constexpr u32 relative_rounded_rect2_nv = 0xEB;
constexpr u32 rounded_rect4_nv = 0xEC;
constexpr u32 relative_rounded_rect4_nv = 0xED;
constexpr u32 rounded_rect8_nv = 0xEE;
constexpr u32 relative_rounded_rect8_nv = 0xEF;
constexpr u32 restart_path_nv = 0xF0;
constexpr u32 dup_first_cubic_curve_to_nv = 0xF2;
constexpr u32 dup_last_cubic_curve_to_nv = 0xF4;
constexpr u32 rect_nv = 0xF6;
constexpr u32 relative_rect_nv = 0xF7;
constexpr u32 circular_ccw_arc_to_nv = 0xF8;
constexpr u32 circular_cw_arc_to_nv = 0xFA;
constexpr u32 circular_tangent_arc_to_nv = 0xFC;
constexpr u32 arc_to_nv = 0xFE;
constexpr u32 relative_arc_to_nv = 0xFF;
constexpr u32 path_modelview_stack_depth_nv = 0x0BA3;
constexpr u32 path_projection_stack_depth_nv = 0x0BA4;
constexpr u32 path_modelview_matrix_nv = 0x0BA6;
constexpr u32 path_projection_matrix_nv = 0x0BA7;
constexpr u32 path_max_modelview_stack_depth_nv = 0x0D36;
constexpr u32 path_max_projection_stack_depth_nv = 0x0D38;
constexpr u32 2_bytes_nv = 0x1407;
constexpr u32 3_bytes_nv = 0x1408;
constexpr u32 4_bytes_nv = 0x1409;
constexpr u32 path_modelview_nv = 0x1700;
constexpr u32 path_projection_nv = 0x1701;
constexpr u32 eye_linear_nv = 0x2400;
constexpr u32 object_linear_nv = 0x2401;
constexpr u32 path_transpose_modelview_matrix_nv = 0x84E3;
constexpr u32 path_transpose_projection_matrix_nv = 0x84E4;
constexpr u32 primary_color_nv = 0x852C;
constexpr u32 secondary_color_nv = 0x852D;
constexpr u32 constant_nv = 0x8576;
constexpr u32 primary_color = 0x8577;
constexpr u32 path_format_svg_nv = 0x9070;
constexpr u32 path_format_ps_nv = 0x9071;
constexpr u32 standard_font_name_nv = 0x9072;
constexpr u32 system_font_name_nv = 0x9073;
constexpr u32 file_name_nv = 0x9074;
constexpr u32 path_stroke_width_nv = 0x9075;
constexpr u32 path_end_caps_nv = 0x9076;
constexpr u32 path_initial_end_cap_nv = 0x9077;
constexpr u32 path_terminal_end_cap_nv = 0x9078;
constexpr u32 path_join_style_nv = 0x9079;
constexpr u32 path_miter_limit_nv = 0x907A;
constexpr u32 path_dash_caps_nv = 0x907B;
constexpr u32 path_initial_dash_cap_nv = 0x907C;
constexpr u32 path_terminal_dash_cap_nv = 0x907D;
constexpr u32 path_dash_offset_nv = 0x907E;
constexpr u32 path_client_length_nv = 0x907F;
constexpr u32 path_fill_mode_nv = 0x9080;
constexpr u32 path_fill_mask_nv = 0x9081;
constexpr u32 path_fill_cover_mode_nv = 0x9082;
constexpr u32 path_stroke_cover_mode_nv = 0x9083;
constexpr u32 path_stroke_mask_nv = 0x9084;
constexpr u32 count_up_nv = 0x9088;
constexpr u32 count_down_nv = 0x9089;
constexpr u32 path_object_bounding_box_nv = 0x908A;
constexpr u32 convex_hull_nv = 0x908B;
constexpr u32 bounding_box_nv = 0x908D;
constexpr u32 translate_x_nv = 0x908E;
constexpr u32 translate_y_nv = 0x908F;
constexpr u32 translate_2d_nv = 0x9090;
constexpr u32 translate_3d_nv = 0x9091;
constexpr u32 affine_2d_nv = 0x9092;
constexpr u32 affine_3d_nv = 0x9094;
constexpr u32 transpose_affine_2d_nv = 0x9096;
constexpr u32 transpose_affine_3d_nv = 0x9098;
constexpr u32 utf8_nv = 0x909A;
constexpr u32 utf16_nv = 0x909B;
constexpr u32 bounding_box_of_bounding_boxes_nv = 0x909C;
constexpr u32 path_command_count_nv = 0x909D;
constexpr u32 path_coord_count_nv = 0x909E;
constexpr u32 path_dash_array_count_nv = 0x909F;
constexpr u32 path_computed_length_nv = 0x90A0;
constexpr u32 path_fill_bounding_box_nv = 0x90A1;
constexpr u32 path_stroke_bounding_box_nv = 0x90A2;
constexpr u32 square_nv = 0x90A3;
constexpr u32 round_nv = 0x90A4;
constexpr u32 triangular_nv = 0x90A5;
constexpr u32 bevel_nv = 0x90A6;
constexpr u32 miter_revert_nv = 0x90A7;
constexpr u32 miter_truncate_nv = 0x90A8;
constexpr u32 skip_missing_glyph_nv = 0x90A9;
constexpr u32 use_missing_glyph_nv = 0x90AA;
constexpr u32 path_error_position_nv = 0x90AB;
constexpr u32 path_fog_gen_mode_nv = 0x90AC;
constexpr u32 accum_adjacent_pairs_nv = 0x90AD;
constexpr u32 adjacent_pairs_nv = 0x90AE;
constexpr u32 first_to_rest_nv = 0x90AF;
constexpr u32 path_gen_mode_nv = 0x90B0;
constexpr u32 path_gen_coeff_nv = 0x90B1;
constexpr u32 path_gen_color_format_nv = 0x90B2;
constexpr u32 path_gen_components_nv = 0x90B3;
constexpr u32 path_dash_offset_reset_nv = 0x90B4;
constexpr u32 move_to_resets_nv = 0x90B5;
constexpr u32 move_to_continues_nv = 0x90B6;
constexpr u32 path_stencil_func_nv = 0x90B7;
constexpr u32 path_stencil_ref_nv = 0x90B8;
constexpr u32 path_stencil_value_mask_nv = 0x90B9;
constexpr u32 path_stencil_depth_offset_factor_nv = 0x90BD;
constexpr u32 path_stencil_depth_offset_units_nv = 0x90BE;
constexpr u32 path_cover_depth_func_nv = 0x90BF;
constexpr u32 font_glyphs_available_nv = 0x9368;
constexpr u32 font_target_unavailable_nv = 0x9369;
constexpr u32 font_unavailable_nv = 0x936A;
constexpr u32 font_unintelligible_nv = 0x936B;
constexpr u32 standard_font_format_nv = 0x936C;
constexpr u32 fragment_input_nv = 0x936D;
STATICINLINE void copy_path_nv(u32 resultPath, u32 srcPath)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCopyPathNV)
                Throw(undefined_behavior(
                    "unloaded function CopyPathNV"));
    }
    glCopyPathNV(resultPath, srcPath);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte> &&
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void cover_fill_path_instanced_nv(i32 numPaths, groups::path_element_type pathNameType, span_const_byte const& paths, u32 pathBase, groups::path_cover_mode coverMode, groups::path_transform_type transformType, span_const_f32 const& transformValues)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCoverFillPathInstancedNV)
                Throw(undefined_behavior(
                    "unloaded function CoverFillPathInstancedNV"));
    }
    glCoverFillPathInstancedNV(numPaths, static_cast<GLenum>(pathNameType), reinterpret_cast<const void *>(paths.data()), pathBase, static_cast<GLenum>(coverMode), static_cast<GLenum>(transformType), reinterpret_cast<const GLfloat *>(transformValues.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void cover_fill_path_nv(u32 path, groups::path_cover_mode coverMode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCoverFillPathNV)
                Throw(undefined_behavior(
                    "unloaded function CoverFillPathNV"));
    }
    glCoverFillPathNV(path, static_cast<GLenum>(coverMode));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte> &&
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void cover_stroke_path_instanced_nv(i32 numPaths, groups::path_element_type pathNameType, span_const_byte const& paths, u32 pathBase, groups::path_cover_mode coverMode, groups::path_transform_type transformType, span_const_f32 const& transformValues)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCoverStrokePathInstancedNV)
                Throw(undefined_behavior(
                    "unloaded function CoverStrokePathInstancedNV"));
    }
    glCoverStrokePathInstancedNV(numPaths, static_cast<GLenum>(pathNameType), reinterpret_cast<const void *>(paths.data()), pathBase, static_cast<GLenum>(coverMode), static_cast<GLenum>(transformType), reinterpret_cast<const GLfloat *>(transformValues.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void cover_stroke_path_nv(u32 path, groups::path_cover_mode coverMode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCoverStrokePathNV)
                Throw(undefined_behavior(
                    "unloaded function CoverStrokePathNV"));
    }
    glCoverStrokePathNV(path, static_cast<GLenum>(coverMode));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void delete_paths_nv(u32 path, i32 range)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeletePathsNV)
                Throw(undefined_behavior(
                    "unloaded function DeletePathsNV"));
    }
    glDeletePathsNV(path, range);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLuint gen_paths_nv(i32 range)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenPathsNV)
                Throw(undefined_behavior(
                    "unloaded function GenPathsNV"));
    }
    auto out = glGenPathsNV(range);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_u8
>
requires (
    semantic::concepts::Span<span_u8> &&
    std::is_same_v<std::decay_t<typename span_u8::value_type>, u8>)
STATICINLINE void get_path_commands_nv(u32 path, span_u8 commands)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPathCommandsNV)
                Throw(undefined_behavior(
                    "unloaded function GetPathCommandsNV"));
    }
    glGetPathCommandsNV(path, reinterpret_cast<GLubyte *>(commands.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_path_coords_nv(u32 path, span_f32 coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPathCoordsNV)
                Throw(undefined_behavior(
                    "unloaded function GetPathCoordsNV"));
    }
    glGetPathCoordsNV(path, reinterpret_cast<GLfloat *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_path_dash_array_nv(u32 path, span_f32 dashArray)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPathDashArrayNV)
                Throw(undefined_behavior(
                    "unloaded function GetPathDashArrayNV"));
    }
    glGetPathDashArrayNV(path, reinterpret_cast<GLfloat *>(dashArray.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLfloat get_path_length_nv(u32 path, i32 startSegment, i32 numSegments)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPathLengthNV)
                Throw(undefined_behavior(
                    "unloaded function GetPathLengthNV"));
    }
    auto out = glGetPathLengthNV(path, startSegment, numSegments);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_path_metric_range_nv(groups::path_metric_mask metricQueryMask, u32 firstPathName, i32 numPaths, i32 stride, span_f32 metrics)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPathMetricRangeNV)
                Throw(undefined_behavior(
                    "unloaded function GetPathMetricRangeNV"));
    }
    glGetPathMetricRangeNV(static_cast<GLenum>(metricQueryMask), firstPathName, numPaths, stride, reinterpret_cast<GLfloat *>(metrics.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class span_f32
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte> &&
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_path_metrics_nv(groups::path_metric_mask metricQueryMask, i32 numPaths, groups::path_element_type pathNameType, span_const_byte const& paths, u32 pathBase, i32 stride, span_f32 metrics)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPathMetricsNV)
                Throw(undefined_behavior(
                    "unloaded function GetPathMetricsNV"));
    }
    glGetPathMetricsNV(static_cast<GLenum>(metricQueryMask), numPaths, static_cast<GLenum>(pathNameType), reinterpret_cast<const void *>(paths.data()), pathBase, stride, reinterpret_cast<GLfloat *>(metrics.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_path_parameterfv_nv(u32 path, groups::path_parameter pname, span_f32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPathParameterfvNV)
                Throw(undefined_behavior(
                    "unloaded function GetPathParameterfvNV"));
    }
    glGetPathParameterfvNV(path, static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_path_parameteriv_nv(u32 path, groups::path_parameter pname, span_i32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPathParameterivNV)
                Throw(undefined_behavior(
                    "unloaded function GetPathParameterivNV"));
    }
    glGetPathParameterivNV(path, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class span_f32
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte> &&
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_path_spacing_nv(groups::path_list_mode pathListMode, i32 numPaths, groups::path_element_type pathNameType, span_const_byte const& paths, u32 pathBase, f32 advanceScale, f32 kerningScale, groups::path_transform_type transformType, span_f32 returnedSpacing)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPathSpacingNV)
                Throw(undefined_behavior(
                    "unloaded function GetPathSpacingNV"));
    }
    glGetPathSpacingNV(static_cast<GLenum>(pathListMode), numPaths, static_cast<GLenum>(pathNameType), reinterpret_cast<const void *>(paths.data()), pathBase, advanceScale, kerningScale, static_cast<GLenum>(transformType), reinterpret_cast<GLfloat *>(returnedSpacing.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void interpolate_paths_nv(u32 resultPath, u32 pathA, u32 pathB, f32 weight)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glInterpolatePathsNV)
                Throw(undefined_behavior(
                    "unloaded function InterpolatePathsNV"));
    }
    glInterpolatePathsNV(resultPath, pathA, pathB, weight);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_path_nv(u32 path)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsPathNV)
                Throw(undefined_behavior(
                    "unloaded function IsPathNV"));
    }
    auto out = glIsPathNV(path);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class vec_2_f32
>
requires (
    semantic::concepts::Vector<vec_2_f32, f32, 2>)
STATICINLINE GLboolean is_point_in_fill_path_nv(u32 path, u32 mask, vec_2_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsPointInFillPathNV)
                Throw(undefined_behavior(
                    "unloaded function IsPointInFillPathNV"));
    }
    auto out = glIsPointInFillPathNV(path, mask, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class vec_2_f32
>
requires (
    semantic::concepts::Vector<vec_2_f32, f32, 2>)
STATICINLINE GLboolean is_point_in_stroke_path_nv(u32 path, vec_2_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsPointInStrokePathNV)
                Throw(undefined_behavior(
                    "unloaded function IsPointInStrokePathNV"));
    }
    auto out = glIsPointInStrokePathNV(path, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_byte,
    class span_const_u8
>
requires (
    semantic::concepts::Span<span_const_u8> &&
    std::is_same_v<std::decay_t<typename span_const_u8::value_type>, u8> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void path_commands_nv(u32 path, span_const_u8 const& commands, i32 numCoords, groups::path_coord_type coordType, span_const_byte const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathCommandsNV)
                Throw(undefined_behavior(
                    "unloaded function PathCommandsNV"));
    }
    glPathCommandsNV(path, commands.size(), reinterpret_cast<const GLubyte *>(commands.data()), numCoords, static_cast<GLenum>(coordType), reinterpret_cast<const void *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void path_coords_nv(u32 path, i32 numCoords, groups::path_coord_type coordType, span_const_byte const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathCoordsNV)
                Throw(undefined_behavior(
                    "unloaded function PathCoordsNV"));
    }
    glPathCoordsNV(path, numCoords, static_cast<GLenum>(coordType), reinterpret_cast<const void *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void path_cover_depth_func_nv(groups::depth_function func)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathCoverDepthFuncNV)
                Throw(undefined_behavior(
                    "unloaded function PathCoverDepthFuncNV"));
    }
    glPathCoverDepthFuncNV(static_cast<GLenum>(func));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void path_dash_array_nv(u32 path, span_const_f32 const& dashArray)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathDashArrayNV)
                Throw(undefined_behavior(
                    "unloaded function PathDashArrayNV"));
    }
    glPathDashArrayNV(path, dashArray.size(), reinterpret_cast<const GLfloat *>(dashArray.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void path_glyph_range_nv(u32 firstPathName, groups::path_font_target fontTarget, span_const_byte const& fontName, groups::path_font_style fontStyle, u32 firstGlyph, i32 numGlyphs, groups::path_handle_missing_glyphs handleMissingGlyphs, u32 pathParameterTemplate, f32 emScale)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathGlyphRangeNV)
                Throw(undefined_behavior(
                    "unloaded function PathGlyphRangeNV"));
    }
    glPathGlyphRangeNV(firstPathName, static_cast<GLenum>(fontTarget), reinterpret_cast<const void *>(fontName.data()), static_cast<GLenum>(fontStyle), firstGlyph, numGlyphs, static_cast<GLenum>(handleMissingGlyphs), pathParameterTemplate, emScale);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void path_glyphs_nv(u32 firstPathName, groups::path_font_target fontTarget, span_const_byte const& fontName, groups::path_font_style fontStyle, i32 numGlyphs, groups::path_element_type type, span_const_byte const& charcodes, groups::path_handle_missing_glyphs handleMissingGlyphs, u32 pathParameterTemplate, f32 emScale)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathGlyphsNV)
                Throw(undefined_behavior(
                    "unloaded function PathGlyphsNV"));
    }
    glPathGlyphsNV(firstPathName, static_cast<GLenum>(fontTarget), reinterpret_cast<const void *>(fontName.data()), static_cast<GLenum>(fontStyle), numGlyphs, static_cast<GLenum>(type), reinterpret_cast<const void *>(charcodes.data()), static_cast<GLenum>(handleMissingGlyphs), pathParameterTemplate, emScale);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void path_parameterf_nv(u32 path, groups::path_parameter pname, f32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathParameterfNV)
                Throw(undefined_behavior(
                    "unloaded function PathParameterfNV"));
    }
    glPathParameterfNV(path, static_cast<GLenum>(pname), value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void path_parameterfv_nv(u32 path, groups::path_parameter pname, span_const_f32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathParameterfvNV)
                Throw(undefined_behavior(
                    "unloaded function PathParameterfvNV"));
    }
    glPathParameterfvNV(path, static_cast<GLenum>(pname), reinterpret_cast<const GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void path_parameteri_nv(u32 path, groups::path_parameter pname, i32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathParameteriNV)
                Throw(undefined_behavior(
                    "unloaded function PathParameteriNV"));
    }
    glPathParameteriNV(path, static_cast<GLenum>(pname), value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void path_parameteriv_nv(u32 path, groups::path_parameter pname, span_const_i32 const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathParameterivNV)
                Throw(undefined_behavior(
                    "unloaded function PathParameterivNV"));
    }
    glPathParameterivNV(path, static_cast<GLenum>(pname), reinterpret_cast<const GLint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void path_stencil_depth_offset_nv(f32 factor, f32 units)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathStencilDepthOffsetNV)
                Throw(undefined_behavior(
                    "unloaded function PathStencilDepthOffsetNV"));
    }
    glPathStencilDepthOffsetNV(factor, units);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void path_stencil_func_nv(groups::stencil_function func, i32 ref, u32 mask)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathStencilFuncNV)
                Throw(undefined_behavior(
                    "unloaded function PathStencilFuncNV"));
    }
    glPathStencilFuncNV(static_cast<GLenum>(func), ref, mask);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void path_string_nv(u32 path, groups::path_string_format format, span_const_byte const& pathString)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathStringNV)
                Throw(undefined_behavior(
                    "unloaded function PathStringNV"));
    }
    glPathStringNV(path, static_cast<GLenum>(format), pathString.size(), reinterpret_cast<const void *>(pathString.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class span_const_u8
>
requires (
    semantic::concepts::Span<span_const_u8> &&
    std::is_same_v<std::decay_t<typename span_const_u8::value_type>, u8> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void path_sub_commands_nv(u32 path, i32 commandStart, i32 commandsToDelete, span_const_u8 const& commands, i32 numCoords, groups::path_coord_type coordType, span_const_byte const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathSubCommandsNV)
                Throw(undefined_behavior(
                    "unloaded function PathSubCommandsNV"));
    }
    glPathSubCommandsNV(path, commandStart, commandsToDelete, commands.size(), reinterpret_cast<const GLubyte *>(commands.data()), numCoords, static_cast<GLenum>(coordType), reinterpret_cast<const void *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void path_sub_coords_nv(u32 path, i32 coordStart, i32 numCoords, groups::path_coord_type coordType, span_const_byte const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathSubCoordsNV)
                Throw(undefined_behavior(
                    "unloaded function PathSubCoordsNV"));
    }
    glPathSubCoordsNV(path, coordStart, numCoords, static_cast<GLenum>(coordType), reinterpret_cast<const void *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_f32
>
requires (
    semantic::concepts::Vector<vec_2_f32, f32, 2>)
STATICINLINE GLboolean point_along_path_nv(u32 path, i32 startSegment, i32 numSegments, f32 distance, vec_2_f32 const& x, f32& tangentX, f32& tangentY)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPointAlongPathNV)
                Throw(undefined_behavior(
                    "unloaded function PointAlongPathNV"));
    }
    auto out = glPointAlongPathNV(path, startSegment, numSegments, distance, x.x(), x.y(), &tangentX, &tangentY);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_byte,
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte> &&
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void stencil_fill_path_instanced_nv(i32 numPaths, groups::path_element_type pathNameType, span_const_byte const& paths, u32 pathBase, groups::path_fill_mode fillMode, u32 mask, groups::path_transform_type transformType, span_const_f32 const& transformValues)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glStencilFillPathInstancedNV)
                Throw(undefined_behavior(
                    "unloaded function StencilFillPathInstancedNV"));
    }
    glStencilFillPathInstancedNV(numPaths, static_cast<GLenum>(pathNameType), reinterpret_cast<const void *>(paths.data()), pathBase, static_cast<GLenum>(fillMode), mask, static_cast<GLenum>(transformType), reinterpret_cast<const GLfloat *>(transformValues.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void stencil_fill_path_nv(u32 path, groups::path_fill_mode fillMode, u32 mask)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glStencilFillPathNV)
                Throw(undefined_behavior(
                    "unloaded function StencilFillPathNV"));
    }
    glStencilFillPathNV(path, static_cast<GLenum>(fillMode), mask);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte> &&
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void stencil_stroke_path_instanced_nv(i32 numPaths, groups::path_element_type pathNameType, span_const_byte const& paths, u32 pathBase, i32 reference, u32 mask, groups::path_transform_type transformType, span_const_f32 const& transformValues)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glStencilStrokePathInstancedNV)
                Throw(undefined_behavior(
                    "unloaded function StencilStrokePathInstancedNV"));
    }
    glStencilStrokePathInstancedNV(numPaths, static_cast<GLenum>(pathNameType), reinterpret_cast<const void *>(paths.data()), pathBase, reference, mask, static_cast<GLenum>(transformType), reinterpret_cast<const GLfloat *>(transformValues.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void stencil_stroke_path_nv(u32 path, i32 reference, u32 mask)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glStencilStrokePathNV)
                Throw(undefined_behavior(
                    "unloaded function StencilStrokePathNV"));
    }
    glStencilStrokePathNV(path, reference, mask);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void transform_path_nv(u32 resultPath, u32 srcPath, groups::path_transform_type transformType, span_const_f32 const& transformValues)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTransformPathNV)
                Throw(undefined_behavior(
                    "unloaded function TransformPathNV"));
    }
    glTransformPathNV(resultPath, srcPath, static_cast<GLenum>(transformType), reinterpret_cast<const GLfloat *>(transformValues.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32,
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32> &&
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void weight_paths_nv(u32 resultPath, span_const_u32 const& paths, span_const_f32 const& weights)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glWeightPathsNV)
                Throw(undefined_behavior(
                    "unloaded function WeightPathsNV"));
    }
    glWeightPathsNV(resultPath, paths.size(), reinterpret_cast<const GLuint *>(paths.data()), reinterpret_cast<const GLfloat *>(weights.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x2_f32
>
requires (
    semantic::concepts::Span<span_const_mat_3x2_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_3x2_f32::value_type, f32, 3, 2>)
STATICINLINE void matrix_load3x2f_nv(GLenum matrixMode, span_const_mat_3x2_f32 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixLoad3x2fNV)
                Throw(undefined_behavior(
                    "unloaded function MatrixLoad3x2fNV"));
    }
    glMatrixLoad3x2fNV(matrixMode, reinterpret_cast<const GLfloat *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x3_f32
>
requires (
    semantic::concepts::Span<span_const_mat_3x3_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_3x3_f32::value_type, f32, 3, 3>)
STATICINLINE void matrix_load3x3f_nv(GLenum matrixMode, span_const_mat_3x3_f32 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixLoad3x3fNV)
                Throw(undefined_behavior(
                    "unloaded function MatrixLoad3x3fNV"));
    }
    glMatrixLoad3x3fNV(matrixMode, reinterpret_cast<const GLfloat *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x3_f32
>
requires (
    semantic::concepts::Span<span_const_mat_3x3_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_3x3_f32::value_type, f32, 3, 3>)
STATICINLINE void matrix_load_transpose3x3f_nv(GLenum matrixMode, span_const_mat_3x3_f32 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixLoadTranspose3x3fNV)
                Throw(undefined_behavior(
                    "unloaded function MatrixLoadTranspose3x3fNV"));
    }
    glMatrixLoadTranspose3x3fNV(matrixMode, reinterpret_cast<const GLfloat *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x2_f32
>
requires (
    semantic::concepts::Span<span_const_mat_3x2_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_3x2_f32::value_type, f32, 3, 2>)
STATICINLINE void matrix_mult3x2f_nv(GLenum matrixMode, span_const_mat_3x2_f32 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixMult3x2fNV)
                Throw(undefined_behavior(
                    "unloaded function MatrixMult3x2fNV"));
    }
    glMatrixMult3x2fNV(matrixMode, reinterpret_cast<const GLfloat *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x3_f32
>
requires (
    semantic::concepts::Span<span_const_mat_3x3_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_3x3_f32::value_type, f32, 3, 3>)
STATICINLINE void matrix_mult3x3f_nv(GLenum matrixMode, span_const_mat_3x3_f32 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixMult3x3fNV)
                Throw(undefined_behavior(
                    "unloaded function MatrixMult3x3fNV"));
    }
    glMatrixMult3x3fNV(matrixMode, reinterpret_cast<const GLfloat *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_mat_3x3_f32
>
requires (
    semantic::concepts::Span<span_const_mat_3x3_f32> &&
    semantic::concepts::Matrix<typename span_const_mat_3x3_f32::value_type, f32, 3, 3>)
STATICINLINE void matrix_mult_transpose3x3f_nv(GLenum matrixMode, span_const_mat_3x3_f32 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixMultTranspose3x3fNV)
                Throw(undefined_behavior(
                    "unloaded function MatrixMultTranspose3x3fNV"));
    }
    glMatrixMultTranspose3x3fNV(matrixMode, reinterpret_cast<const GLfloat *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class span_u32
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte> &&
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE GLenum path_glyph_index_range_nv(GLenum fontTarget, span_const_byte const& fontName, groups::path_font_style fontStyle, u32 pathParameterTemplate, f32 emScale, span_u32 baseAndCount)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathGlyphIndexRangeNV)
                Throw(undefined_behavior(
                    "unloaded function PathGlyphIndexRangeNV"));
    }
    auto out = glPathGlyphIndexRangeNV(fontTarget, reinterpret_cast<const void *>(fontName.data()), static_cast<GLenum>(fontStyle), pathParameterTemplate, emScale, reinterpret_cast<GLuint *>(baseAndCount.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_byte,
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte> &&
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void stencil_then_cover_fill_path_instanced_nv(i32 numPaths, GLenum pathNameType, span_const_byte const& paths, u32 pathBase, GLenum fillMode, u32 mask, GLenum coverMode, GLenum transformType, span_const_f32 const& transformValues)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glStencilThenCoverFillPathInstancedNV)
                Throw(undefined_behavior(
                    "unloaded function StencilThenCoverFillPathInstancedNV"));
    }
    glStencilThenCoverFillPathInstancedNV(numPaths, pathNameType, reinterpret_cast<const void *>(paths.data()), pathBase, fillMode, mask, coverMode, transformType, reinterpret_cast<const GLfloat *>(transformValues.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void stencil_then_cover_fill_path_nv(u32 path, GLenum fillMode, u32 mask, GLenum coverMode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glStencilThenCoverFillPathNV)
                Throw(undefined_behavior(
                    "unloaded function StencilThenCoverFillPathNV"));
    }
    glStencilThenCoverFillPathNV(path, fillMode, mask, coverMode);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte> &&
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void stencil_then_cover_stroke_path_instanced_nv(i32 numPaths, GLenum pathNameType, span_const_byte const& paths, u32 pathBase, i32 reference, u32 mask, GLenum coverMode, GLenum transformType, span_const_f32 const& transformValues)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glStencilThenCoverStrokePathInstancedNV)
                Throw(undefined_behavior(
                    "unloaded function StencilThenCoverStrokePathInstancedNV"));
    }
    glStencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, reinterpret_cast<const void *>(paths.data()), pathBase, reference, mask, coverMode, transformType, reinterpret_cast<const GLfloat *>(transformValues.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void stencil_then_cover_stroke_path_nv(u32 path, i32 reference, u32 mask, GLenum coverMode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glStencilThenCoverStrokePathNV)
                Throw(undefined_behavior(
                    "unloaded function StencilThenCoverStrokePathNV"));
    }
    glStencilThenCoverStrokePathNV(path, reference, mask, coverMode);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLenum,
    class span_f32
>
requires (
    semantic::concepts::Span<span_const_GLenum> &&
    std::is_same_v<std::decay_t<typename span_const_GLenum::value_type>, GLenum> &&
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_program_resourcefv_nv(u32 program, groups::program_interface programInterface, u32 index, i32 propCount, span_const_GLenum const& props, i32& length, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramResourcefvNV)
                Throw(undefined_behavior(
                    "unloaded function GetProgramResourcefvNV"));
        glIsProgram(program);
    }
    glGetProgramResourcefvNV(program, static_cast<GLenum>(programInterface), index, propCount, reinterpret_cast<const GLenum *>(props.data()), params.size(), &length, reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE GLenum path_glyph_index_array_nv(u32 firstPathName, GLenum fontTarget, span_const_byte const& fontName, groups::path_font_style fontStyle, u32 firstGlyphIndex, i32 numGlyphs, u32 pathParameterTemplate, f32 emScale)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathGlyphIndexArrayNV)
                Throw(undefined_behavior(
                    "unloaded function PathGlyphIndexArrayNV"));
    }
    auto out = glPathGlyphIndexArrayNV(firstPathName, fontTarget, reinterpret_cast<const void *>(fontName.data()), static_cast<GLenum>(fontStyle), firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE GLenum path_memory_glyph_index_array_nv(u32 firstPathName, GLenum fontTarget, GLsizeiptr fontSize, span_const_byte const& fontData, i32 faceIndex, u32 firstGlyphIndex, i32 numGlyphs, u32 pathParameterTemplate, f32 emScale)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathMemoryGlyphIndexArrayNV)
                Throw(undefined_behavior(
                    "unloaded function PathMemoryGlyphIndexArrayNV"));
    }
    auto out = glPathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, reinterpret_cast<const void *>(fontData.data()), faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void program_path_fragment_input_gen_nv(u32 program, i32 location, GLenum genMode, i32 components, span_const_f32 const& coeffs)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramPathFragmentInputGenNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramPathFragmentInputGenNV"));
        glIsProgram(program);
    }
    glProgramPathFragmentInputGenNV(program, location, genMode, components, reinterpret_cast<const GLfloat *>(coeffs.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_path_color_genfv_nv(groups::path_color color, groups::path_gen_mode pname, span_f32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPathColorGenfvNV)
                Throw(undefined_behavior(
                    "unloaded function GetPathColorGenfvNV"));
    }
    glGetPathColorGenfvNV(static_cast<GLenum>(color), static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_path_color_geniv_nv(groups::path_color color, groups::path_gen_mode pname, span_i32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPathColorGenivNV)
                Throw(undefined_behavior(
                    "unloaded function GetPathColorGenivNV"));
    }
    glGetPathColorGenivNV(static_cast<GLenum>(color), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_path_tex_genfv_nv(groups::texture_unit texCoordSet, groups::path_gen_mode pname, span_f32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPathTexGenfvNV)
                Throw(undefined_behavior(
                    "unloaded function GetPathTexGenfvNV"));
    }
    glGetPathTexGenfvNV(static_cast<GLenum>(texCoordSet), static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_path_tex_geniv_nv(groups::texture_unit texCoordSet, groups::path_gen_mode pname, span_i32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPathTexGenivNV)
                Throw(undefined_behavior(
                    "unloaded function GetPathTexGenivNV"));
    }
    glGetPathTexGenivNV(static_cast<GLenum>(texCoordSet), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void path_color_gen_nv(groups::path_color color, groups::path_gen_mode genMode, groups::path_color_format colorFormat, span_const_f32 const& coeffs)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathColorGenNV)
                Throw(undefined_behavior(
                    "unloaded function PathColorGenNV"));
    }
    glPathColorGenNV(static_cast<GLenum>(color), static_cast<GLenum>(genMode), static_cast<GLenum>(colorFormat), reinterpret_cast<const GLfloat *>(coeffs.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void path_fog_gen_nv(groups::path_gen_mode genMode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathFogGenNV)
                Throw(undefined_behavior(
                    "unloaded function PathFogGenNV"));
    }
    glPathFogGenNV(static_cast<GLenum>(genMode));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void path_tex_gen_nv(groups::path_color texCoordSet, groups::path_gen_mode genMode, i32 components, span_const_f32 const& coeffs)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPathTexGenNV)
                Throw(undefined_behavior(
                    "unloaded function PathTexGenNV"));
    }
    glPathTexGenNV(static_cast<GLenum>(texCoordSet), static_cast<GLenum>(genMode), components, reinterpret_cast<const GLfloat *>(coeffs.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void matrix_frustum_ext(groups::matrix_mode mode, f64 left, f64 right, f64 bottom, f64 top, f64 zNear, f64 zFar)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixFrustumEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixFrustumEXT"));
    }
    glMatrixFrustumEXT(static_cast<GLenum>(mode), left, right, bottom, top, zNear, zFar);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void matrix_load_identity_ext(groups::matrix_mode mode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixLoadIdentityEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixLoadIdentityEXT"));
    }
    glMatrixLoadIdentityEXT(static_cast<GLenum>(mode));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f64
>
requires (
    semantic::concepts::Span<span_const_f64> &&
    std::is_same_v<std::decay_t<typename span_const_f64::value_type>, f64>)
STATICINLINE void matrix_load_transposed_ext(groups::matrix_mode mode, span_const_f64 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixLoadTransposedEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixLoadTransposedEXT"));
    }
    glMatrixLoadTransposedEXT(static_cast<GLenum>(mode), reinterpret_cast<const GLdouble *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void matrix_load_transposef_ext(groups::matrix_mode mode, span_const_f32 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixLoadTransposefEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixLoadTransposefEXT"));
    }
    glMatrixLoadTransposefEXT(static_cast<GLenum>(mode), reinterpret_cast<const GLfloat *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f64
>
requires (
    semantic::concepts::Span<span_const_f64> &&
    std::is_same_v<std::decay_t<typename span_const_f64::value_type>, f64>)
STATICINLINE void matrix_loadd_ext(groups::matrix_mode mode, span_const_f64 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixLoaddEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixLoaddEXT"));
    }
    glMatrixLoaddEXT(static_cast<GLenum>(mode), reinterpret_cast<const GLdouble *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void matrix_loadf_ext(groups::matrix_mode mode, span_const_f32 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixLoadfEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixLoadfEXT"));
    }
    glMatrixLoadfEXT(static_cast<GLenum>(mode), reinterpret_cast<const GLfloat *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f64
>
requires (
    semantic::concepts::Span<span_const_f64> &&
    std::is_same_v<std::decay_t<typename span_const_f64::value_type>, f64>)
STATICINLINE void matrix_mult_transposed_ext(groups::matrix_mode mode, span_const_f64 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixMultTransposedEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixMultTransposedEXT"));
    }
    glMatrixMultTransposedEXT(static_cast<GLenum>(mode), reinterpret_cast<const GLdouble *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void matrix_mult_transposef_ext(groups::matrix_mode mode, span_const_f32 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixMultTransposefEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixMultTransposefEXT"));
    }
    glMatrixMultTransposefEXT(static_cast<GLenum>(mode), reinterpret_cast<const GLfloat *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f64
>
requires (
    semantic::concepts::Span<span_const_f64> &&
    std::is_same_v<std::decay_t<typename span_const_f64::value_type>, f64>)
STATICINLINE void matrix_multd_ext(groups::matrix_mode mode, span_const_f64 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixMultdEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixMultdEXT"));
    }
    glMatrixMultdEXT(static_cast<GLenum>(mode), reinterpret_cast<const GLdouble *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void matrix_multf_ext(groups::matrix_mode mode, span_const_f32 const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixMultfEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixMultfEXT"));
    }
    glMatrixMultfEXT(static_cast<GLenum>(mode), reinterpret_cast<const GLfloat *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void matrix_ortho_ext(groups::matrix_mode mode, f64 left, f64 right, f64 bottom, f64 top, f64 zNear, f64 zFar)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixOrthoEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixOrthoEXT"));
    }
    glMatrixOrthoEXT(static_cast<GLenum>(mode), left, right, bottom, top, zNear, zFar);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void matrix_pop_ext(groups::matrix_mode mode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixPopEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixPopEXT"));
    }
    glMatrixPopEXT(static_cast<GLenum>(mode));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void matrix_push_ext(groups::matrix_mode mode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixPushEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixPushEXT"));
    }
    glMatrixPushEXT(static_cast<GLenum>(mode));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f64
>
requires (
    semantic::concepts::Vector<vec_3_f64, f64, 3>)
STATICINLINE void matrix_rotated_ext(groups::matrix_mode mode, f64 angle, vec_3_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixRotatedEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixRotatedEXT"));
    }
    glMatrixRotatedEXT(static_cast<GLenum>(mode), angle, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f32
>
requires (
    semantic::concepts::Vector<vec_3_f32, f32, 3>)
STATICINLINE void matrix_rotatef_ext(groups::matrix_mode mode, f32 angle, vec_3_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixRotatefEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixRotatefEXT"));
    }
    glMatrixRotatefEXT(static_cast<GLenum>(mode), angle, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f64
>
requires (
    semantic::concepts::Vector<vec_3_f64, f64, 3>)
STATICINLINE void matrix_scaled_ext(groups::matrix_mode mode, vec_3_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixScaledEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixScaledEXT"));
    }
    glMatrixScaledEXT(static_cast<GLenum>(mode), x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f32
>
requires (
    semantic::concepts::Vector<vec_3_f32, f32, 3>)
STATICINLINE void matrix_scalef_ext(groups::matrix_mode mode, vec_3_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixScalefEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixScalefEXT"));
    }
    glMatrixScalefEXT(static_cast<GLenum>(mode), x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f64
>
requires (
    semantic::concepts::Vector<vec_3_f64, f64, 3>)
STATICINLINE void matrix_translated_ext(groups::matrix_mode mode, vec_3_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixTranslatedEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixTranslatedEXT"));
    }
    glMatrixTranslatedEXT(static_cast<GLenum>(mode), x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f32
>
requires (
    semantic::concepts::Vector<vec_3_f32, f32, 3>)
STATICINLINE void matrix_translatef_ext(groups::matrix_mode mode, vec_3_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMatrixTranslatefEXT)
                Throw(undefined_behavior(
                    "unloaded function MatrixTranslatefEXT"));
    }
    glMatrixTranslatefEXT(static_cast<GLenum>(mode), x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_path_rendering
#endif // GL_NV_path_rendering
#ifdef GL_NV_path_rendering_shared_edge
namespace nv_path_rendering_shared_edge {
constexpr u32 shared_edge_nv = 0xC0;
} // nv_path_rendering_shared_edge
#endif // GL_NV_path_rendering_shared_edge
#ifdef GL_NV_pixel_data_range
namespace nv_pixel_data_range {
constexpr u32 write_pixel_data_range_nv = 0x8878;
constexpr u32 read_pixel_data_range_nv = 0x8879;
constexpr u32 write_pixel_data_range_length_nv = 0x887A;
constexpr u32 read_pixel_data_range_length_nv = 0x887B;
constexpr u32 write_pixel_data_range_pointer_nv = 0x887C;
constexpr u32 read_pixel_data_range_pointer_nv = 0x887D;
STATICINLINE void flush_pixel_data_range_nv(groups::pixel_data_range_target_nv target)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFlushPixelDataRangeNV)
                Throw(undefined_behavior(
                    "unloaded function FlushPixelDataRangeNV"));
    }
    glFlushPixelDataRangeNV(static_cast<GLenum>(target));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void pixel_data_range_nv(groups::pixel_data_range_target_nv target, span_const_byte const& pointer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPixelDataRangeNV)
                Throw(undefined_behavior(
                    "unloaded function PixelDataRangeNV"));
    }
    glPixelDataRangeNV(static_cast<GLenum>(target), pointer.size(), reinterpret_cast<const void *>(pointer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_pixel_data_range
#endif // GL_NV_pixel_data_range
#ifdef GL_NV_pixel_buffer_object
namespace nv_pixel_buffer_object {
constexpr u32 pixel_pack_buffer_nv = 0x88EB;
constexpr u32 pixel_unpack_buffer_nv = 0x88EC;
constexpr u32 pixel_pack_buffer_binding_nv = 0x88ED;
constexpr u32 pixel_unpack_buffer_binding_nv = 0x88EF;
} // nv_pixel_buffer_object
#endif // GL_NV_pixel_buffer_object
#ifdef GL_NV_point_sprite
namespace nv_point_sprite {
constexpr u32 point_sprite_nv = 0x8861;
constexpr u32 coord_replace_nv = 0x8862;
constexpr u32 point_sprite_r_mode_nv = 0x8863;
STATICINLINE void point_parameteri_nv(groups::point_parameter_name_arb pname, i32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPointParameteriNV)
                Throw(undefined_behavior(
                    "unloaded function PointParameteriNV"));
    }
    glPointParameteriNV(static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void point_parameteriv_nv(groups::point_parameter_name_arb pname, span_const_i32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPointParameterivNV)
                Throw(undefined_behavior(
                    "unloaded function PointParameterivNV"));
    }
    glPointParameterivNV(static_cast<GLenum>(pname), reinterpret_cast<const GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_point_sprite
#endif // GL_NV_point_sprite
#ifdef GL_NV_polygon_mode
namespace nv_polygon_mode {
constexpr u32 polygon_mode_nv = 0x0B40;
constexpr u32 point_nv = 0x1B00;
constexpr u32 line_nv = 0x1B01;
constexpr u32 fill_nv = 0x1B02;
constexpr u32 polygon_offset_point_nv = 0x2A01;
constexpr u32 polygon_offset_line_nv = 0x2A02;
STATICINLINE void polygon_mode_nv(groups::material_face face, groups::polygon_mode mode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPolygonModeNV)
                Throw(undefined_behavior(
                    "unloaded function PolygonModeNV"));
    }
    glPolygonModeNV(static_cast<GLenum>(face), static_cast<GLenum>(mode));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_polygon_mode
#endif // GL_NV_polygon_mode
#ifdef GL_NV_present_video
namespace nv_present_video {
constexpr u32 frame_nv = 0x8E26;
constexpr u32 fields_nv = 0x8E27;
constexpr u32 current_time_nv = 0x8E28;
constexpr u32 num_fill_streams_nv = 0x8E29;
constexpr u32 present_time_nv = 0x8E2A;
constexpr u32 present_duration_nv = 0x8E2B;
template<
    class span_GLint64EXT
>
requires (
    semantic::concepts::Span<span_GLint64EXT> &&
    std::is_same_v<std::decay_t<typename span_GLint64EXT::value_type>, GLint64EXT>)
STATICINLINE void get_videoi64v_nv(u32 video_slot, GLenum pname, span_GLint64EXT params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVideoi64vNV)
                Throw(undefined_behavior(
                    "unloaded function GetVideoi64vNV"));
    }
    glGetVideoi64vNV(video_slot, pname, reinterpret_cast<GLint64EXT *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_videoiv_nv(u32 video_slot, GLenum pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVideoivNV)
                Throw(undefined_behavior(
                    "unloaded function GetVideoivNV"));
    }
    glGetVideoivNV(video_slot, pname, reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE void get_videoui64v_nv(u32 video_slot, GLenum pname, span_GLuint64EXT params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVideoui64vNV)
                Throw(undefined_behavior(
                    "unloaded function GetVideoui64vNV"));
    }
    glGetVideoui64vNV(video_slot, pname, reinterpret_cast<GLuint64EXT *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_videouiv_nv(u32 video_slot, GLenum pname, span_u32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVideouivNV)
                Throw(undefined_behavior(
                    "unloaded function GetVideouivNV"));
    }
    glGetVideouivNV(video_slot, pname, reinterpret_cast<GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void present_frame_dual_fill_nv(u32 video_slot, GLuint64EXT minPresentTime, u32 beginPresentTimeId, u32 presentDurationId, GLenum type, GLenum target0, u32 fill0, GLenum target1, u32 fill1, GLenum target2, u32 fill2, GLenum target3, u32 fill3)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPresentFrameDualFillNV)
                Throw(undefined_behavior(
                    "unloaded function PresentFrameDualFillNV"));
    }
    glPresentFrameDualFillNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void present_frame_keyed_nv(u32 video_slot, GLuint64EXT minPresentTime, u32 beginPresentTimeId, u32 presentDurationId, GLenum type, GLenum target0, u32 fill0, u32 key0, GLenum target1, u32 fill1, u32 key1)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPresentFrameKeyedNV)
                Throw(undefined_behavior(
                    "unloaded function PresentFrameKeyedNV"));
    }
    glPresentFrameKeyedNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_present_video
#endif // GL_NV_present_video
#ifdef GL_NV_primitive_restart
namespace nv_primitive_restart {
constexpr u32 primitive_restart_nv = 0x8558;
constexpr u32 primitive_restart_index_nv = 0x8559;
STATICINLINE void primitive_restart_index_nv(u32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPrimitiveRestartIndexNV)
                Throw(undefined_behavior(
                    "unloaded function PrimitiveRestartIndexNV"));
    }
    glPrimitiveRestartIndexNV(index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void primitive_restart_nv()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPrimitiveRestartNV)
                Throw(undefined_behavior(
                    "unloaded function PrimitiveRestartNV"));
    }
    glPrimitiveRestartNV();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_primitive_restart
#endif // GL_NV_primitive_restart
#ifdef GL_NV_primitive_shading_rate
namespace nv_primitive_shading_rate {
constexpr u32 shading_rate_image_per_primitive_nv = 0x95B1;
constexpr u32 shading_rate_image_palette_count_nv = 0x95B2;
} // nv_primitive_shading_rate
#endif // GL_NV_primitive_shading_rate
#ifdef GL_NV_query_resource
namespace nv_query_resource {
constexpr u32 query_resource_type_vidmem_alloc_nv = 0x9540;
constexpr u32 query_resource_memtype_vidmem_nv = 0x9542;
constexpr u32 query_resource_sys_reserved_nv = 0x9544;
constexpr u32 query_resource_texture_nv = 0x9545;
constexpr u32 query_resource_renderbuffer_nv = 0x9546;
constexpr u32 query_resource_bufferobject_nv = 0x9547;
template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE GLint query_resource_nv(GLenum queryType, i32 tagId, span_i32 buffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glQueryResourceNV)
                Throw(undefined_behavior(
                    "unloaded function QueryResourceNV"));
    }
    auto out = glQueryResourceNV(queryType, tagId, buffer.size(), reinterpret_cast<GLint *>(buffer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // nv_query_resource
#endif // GL_NV_query_resource
#ifdef GL_NV_query_resource_tag
namespace nv_query_resource_tag {
template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void delete_query_resource_tag_nv(span_const_i32 const& tagIds)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteQueryResourceTagNV)
                Throw(undefined_behavior(
                    "unloaded function DeleteQueryResourceTagNV"));
    }
    glDeleteQueryResourceTagNV(tagIds.size(), reinterpret_cast<const GLint *>(tagIds.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void gen_query_resource_tag_nv(span_i32 tagIds)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenQueryResourceTagNV)
                Throw(undefined_behavior(
                    "unloaded function GenQueryResourceTagNV"));
    }
    glGenQueryResourceTagNV(tagIds.size(), reinterpret_cast<GLint *>(tagIds.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void query_resource_tag_nv(i32 tagId, std::string_view const& tagString)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glQueryResourceTagNV)
                Throw(undefined_behavior(
                    "unloaded function QueryResourceTagNV"));
    }
    glQueryResourceTagNV(tagId, tagString.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_query_resource_tag
#endif // GL_NV_query_resource_tag
#ifdef GL_NV_read_buffer
namespace nv_read_buffer {
constexpr u32 read_buffer_nv = 0x0C02;
STATICINLINE void read_buffer_nv(GLenum mode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glReadBufferNV)
                Throw(undefined_behavior(
                    "unloaded function ReadBufferNV"));
    }
    glReadBufferNV(mode);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_read_buffer
#endif // GL_NV_read_buffer
#ifdef GL_NV_read_buffer_front
namespace nv_read_buffer_front {
} // nv_read_buffer_front
#endif // GL_NV_read_buffer_front
#ifdef GL_NV_read_depth
namespace nv_read_depth {
} // nv_read_depth
#endif // GL_NV_read_depth
#ifdef GL_NV_read_depth_stencil
namespace nv_read_depth_stencil {
} // nv_read_depth_stencil
#endif // GL_NV_read_depth_stencil
#ifdef GL_NV_read_stencil
namespace nv_read_stencil {
} // nv_read_stencil
#endif // GL_NV_read_stencil
#ifdef GL_NV_register_combiners
namespace nv_register_combiners {
constexpr u32 zero = 0;
constexpr u32 none = 0;
constexpr u32 fog = 0x0B60;
constexpr u32 texture0_arb = 0x84C0;
constexpr u32 texture1_arb = 0x84C1;
constexpr u32 register_combiners_nv = 0x8522;
constexpr u32 variable_a_nv = 0x8523;
constexpr u32 variable_b_nv = 0x8524;
constexpr u32 variable_c_nv = 0x8525;
constexpr u32 variable_d_nv = 0x8526;
constexpr u32 variable_e_nv = 0x8527;
constexpr u32 variable_f_nv = 0x8528;
constexpr u32 variable_g_nv = 0x8529;
constexpr u32 constant_color0_nv = 0x852A;
constexpr u32 constant_color1_nv = 0x852B;
constexpr u32 primary_color_nv = 0x852C;
constexpr u32 secondary_color_nv = 0x852D;
constexpr u32 spare0_nv = 0x852E;
constexpr u32 spare1_nv = 0x852F;
constexpr u32 discard_nv = 0x8530;
constexpr u32 e_times_f_nv = 0x8531;
constexpr u32 spare0_plus_secondary_color_nv = 0x8532;
constexpr u32 unsigned_identity_nv = 0x8536;
constexpr u32 unsigned_invert_nv = 0x8537;
constexpr u32 expand_normal_nv = 0x8538;
constexpr u32 expand_negate_nv = 0x8539;
constexpr u32 half_bias_normal_nv = 0x853A;
constexpr u32 half_bias_negate_nv = 0x853B;
constexpr u32 signed_identity_nv = 0x853C;
constexpr u32 signed_negate_nv = 0x853D;
constexpr u32 scale_by_two_nv = 0x853E;
constexpr u32 scale_by_four_nv = 0x853F;
constexpr u32 scale_by_one_half_nv = 0x8540;
constexpr u32 bias_by_negative_one_half_nv = 0x8541;
constexpr u32 combiner_input_nv = 0x8542;
constexpr u32 combiner_mapping_nv = 0x8543;
constexpr u32 combiner_component_usage_nv = 0x8544;
constexpr u32 combiner_ab_dot_product_nv = 0x8545;
constexpr u32 combiner_cd_dot_product_nv = 0x8546;
constexpr u32 combiner_mux_sum_nv = 0x8547;
constexpr u32 combiner_scale_nv = 0x8548;
constexpr u32 combiner_bias_nv = 0x8549;
constexpr u32 combiner_ab_output_nv = 0x854A;
constexpr u32 combiner_cd_output_nv = 0x854B;
constexpr u32 combiner_sum_output_nv = 0x854C;
constexpr u32 max_general_combiners_nv = 0x854D;
constexpr u32 num_general_combiners_nv = 0x854E;
constexpr u32 color_sum_clamp_nv = 0x854F;
constexpr u32 combiner0_nv = 0x8550;
constexpr u32 combiner1_nv = 0x8551;
constexpr u32 combiner2_nv = 0x8552;
constexpr u32 combiner3_nv = 0x8553;
constexpr u32 combiner4_nv = 0x8554;
constexpr u32 combiner5_nv = 0x8555;
constexpr u32 combiner6_nv = 0x8556;
constexpr u32 combiner7_nv = 0x8557;
STATICINLINE void combiner_input_nv(groups::combiner_stage_nv stage, groups::combiner_portion_nv portion, groups::combiner_variable_nv variable, groups::combiner_register_nv input, groups::combiner_mapping_nv mapping, groups::combiner_component_usage_nv componentUsage)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCombinerInputNV)
                Throw(undefined_behavior(
                    "unloaded function CombinerInputNV"));
    }
    glCombinerInputNV(static_cast<GLenum>(stage), static_cast<GLenum>(portion), static_cast<GLenum>(variable), static_cast<GLenum>(input), static_cast<GLenum>(mapping), static_cast<GLenum>(componentUsage));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void combiner_output_nv(groups::combiner_stage_nv stage, groups::combiner_portion_nv portion, groups::combiner_register_nv abOutput, groups::combiner_register_nv cdOutput, groups::combiner_register_nv sumOutput, groups::combiner_scale_nv scale, groups::combiner_bias_nv bias, bool abDotProduct, bool cdDotProduct, bool muxSum)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCombinerOutputNV)
                Throw(undefined_behavior(
                    "unloaded function CombinerOutputNV"));
    }
    glCombinerOutputNV(static_cast<GLenum>(stage), static_cast<GLenum>(portion), static_cast<GLenum>(abOutput), static_cast<GLenum>(cdOutput), static_cast<GLenum>(sumOutput), static_cast<GLenum>(scale), static_cast<GLenum>(bias), abDotProduct, cdDotProduct, muxSum);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void combiner_parameterf_nv(groups::combiner_parameter_nv pname, f32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCombinerParameterfNV)
                Throw(undefined_behavior(
                    "unloaded function CombinerParameterfNV"));
    }
    glCombinerParameterfNV(static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void combiner_parameterfv_nv(groups::combiner_parameter_nv pname, span_const_f32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCombinerParameterfvNV)
                Throw(undefined_behavior(
                    "unloaded function CombinerParameterfvNV"));
    }
    glCombinerParameterfvNV(static_cast<GLenum>(pname), reinterpret_cast<const GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void combiner_parameteri_nv(groups::combiner_parameter_nv pname, i32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCombinerParameteriNV)
                Throw(undefined_behavior(
                    "unloaded function CombinerParameteriNV"));
    }
    glCombinerParameteriNV(static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void combiner_parameteriv_nv(groups::combiner_parameter_nv pname, span_const_i32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCombinerParameterivNV)
                Throw(undefined_behavior(
                    "unloaded function CombinerParameterivNV"));
    }
    glCombinerParameterivNV(static_cast<GLenum>(pname), reinterpret_cast<const GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void final_combiner_input_nv(groups::combiner_variable_nv variable, groups::combiner_register_nv input, groups::combiner_mapping_nv mapping, groups::combiner_component_usage_nv componentUsage)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFinalCombinerInputNV)
                Throw(undefined_behavior(
                    "unloaded function FinalCombinerInputNV"));
    }
    glFinalCombinerInputNV(static_cast<GLenum>(variable), static_cast<GLenum>(input), static_cast<GLenum>(mapping), static_cast<GLenum>(componentUsage));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_combiner_input_parameterfv_nv(groups::combiner_stage_nv stage, groups::combiner_portion_nv portion, groups::combiner_variable_nv variable, groups::combiner_parameter_nv pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetCombinerInputParameterfvNV)
                Throw(undefined_behavior(
                    "unloaded function GetCombinerInputParameterfvNV"));
    }
    glGetCombinerInputParameterfvNV(static_cast<GLenum>(stage), static_cast<GLenum>(portion), static_cast<GLenum>(variable), static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_combiner_input_parameteriv_nv(groups::combiner_stage_nv stage, groups::combiner_portion_nv portion, groups::combiner_variable_nv variable, groups::combiner_parameter_nv pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetCombinerInputParameterivNV)
                Throw(undefined_behavior(
                    "unloaded function GetCombinerInputParameterivNV"));
    }
    glGetCombinerInputParameterivNV(static_cast<GLenum>(stage), static_cast<GLenum>(portion), static_cast<GLenum>(variable), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_combiner_output_parameterfv_nv(groups::combiner_stage_nv stage, groups::combiner_portion_nv portion, groups::combiner_parameter_nv pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetCombinerOutputParameterfvNV)
                Throw(undefined_behavior(
                    "unloaded function GetCombinerOutputParameterfvNV"));
    }
    glGetCombinerOutputParameterfvNV(static_cast<GLenum>(stage), static_cast<GLenum>(portion), static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_combiner_output_parameteriv_nv(groups::combiner_stage_nv stage, groups::combiner_portion_nv portion, groups::combiner_parameter_nv pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetCombinerOutputParameterivNV)
                Throw(undefined_behavior(
                    "unloaded function GetCombinerOutputParameterivNV"));
    }
    glGetCombinerOutputParameterivNV(static_cast<GLenum>(stage), static_cast<GLenum>(portion), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_final_combiner_input_parameterfv_nv(groups::combiner_variable_nv variable, groups::combiner_parameter_nv pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetFinalCombinerInputParameterfvNV)
                Throw(undefined_behavior(
                    "unloaded function GetFinalCombinerInputParameterfvNV"));
    }
    glGetFinalCombinerInputParameterfvNV(static_cast<GLenum>(variable), static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_final_combiner_input_parameteriv_nv(groups::combiner_variable_nv variable, groups::combiner_parameter_nv pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetFinalCombinerInputParameterivNV)
                Throw(undefined_behavior(
                    "unloaded function GetFinalCombinerInputParameterivNV"));
    }
    glGetFinalCombinerInputParameterivNV(static_cast<GLenum>(variable), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_register_combiners
#endif // GL_NV_register_combiners
#ifdef GL_NV_register_combiners2
namespace nv_register_combiners2 {
constexpr u32 per_stage_constants_nv = 0x8535;
template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void combiner_stage_parameterfv_nv(groups::combiner_stage_nv stage, groups::combiner_parameter_nv pname, span_const_f32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCombinerStageParameterfvNV)
                Throw(undefined_behavior(
                    "unloaded function CombinerStageParameterfvNV"));
    }
    glCombinerStageParameterfvNV(static_cast<GLenum>(stage), static_cast<GLenum>(pname), reinterpret_cast<const GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_combiner_stage_parameterfv_nv(groups::combiner_stage_nv stage, groups::combiner_parameter_nv pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetCombinerStageParameterfvNV)
                Throw(undefined_behavior(
                    "unloaded function GetCombinerStageParameterfvNV"));
    }
    glGetCombinerStageParameterfvNV(static_cast<GLenum>(stage), static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_register_combiners2
#endif // GL_NV_register_combiners2
#ifdef GL_NV_representative_fragment_test
namespace nv_representative_fragment_test {
constexpr u32 representative_fragment_test_nv = 0x937F;
} // nv_representative_fragment_test
#endif // GL_NV_representative_fragment_test
#ifdef GL_NV_robustness_video_memory_purge
namespace nv_robustness_video_memory_purge {
constexpr u32 purged_context_reset_nv = 0x92BB;
} // nv_robustness_video_memory_purge
#endif // GL_NV_robustness_video_memory_purge
#ifdef GL_NV_sRGB_formats
namespace nv_srgb_formats {
constexpr u32 etc1_srgb8_nv = 0x88EE;
constexpr u32 srgb8_nv = 0x8C41;
constexpr u32 sluminance_alpha_nv = 0x8C44;
constexpr u32 sluminance8_alpha8_nv = 0x8C45;
constexpr u32 sluminance_nv = 0x8C46;
constexpr u32 sluminance8_nv = 0x8C47;
constexpr u32 compressed_srgb_s3tc_dxt1_nv = 0x8C4C;
constexpr u32 compressed_srgb_alpha_s3tc_dxt1_nv = 0x8C4D;
constexpr u32 compressed_srgb_alpha_s3tc_dxt3_nv = 0x8C4E;
constexpr u32 compressed_srgb_alpha_s3tc_dxt5_nv = 0x8C4F;
} // nv_srgb_formats
#endif // GL_NV_sRGB_formats
#ifdef GL_NV_sample_locations
namespace nv_sample_locations {
constexpr u32 sample_location_nv = 0x8E50;
constexpr u32 sample_location_subpixel_bits_nv = 0x933D;
constexpr u32 sample_location_pixel_grid_width_nv = 0x933E;
constexpr u32 sample_location_pixel_grid_height_nv = 0x933F;
constexpr u32 programmable_sample_location_table_size_nv = 0x9340;
constexpr u32 programmable_sample_location_nv = 0x9341;
constexpr u32 framebuffer_programmable_sample_locations_nv = 0x9342;
constexpr u32 framebuffer_sample_location_pixel_grid_nv = 0x9343;
template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void framebuffer_sample_locationsfv_nv(groups::framebuffer_target target, u32 start, i32 count, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferSampleLocationsfvNV)
                Throw(undefined_behavior(
                    "unloaded function FramebufferSampleLocationsfvNV"));
    }
    glFramebufferSampleLocationsfvNV(static_cast<GLenum>(target), start, count, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void named_framebuffer_sample_locationsfv_nv(u32 framebuffer, u32 start, i32 count, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNamedFramebufferSampleLocationsfvNV)
                Throw(undefined_behavior(
                    "unloaded function NamedFramebufferSampleLocationsfvNV"));
        glIsFramebuffer(framebuffer);
    }
    glNamedFramebufferSampleLocationsfvNV(framebuffer, start, count, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void resolve_depth_values_nv()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glResolveDepthValuesNV)
                Throw(undefined_behavior(
                    "unloaded function ResolveDepthValuesNV"));
    }
    glResolveDepthValuesNV();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_sample_locations
#endif // GL_NV_sample_locations
#ifdef GL_NV_sample_mask_override_coverage
namespace nv_sample_mask_override_coverage {
} // nv_sample_mask_override_coverage
#endif // GL_NV_sample_mask_override_coverage
#ifdef GL_NV_scissor_exclusive
namespace nv_scissor_exclusive {
constexpr u32 scissor_test_exclusive_nv = 0x9555;
constexpr u32 scissor_box_exclusive_nv = 0x9556;
template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void scissor_exclusive_arrayv_nv(u32 first, i32 count, span_const_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glScissorExclusiveArrayvNV)
                Throw(undefined_behavior(
                    "unloaded function ScissorExclusiveArrayvNV"));
    }
    glScissorExclusiveArrayvNV(first, count, reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void scissor_exclusive_nv(vec_2_i32 const& x, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glScissorExclusiveNV)
                Throw(undefined_behavior(
                    "unloaded function ScissorExclusiveNV"));
    }
    glScissorExclusiveNV(x.x(), x.y(), width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_scissor_exclusive
#endif // GL_NV_scissor_exclusive
#ifdef GL_NV_shader_atomic_counters
namespace nv_shader_atomic_counters {
} // nv_shader_atomic_counters
#endif // GL_NV_shader_atomic_counters
#ifdef GL_NV_shader_atomic_float
namespace nv_shader_atomic_float {
} // nv_shader_atomic_float
#endif // GL_NV_shader_atomic_float
#ifdef GL_NV_shader_atomic_float64
namespace nv_shader_atomic_float64 {
} // nv_shader_atomic_float64
#endif // GL_NV_shader_atomic_float64
#ifdef GL_NV_shader_atomic_fp16_vector
namespace nv_shader_atomic_fp16_vector {
} // nv_shader_atomic_fp16_vector
#endif // GL_NV_shader_atomic_fp16_vector
#ifdef GL_NV_shader_atomic_int64
namespace nv_shader_atomic_int64 {
} // nv_shader_atomic_int64
#endif // GL_NV_shader_atomic_int64
#ifdef GL_NV_shader_buffer_load
namespace nv_shader_buffer_load {
constexpr u32 buffer_gpu_address_nv = 0x8F1D;
constexpr u32 gpu_address_nv = 0x8F34;
constexpr u32 max_shader_buffer_address_nv = 0x8F35;
template<
    class span_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE void get_buffer_parameterui64v_nv(groups::buffer_target_arb target, GLenum pname, span_GLuint64EXT params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetBufferParameterui64vNV)
                Throw(undefined_behavior(
                    "unloaded function GetBufferParameterui64vNV"));
    }
    glGetBufferParameterui64vNV(static_cast<GLenum>(target), pname, reinterpret_cast<GLuint64EXT *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE void get_integerui64v_nv(GLenum value, span_GLuint64EXT result)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetIntegerui64vNV)
                Throw(undefined_behavior(
                    "unloaded function GetIntegerui64vNV"));
    }
    glGetIntegerui64vNV(value, reinterpret_cast<GLuint64EXT *>(result.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE void get_named_buffer_parameterui64v_nv(u32 buffer, groups::buffer_prop_arb pname, span_GLuint64EXT params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetNamedBufferParameterui64vNV)
                Throw(undefined_behavior(
                    "unloaded function GetNamedBufferParameterui64vNV"));
        glIsBuffer(buffer);
    }
    glGetNamedBufferParameterui64vNV(buffer, static_cast<GLenum>(pname), reinterpret_cast<GLuint64EXT *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE void get_uniformui64v_nv(u32 program, i32 location, span_GLuint64EXT params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetUniformui64vNV)
                Throw(undefined_behavior(
                    "unloaded function GetUniformui64vNV"));
        glIsProgram(program);
    }
    glGetUniformui64vNV(program, location, reinterpret_cast<GLuint64EXT *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_buffer_resident_nv(GLenum target)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsBufferResidentNV)
                Throw(undefined_behavior(
                    "unloaded function IsBufferResidentNV"));
    }
    auto out = glIsBufferResidentNV(target);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLboolean is_named_buffer_resident_nv(u32 buffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsNamedBufferResidentNV)
                Throw(undefined_behavior(
                    "unloaded function IsNamedBufferResidentNV"));
        glIsBuffer(buffer);
    }
    auto out = glIsNamedBufferResidentNV(buffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void make_buffer_non_resident_nv(GLenum target)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMakeBufferNonResidentNV)
                Throw(undefined_behavior(
                    "unloaded function MakeBufferNonResidentNV"));
    }
    glMakeBufferNonResidentNV(target);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void make_buffer_resident_nv(GLenum target, GLenum access)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMakeBufferResidentNV)
                Throw(undefined_behavior(
                    "unloaded function MakeBufferResidentNV"));
    }
    glMakeBufferResidentNV(target, access);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void make_named_buffer_non_resident_nv(u32 buffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMakeNamedBufferNonResidentNV)
                Throw(undefined_behavior(
                    "unloaded function MakeNamedBufferNonResidentNV"));
        glIsBuffer(buffer);
    }
    glMakeNamedBufferNonResidentNV(buffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void make_named_buffer_resident_nv(u32 buffer, GLenum access)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMakeNamedBufferResidentNV)
                Throw(undefined_behavior(
                    "unloaded function MakeNamedBufferResidentNV"));
        glIsBuffer(buffer);
    }
    glMakeNamedBufferResidentNV(buffer, access);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void program_uniform(u32 program, i32 location, GLuint64EXT value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformui64NV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformui64NV"));
        glIsProgram(program);
    }
    glProgramUniformui64NV(program, location, value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_const_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE void program_uniform(u32 program, i32 location, span_const_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramUniformui64vNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramUniformui64vNV"));
        glIsProgram(program);
    }
    glProgramUniformui64vNV(program, location, value.size(), reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void uniform(i32 location, GLuint64EXT value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformui64NV)
                Throw(undefined_behavior(
                    "unloaded function Uniformui64NV"));
    }
    glUniformui64NV(location, value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_const_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE void uniform(i32 location, i32 count, span_const_GLuint64EXT const& value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUniformui64vNV)
                Throw(undefined_behavior(
                    "unloaded function Uniformui64vNV"));
    }
    glUniformui64vNV(location, count, reinterpret_cast<const GLuint64EXT *>(value.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_shader_buffer_load
#endif // GL_NV_shader_buffer_load
#ifdef GL_NV_shader_buffer_store
namespace nv_shader_buffer_store {
constexpr u32 shader_global_access_barrier_bit_nv = 0x00000010;
constexpr u32 write_only = 0x88B9;
constexpr u32 read_write = 0x88BA;
} // nv_shader_buffer_store
#endif // GL_NV_shader_buffer_store
#ifdef GL_NV_shader_noperspective_interpolation
namespace nv_shader_noperspective_interpolation {
} // nv_shader_noperspective_interpolation
#endif // GL_NV_shader_noperspective_interpolation
#ifdef GL_NV_shader_storage_buffer_object
namespace nv_shader_storage_buffer_object {
} // nv_shader_storage_buffer_object
#endif // GL_NV_shader_storage_buffer_object
#ifdef GL_NV_shader_subgroup_partitioned
namespace nv_shader_subgroup_partitioned {
constexpr u32 subgroup_feature_partitioned_bit_nv = 0x00000100;
} // nv_shader_subgroup_partitioned
#endif // GL_NV_shader_subgroup_partitioned
#ifdef GL_NV_shader_texture_footprint
namespace nv_shader_texture_footprint {
} // nv_shader_texture_footprint
#endif // GL_NV_shader_texture_footprint
#ifdef GL_NV_shader_thread_group
namespace nv_shader_thread_group {
constexpr u32 warp_size_nv = 0x9339;
constexpr u32 warps_per_sm_nv = 0x933A;
constexpr u32 sm_count_nv = 0x933B;
} // nv_shader_thread_group
#endif // GL_NV_shader_thread_group
#ifdef GL_NV_shader_thread_shuffle
namespace nv_shader_thread_shuffle {
} // nv_shader_thread_shuffle
#endif // GL_NV_shader_thread_shuffle
#ifdef GL_NV_shading_rate_image
namespace nv_shading_rate_image {
constexpr u32 shading_rate_image_binding_nv = 0x955B;
constexpr u32 shading_rate_image_texel_width_nv = 0x955C;
constexpr u32 shading_rate_image_texel_height_nv = 0x955D;
constexpr u32 shading_rate_image_palette_size_nv = 0x955E;
constexpr u32 max_coarse_fragment_samples_nv = 0x955F;
constexpr u32 shading_rate_image_nv = 0x9563;
constexpr u32 shading_rate_no_invocations_nv = 0x9564;
constexpr u32 shading_rate_1_invocation_per_pixel_nv = 0x9565;
constexpr u32 shading_rate_1_invocation_per_1x2_pixels_nv = 0x9566;
constexpr u32 shading_rate_1_invocation_per_2x1_pixels_nv = 0x9567;
constexpr u32 shading_rate_1_invocation_per_2x2_pixels_nv = 0x9568;
constexpr u32 shading_rate_1_invocation_per_2x4_pixels_nv = 0x9569;
constexpr u32 shading_rate_1_invocation_per_4x2_pixels_nv = 0x956A;
constexpr u32 shading_rate_1_invocation_per_4x4_pixels_nv = 0x956B;
constexpr u32 shading_rate_2_invocations_per_pixel_nv = 0x956C;
constexpr u32 shading_rate_4_invocations_per_pixel_nv = 0x956D;
constexpr u32 shading_rate_8_invocations_per_pixel_nv = 0x956E;
constexpr u32 shading_rate_16_invocations_per_pixel_nv = 0x956F;
constexpr u32 shading_rate_sample_order_default_nv = 0x95AE;
constexpr u32 shading_rate_sample_order_pixel_major_nv = 0x95AF;
constexpr u32 shading_rate_sample_order_sample_major_nv = 0x95B0;
STATICINLINE void bind_shading_rate_image_nv(u32 texture)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindShadingRateImageNV)
                Throw(undefined_behavior(
                    "unloaded function BindShadingRateImageNV"));
        glIsTexture(texture);
    }
    glBindShadingRateImageNV(texture);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void get_shading_rate_image_palette_nv(u32 viewport, u32 entry, GLenum& rate)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetShadingRateImagePaletteNV)
                Throw(undefined_behavior(
                    "unloaded function GetShadingRateImagePaletteNV"));
    }
    glGetShadingRateImagePaletteNV(viewport, entry, &rate);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_shading_rate_sample_locationiv_nv(GLenum rate, u32 samples, u32 index, span_i32 location)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetShadingRateSampleLocationivNV)
                Throw(undefined_behavior(
                    "unloaded function GetShadingRateSampleLocationivNV"));
    }
    glGetShadingRateSampleLocationivNV(rate, samples, index, reinterpret_cast<GLint *>(location.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void shading_rate_image_barrier_nv(bool synchronize)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glShadingRateImageBarrierNV)
                Throw(undefined_behavior(
                    "unloaded function ShadingRateImageBarrierNV"));
    }
    glShadingRateImageBarrierNV(synchronize);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLenum
>
requires (
    semantic::concepts::Span<span_const_GLenum> &&
    std::is_same_v<std::decay_t<typename span_const_GLenum::value_type>, GLenum>)
STATICINLINE void shading_rate_image_palette_nv(u32 viewport, u32 first, span_const_GLenum const& rates)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glShadingRateImagePaletteNV)
                Throw(undefined_behavior(
                    "unloaded function ShadingRateImagePaletteNV"));
    }
    glShadingRateImagePaletteNV(viewport, first, rates.size(), reinterpret_cast<const GLenum *>(rates.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void shading_rate_sample_order_nv(GLenum order)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glShadingRateSampleOrderNV)
                Throw(undefined_behavior(
                    "unloaded function ShadingRateSampleOrderNV"));
    }
    glShadingRateSampleOrderNV(order);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void shading_rate_sample_order_custom_nv(GLenum rate, u32 samples, span_const_i32 const& locations)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glShadingRateSampleOrderCustomNV)
                Throw(undefined_behavior(
                    "unloaded function ShadingRateSampleOrderCustomNV"));
    }
    glShadingRateSampleOrderCustomNV(rate, samples, reinterpret_cast<const GLint *>(locations.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_shading_rate_image
#endif // GL_NV_shading_rate_image
#ifdef GL_NV_shadow_samplers_array
namespace nv_shadow_samplers_array {
constexpr u32 sampler_2d_array_shadow_nv = 0x8DC4;
} // nv_shadow_samplers_array
#endif // GL_NV_shadow_samplers_array
#ifdef GL_NV_shadow_samplers_cube
namespace nv_shadow_samplers_cube {
constexpr u32 sampler_cube_shadow_nv = 0x8DC5;
} // nv_shadow_samplers_cube
#endif // GL_NV_shadow_samplers_cube
#ifdef GL_NV_stereo_view_rendering
namespace nv_stereo_view_rendering {
} // nv_stereo_view_rendering
#endif // GL_NV_stereo_view_rendering
#ifdef GL_NV_tessellation_program5
namespace nv_tessellation_program5 {
constexpr u32 max_program_patch_attribs_nv = 0x86D8;
constexpr u32 tess_control_program_nv = 0x891E;
constexpr u32 tess_evaluation_program_nv = 0x891F;
constexpr u32 tess_control_program_parameter_buffer_nv = 0x8C74;
constexpr u32 tess_evaluation_program_parameter_buffer_nv = 0x8C75;
} // nv_tessellation_program5
#endif // GL_NV_tessellation_program5
#ifdef GL_NV_texgen_emboss
namespace nv_texgen_emboss {
constexpr u32 emboss_light_nv = 0x855D;
constexpr u32 emboss_constant_nv = 0x855E;
constexpr u32 emboss_map_nv = 0x855F;
} // nv_texgen_emboss
#endif // GL_NV_texgen_emboss
#ifdef GL_NV_texgen_reflection
namespace nv_texgen_reflection {
constexpr u32 normal_map_nv = 0x8511;
constexpr u32 reflection_map_nv = 0x8512;
} // nv_texgen_reflection
#endif // GL_NV_texgen_reflection
#ifdef GL_NV_texture_barrier
namespace nv_texture_barrier {
STATICINLINE void texture_barrier_nv()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureBarrierNV)
                Throw(undefined_behavior(
                    "unloaded function TextureBarrierNV"));
    }
    glTextureBarrierNV();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_texture_barrier
#endif // GL_NV_texture_barrier
#ifdef GL_NV_texture_border_clamp
namespace nv_texture_border_clamp {
constexpr u32 texture_border_color_nv = 0x1004;
constexpr u32 clamp_to_border_nv = 0x812D;
} // nv_texture_border_clamp
#endif // GL_NV_texture_border_clamp
#ifdef GL_NV_texture_compression_s3tc_update
namespace nv_texture_compression_s3tc_update {
} // nv_texture_compression_s3tc_update
#endif // GL_NV_texture_compression_s3tc_update
#ifdef GL_NV_texture_compression_vtc
namespace nv_texture_compression_vtc {
} // nv_texture_compression_vtc
#endif // GL_NV_texture_compression_vtc
#ifdef GL_NV_texture_env_combine4
namespace nv_texture_env_combine4 {
constexpr u32 combine4_nv = 0x8503;
constexpr u32 source3_rgb_nv = 0x8583;
constexpr u32 source3_alpha_nv = 0x858B;
constexpr u32 operand3_rgb_nv = 0x8593;
constexpr u32 operand3_alpha_nv = 0x859B;
} // nv_texture_env_combine4
#endif // GL_NV_texture_env_combine4
#ifdef GL_NV_texture_expand_normal
namespace nv_texture_expand_normal {
constexpr u32 texture_unsigned_remap_mode_nv = 0x888F;
} // nv_texture_expand_normal
#endif // GL_NV_texture_expand_normal
#ifdef GL_NV_texture_multisample
namespace nv_texture_multisample {
constexpr u32 texture_coverage_samples_nv = 0x9045;
constexpr u32 texture_color_samples_nv = 0x9046;
template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void tex_image_2d_multisample_coverage_nv(groups::texture_target target, i32 coverageSamples, i32 colorSamples, i32 internalFormat, vec_2_i32 const& width, bool fixedSampleLocations)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexImage2DMultisampleCoverageNV)
                Throw(undefined_behavior(
                    "unloaded function TexImage2DMultisampleCoverageNV"));
    }
    glTexImage2DMultisampleCoverageNV(static_cast<GLenum>(target), coverageSamples, colorSamples, internalFormat, width[0], width[1], fixedSampleLocations);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void tex_image_3d_multisample_coverage_nv(groups::texture_target target, i32 coverageSamples, i32 colorSamples, i32 internalFormat, vec_3_i32 const& width, bool fixedSampleLocations)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexImage3DMultisampleCoverageNV)
                Throw(undefined_behavior(
                    "unloaded function TexImage3DMultisampleCoverageNV"));
    }
    glTexImage3DMultisampleCoverageNV(static_cast<GLenum>(target), coverageSamples, colorSamples, internalFormat, width[0], width[1], width[2], fixedSampleLocations);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void texture_image_2d_multisample_coverage_nv(u32 texture, groups::texture_target target, i32 coverageSamples, i32 colorSamples, i32 internalFormat, vec_2_i32 const& width, bool fixedSampleLocations)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureImage2DMultisampleCoverageNV)
                Throw(undefined_behavior(
                    "unloaded function TextureImage2DMultisampleCoverageNV"));
        glIsTexture(texture);
    }
    glTextureImage2DMultisampleCoverageNV(texture, static_cast<GLenum>(target), coverageSamples, colorSamples, internalFormat, width[0], width[1], fixedSampleLocations);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void texture_image_2d_multisample_nv(u32 texture, groups::texture_target target, i32 samples, i32 internalFormat, vec_2_i32 const& width, bool fixedSampleLocations)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureImage2DMultisampleNV)
                Throw(undefined_behavior(
                    "unloaded function TextureImage2DMultisampleNV"));
        glIsTexture(texture);
    }
    glTextureImage2DMultisampleNV(texture, static_cast<GLenum>(target), samples, internalFormat, width[0], width[1], fixedSampleLocations);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void texture_image_3d_multisample_coverage_nv(u32 texture, groups::texture_target target, i32 coverageSamples, i32 colorSamples, i32 internalFormat, vec_3_i32 const& width, bool fixedSampleLocations)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureImage3DMultisampleCoverageNV)
                Throw(undefined_behavior(
                    "unloaded function TextureImage3DMultisampleCoverageNV"));
        glIsTexture(texture);
    }
    glTextureImage3DMultisampleCoverageNV(texture, static_cast<GLenum>(target), coverageSamples, colorSamples, internalFormat, width[0], width[1], width[2], fixedSampleLocations);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void texture_image_3d_multisample_nv(u32 texture, groups::texture_target target, i32 samples, i32 internalFormat, vec_3_i32 const& width, bool fixedSampleLocations)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureImage3DMultisampleNV)
                Throw(undefined_behavior(
                    "unloaded function TextureImage3DMultisampleNV"));
        glIsTexture(texture);
    }
    glTextureImage3DMultisampleNV(texture, static_cast<GLenum>(target), samples, internalFormat, width[0], width[1], width[2], fixedSampleLocations);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_texture_multisample
#endif // GL_NV_texture_multisample
#ifdef GL_NV_texture_npot_2D_mipmap
namespace nv_texture_npot_2d_mipmap {
} // nv_texture_npot_2d_mipmap
#endif // GL_NV_texture_npot_2D_mipmap
#ifdef GL_NV_texture_rectangle
namespace nv_texture_rectangle {
constexpr u32 texture_rectangle_nv = 0x84F5;
constexpr u32 texture_binding_rectangle_nv = 0x84F6;
constexpr u32 proxy_texture_rectangle_nv = 0x84F7;
constexpr u32 max_rectangle_texture_size_nv = 0x84F8;
} // nv_texture_rectangle
#endif // GL_NV_texture_rectangle
#ifdef GL_NV_texture_rectangle_compressed
namespace nv_texture_rectangle_compressed {
} // nv_texture_rectangle_compressed
#endif // GL_NV_texture_rectangle_compressed
#ifdef GL_NV_texture_shader
namespace nv_texture_shader {
constexpr u32 offset_texture_rectangle_nv = 0x864C;
constexpr u32 offset_texture_rectangle_scale_nv = 0x864D;
constexpr u32 dot_product_texture_rectangle_nv = 0x864E;
constexpr u32 rgba_unsigned_dot_product_mapping_nv = 0x86D9;
constexpr u32 unsigned_int_s8_s8_8_8_nv = 0x86DA;
constexpr u32 unsigned_int_8_8_s8_s8_rev_nv = 0x86DB;
constexpr u32 dsdt_mag_intensity_nv = 0x86DC;
constexpr u32 shader_consistent_nv = 0x86DD;
constexpr u32 texture_shader_nv = 0x86DE;
constexpr u32 shader_operation_nv = 0x86DF;
constexpr u32 cull_modes_nv = 0x86E0;
constexpr u32 offset_texture_matrix_nv = 0x86E1;
constexpr u32 offset_texture_2d_matrix_nv = 0x86E1;
constexpr u32 offset_texture_scale_nv = 0x86E2;
constexpr u32 offset_texture_2d_scale_nv = 0x86E2;
constexpr u32 offset_texture_bias_nv = 0x86E3;
constexpr u32 offset_texture_2d_bias_nv = 0x86E3;
constexpr u32 previous_texture_input_nv = 0x86E4;
constexpr u32 const_eye_nv = 0x86E5;
constexpr u32 pass_through_nv = 0x86E6;
constexpr u32 cull_fragment_nv = 0x86E7;
constexpr u32 offset_texture_2d_nv = 0x86E8;
constexpr u32 dependent_ar_texture_2d_nv = 0x86E9;
constexpr u32 dependent_gb_texture_2d_nv = 0x86EA;
constexpr u32 dot_product_nv = 0x86EC;
constexpr u32 dot_product_depth_replace_nv = 0x86ED;
constexpr u32 dot_product_texture_2d_nv = 0x86EE;
constexpr u32 dot_product_texture_cube_map_nv = 0x86F0;
constexpr u32 dot_product_diffuse_cube_map_nv = 0x86F1;
constexpr u32 dot_product_reflect_cube_map_nv = 0x86F2;
constexpr u32 dot_product_const_eye_reflect_cube_map_nv = 0x86F3;
constexpr u32 hilo_nv = 0x86F4;
constexpr u32 dsdt_nv = 0x86F5;
constexpr u32 dsdt_mag_nv = 0x86F6;
constexpr u32 dsdt_mag_vib_nv = 0x86F7;
constexpr u32 hilo16_nv = 0x86F8;
constexpr u32 signed_hilo_nv = 0x86F9;
constexpr u32 signed_hilo16_nv = 0x86FA;
constexpr u32 signed_rgba_nv = 0x86FB;
constexpr u32 signed_rgba8_nv = 0x86FC;
constexpr u32 signed_rgb_nv = 0x86FE;
constexpr u32 signed_rgb8_nv = 0x86FF;
constexpr u32 signed_luminance_nv = 0x8701;
constexpr u32 signed_luminance8_nv = 0x8702;
constexpr u32 signed_luminance_alpha_nv = 0x8703;
constexpr u32 signed_luminance8_alpha8_nv = 0x8704;
constexpr u32 signed_alpha_nv = 0x8705;
constexpr u32 signed_alpha8_nv = 0x8706;
constexpr u32 signed_intensity_nv = 0x8707;
constexpr u32 signed_intensity8_nv = 0x8708;
constexpr u32 dsdt8_nv = 0x8709;
constexpr u32 dsdt8_mag8_nv = 0x870A;
constexpr u32 dsdt8_mag8_intensity8_nv = 0x870B;
constexpr u32 signed_rgb_unsigned_alpha_nv = 0x870C;
constexpr u32 signed_rgb8_unsigned_alpha8_nv = 0x870D;
constexpr u32 hi_scale_nv = 0x870E;
constexpr u32 lo_scale_nv = 0x870F;
constexpr u32 ds_scale_nv = 0x8710;
constexpr u32 dt_scale_nv = 0x8711;
constexpr u32 magnitude_scale_nv = 0x8712;
constexpr u32 vibrance_scale_nv = 0x8713;
constexpr u32 hi_bias_nv = 0x8714;
constexpr u32 lo_bias_nv = 0x8715;
constexpr u32 ds_bias_nv = 0x8716;
constexpr u32 dt_bias_nv = 0x8717;
constexpr u32 magnitude_bias_nv = 0x8718;
constexpr u32 vibrance_bias_nv = 0x8719;
constexpr u32 texture_border_values_nv = 0x871A;
constexpr u32 texture_hi_size_nv = 0x871B;
constexpr u32 texture_lo_size_nv = 0x871C;
constexpr u32 texture_ds_size_nv = 0x871D;
constexpr u32 texture_dt_size_nv = 0x871E;
constexpr u32 texture_mag_size_nv = 0x871F;
} // nv_texture_shader
#endif // GL_NV_texture_shader
#ifdef GL_NV_texture_shader2
namespace nv_texture_shader2 {
constexpr u32 dot_product_texture_3d_nv = 0x86EF;
} // nv_texture_shader2
#endif // GL_NV_texture_shader2
#ifdef GL_NV_texture_shader3
namespace nv_texture_shader3 {
constexpr u32 offset_projective_texture_2d_nv = 0x8850;
constexpr u32 offset_projective_texture_2d_scale_nv = 0x8851;
constexpr u32 offset_projective_texture_rectangle_nv = 0x8852;
constexpr u32 offset_projective_texture_rectangle_scale_nv = 0x8853;
constexpr u32 offset_hilo_texture_2d_nv = 0x8854;
constexpr u32 offset_hilo_texture_rectangle_nv = 0x8855;
constexpr u32 offset_hilo_projective_texture_2d_nv = 0x8856;
constexpr u32 offset_hilo_projective_texture_rectangle_nv = 0x8857;
constexpr u32 dependent_hilo_texture_2d_nv = 0x8858;
constexpr u32 dependent_rgb_texture_3d_nv = 0x8859;
constexpr u32 dependent_rgb_texture_cube_map_nv = 0x885A;
constexpr u32 dot_product_pass_through_nv = 0x885B;
constexpr u32 dot_product_texture_1d_nv = 0x885C;
constexpr u32 dot_product_affine_depth_replace_nv = 0x885D;
constexpr u32 hilo8_nv = 0x885E;
constexpr u32 signed_hilo8_nv = 0x885F;
constexpr u32 force_blue_to_one_nv = 0x8860;
} // nv_texture_shader3
#endif // GL_NV_texture_shader3
#ifdef GL_NV_transform_feedback
namespace nv_transform_feedback {
constexpr u32 next_buffer_nv = -2;
constexpr u32 skip_components4_nv = -3;
constexpr u32 skip_components3_nv = -4;
constexpr u32 skip_components2_nv = -5;
constexpr u32 skip_components1_nv = -6;
constexpr u32 back_primary_color_nv = 0x8C77;
constexpr u32 back_secondary_color_nv = 0x8C78;
constexpr u32 texture_coord_nv = 0x8C79;
constexpr u32 clip_distance_nv = 0x8C7A;
constexpr u32 vertex_id_nv = 0x8C7B;
constexpr u32 primitive_id_nv = 0x8C7C;
constexpr u32 generic_attrib_nv = 0x8C7D;
constexpr u32 transform_feedback_attribs_nv = 0x8C7E;
constexpr u32 transform_feedback_buffer_mode_nv = 0x8C7F;
constexpr u32 max_transform_feedback_separate_components_nv = 0x8C80;
constexpr u32 active_varyings_nv = 0x8C81;
constexpr u32 active_varying_max_length_nv = 0x8C82;
constexpr u32 transform_feedback_varyings_nv = 0x8C83;
constexpr u32 transform_feedback_buffer_start_nv = 0x8C84;
constexpr u32 transform_feedback_buffer_size_nv = 0x8C85;
constexpr u32 transform_feedback_record_nv = 0x8C86;
constexpr u32 primitives_generated_nv = 0x8C87;
constexpr u32 transform_feedback_primitives_written_nv = 0x8C88;
constexpr u32 rasterizer_discard_nv = 0x8C89;
constexpr u32 max_transform_feedback_interleaved_components_nv = 0x8C8A;
constexpr u32 max_transform_feedback_separate_attribs_nv = 0x8C8B;
constexpr u32 interleaved_attribs_nv = 0x8C8C;
constexpr u32 separate_attribs_nv = 0x8C8D;
constexpr u32 transform_feedback_buffer_nv = 0x8C8E;
constexpr u32 transform_feedback_buffer_binding_nv = 0x8C8F;
constexpr u32 layer_nv = 0x8DAA;
STATICINLINE void active_varying_nv(u32 program, std::string_view const& name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glActiveVaryingNV)
                Throw(undefined_behavior(
                    "unloaded function ActiveVaryingNV"));
        glIsProgram(program);
    }
    glActiveVaryingNV(program, name.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void begin_transform_feedback_nv(groups::primitive_type primitiveMode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBeginTransformFeedbackNV)
                Throw(undefined_behavior(
                    "unloaded function BeginTransformFeedbackNV"));
    }
    glBeginTransformFeedbackNV(static_cast<GLenum>(primitiveMode));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void bind_buffer_base_nv(groups::buffer_target_arb target, u32 index, u32 buffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindBufferBaseNV)
                Throw(undefined_behavior(
                    "unloaded function BindBufferBaseNV"));
        glIsBuffer(buffer);
    }
    glBindBufferBaseNV(static_cast<GLenum>(target), index, buffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void bind_buffer_offset_nv(groups::buffer_target_arb target, u32 index, u32 buffer, GLintptr offset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindBufferOffsetNV)
                Throw(undefined_behavior(
                    "unloaded function BindBufferOffsetNV"));
        glIsBuffer(buffer);
    }
    glBindBufferOffsetNV(static_cast<GLenum>(target), index, buffer, offset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void bind_buffer_range_nv(groups::buffer_target_arb target, u32 index, u32 buffer, GLintptr offset, GLsizeiptr size)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindBufferRangeNV)
                Throw(undefined_behavior(
                    "unloaded function BindBufferRangeNV"));
        glIsBuffer(buffer);
    }
    glBindBufferRangeNV(static_cast<GLenum>(target), index, buffer, offset, size);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void end_transform_feedback_nv()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEndTransformFeedbackNV)
                Throw(undefined_behavior(
                    "unloaded function EndTransformFeedbackNV"));
    }
    glEndTransformFeedbackNV();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLchar
>
requires (
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE void get_active_varying_nv(u32 program, u32 index, i32& length, i32& size, GLenum& type, span_GLchar name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetActiveVaryingNV)
                Throw(undefined_behavior(
                    "unloaded function GetActiveVaryingNV"));
        glIsProgram(program);
    }
    glGetActiveVaryingNV(program, index, name.size(), &length, &size, &type, name.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void get_transform_feedback_varying_nv(u32 program, u32 index, i32& location)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTransformFeedbackVaryingNV)
                Throw(undefined_behavior(
                    "unloaded function GetTransformFeedbackVaryingNV"));
        glIsProgram(program);
    }
    glGetTransformFeedbackVaryingNV(program, index, &location);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLint get_varying_location_nv(u32 program, std::string_view const& name)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVaryingLocationNV)
                Throw(undefined_behavior(
                    "unloaded function GetVaryingLocationNV"));
        glIsProgram(program);
    }
    auto out = glGetVaryingLocationNV(program, name.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void transform_feedback_attribs_nv(i32 count, span_const_i32 const& attribs, GLenum bufferMode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTransformFeedbackAttribsNV)
                Throw(undefined_behavior(
                    "unloaded function TransformFeedbackAttribsNV"));
    }
    glTransformFeedbackAttribsNV(count, reinterpret_cast<const GLint *>(attribs.data()), bufferMode);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void transform_feedback_varyings_nv(u32 program, span_const_i32 const& locations, GLenum bufferMode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTransformFeedbackVaryingsNV)
                Throw(undefined_behavior(
                    "unloaded function TransformFeedbackVaryingsNV"));
        glIsProgram(program);
    }
    glTransformFeedbackVaryingsNV(program, locations.size(), reinterpret_cast<const GLint *>(locations.data()), bufferMode);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void transform_feedback_stream_attribs_nv(span_const_i32 const& attribs, span_const_i32 const& bufstreams, GLenum bufferMode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTransformFeedbackStreamAttribsNV)
                Throw(undefined_behavior(
                    "unloaded function TransformFeedbackStreamAttribsNV"));
    }
    glTransformFeedbackStreamAttribsNV(attribs.size(), reinterpret_cast<const GLint *>(attribs.data()), bufstreams.size(), reinterpret_cast<const GLint *>(bufstreams.data()), bufferMode);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_transform_feedback
#endif // GL_NV_transform_feedback
#ifdef GL_NV_transform_feedback2
namespace nv_transform_feedback2 {
constexpr u32 transform_feedback_nv = 0x8E22;
constexpr u32 transform_feedback_buffer_paused_nv = 0x8E23;
constexpr u32 transform_feedback_buffer_active_nv = 0x8E24;
constexpr u32 transform_feedback_binding_nv = 0x8E25;
STATICINLINE void bind_transform_feedback_nv(groups::buffer_target_arb target, u32 id)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindTransformFeedbackNV)
                Throw(undefined_behavior(
                    "unloaded function BindTransformFeedbackNV"));
    }
    glBindTransformFeedbackNV(static_cast<GLenum>(target), id);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_transform_feedbacks_nv(span_const_u32 const& ids)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteTransformFeedbacksNV)
                Throw(undefined_behavior(
                    "unloaded function DeleteTransformFeedbacksNV"));
    }
    glDeleteTransformFeedbacksNV(ids.size(), reinterpret_cast<const GLuint *>(ids.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void draw_transform_feedback_nv(groups::primitive_type mode, u32 id)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawTransformFeedbackNV)
                Throw(undefined_behavior(
                    "unloaded function DrawTransformFeedbackNV"));
    }
    glDrawTransformFeedbackNV(static_cast<GLenum>(mode), id);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void gen_transform_feedbacks_nv(span_u32 ids)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenTransformFeedbacksNV)
                Throw(undefined_behavior(
                    "unloaded function GenTransformFeedbacksNV"));
    }
    glGenTransformFeedbacksNV(ids.size(), reinterpret_cast<GLuint *>(ids.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_transform_feedback_nv(u32 id)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsTransformFeedbackNV)
                Throw(undefined_behavior(
                    "unloaded function IsTransformFeedbackNV"));
    }
    auto out = glIsTransformFeedbackNV(id);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void pause_transform_feedback_nv()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPauseTransformFeedbackNV)
                Throw(undefined_behavior(
                    "unloaded function PauseTransformFeedbackNV"));
    }
    glPauseTransformFeedbackNV();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void resume_transform_feedback_nv()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glResumeTransformFeedbackNV)
                Throw(undefined_behavior(
                    "unloaded function ResumeTransformFeedbackNV"));
    }
    glResumeTransformFeedbackNV();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_transform_feedback2
#endif // GL_NV_transform_feedback2
#ifdef GL_NV_uniform_buffer_unified_memory
namespace nv_uniform_buffer_unified_memory {
constexpr u32 uniform_buffer_unified_nv = 0x936E;
constexpr u32 uniform_buffer_address_nv = 0x936F;
constexpr u32 uniform_buffer_length_nv = 0x9370;
} // nv_uniform_buffer_unified_memory
#endif // GL_NV_uniform_buffer_unified_memory
#ifdef GL_NV_vdpau_interop
namespace nv_vdpau_interop {
constexpr u32 surface_state_nv = 0x86EB;
constexpr u32 surface_registered_nv = 0x86FD;
constexpr u32 surface_mapped_nv = 0x8700;
constexpr u32 write_discard_nv = 0x88BE;
STATICINLINE void vdpau_fini_nv()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVDPAUFiniNV)
                Throw(undefined_behavior(
                    "unloaded function VDPAUFiniNV"));
    }
    glVDPAUFiniNV();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void vdpau_get_surfaceiv_nv(GLvdpauSurfaceNV surface, GLenum pname, span_i32 length, span_i32 values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVDPAUGetSurfaceivNV)
                Throw(undefined_behavior(
                    "unloaded function VDPAUGetSurfaceivNV"));
    }
    glVDPAUGetSurfaceivNV(surface, pname, values.size(), reinterpret_cast<GLsizei *>(length.data()), reinterpret_cast<GLint *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void vdpau_init_nv(span_const_byte const& vdpDevice, span_const_byte const& getProcAddress)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVDPAUInitNV)
                Throw(undefined_behavior(
                    "unloaded function VDPAUInitNV"));
    }
    glVDPAUInitNV(reinterpret_cast<const void *>(vdpDevice.data()), reinterpret_cast<const void *>(getProcAddress.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean vdpau_is_surface_nv(GLvdpauSurfaceNV surface)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVDPAUIsSurfaceNV)
                Throw(undefined_behavior(
                    "unloaded function VDPAUIsSurfaceNV"));
    }
    auto out = glVDPAUIsSurfaceNV(surface);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_GLvdpauSurfaceNV
>
requires (
    semantic::concepts::Span<span_const_GLvdpauSurfaceNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLvdpauSurfaceNV::value_type>, GLvdpauSurfaceNV>)
STATICINLINE void vdpau_map_surfaces_nv(span_const_GLvdpauSurfaceNV const& surfaces)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVDPAUMapSurfacesNV)
                Throw(undefined_behavior(
                    "unloaded function VDPAUMapSurfacesNV"));
    }
    glVDPAUMapSurfacesNV(surfaces.size(), reinterpret_cast<const GLvdpauSurfaceNV *>(surfaces.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte> &&
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE GLvdpauSurfaceNV vdpau_register_output_surface_nv(span_const_byte const& vdpSurface, GLenum target, span_const_u32 const& textureNames)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVDPAURegisterOutputSurfaceNV)
                Throw(undefined_behavior(
                    "unloaded function VDPAURegisterOutputSurfaceNV"));
    }
    auto out = glVDPAURegisterOutputSurfaceNV(reinterpret_cast<const void *>(vdpSurface.data()), target, textureNames.size(), reinterpret_cast<const GLuint *>(textureNames.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_byte,
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte> &&
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE GLvdpauSurfaceNV vdpau_register_video_surface_nv(span_const_byte const& vdpSurface, GLenum target, span_const_u32 const& textureNames)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVDPAURegisterVideoSurfaceNV)
                Throw(undefined_behavior(
                    "unloaded function VDPAURegisterVideoSurfaceNV"));
    }
    auto out = glVDPAURegisterVideoSurfaceNV(reinterpret_cast<const void *>(vdpSurface.data()), target, textureNames.size(), reinterpret_cast<const GLuint *>(textureNames.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void vdpau_surface_access_nv(GLvdpauSurfaceNV surface, GLenum access)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVDPAUSurfaceAccessNV)
                Throw(undefined_behavior(
                    "unloaded function VDPAUSurfaceAccessNV"));
    }
    glVDPAUSurfaceAccessNV(surface, access);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLvdpauSurfaceNV
>
requires (
    semantic::concepts::Span<span_const_GLvdpauSurfaceNV> &&
    std::is_same_v<std::decay_t<typename span_const_GLvdpauSurfaceNV::value_type>, GLvdpauSurfaceNV>)
STATICINLINE void vdpau_unmap_surfaces_nv(span_const_GLvdpauSurfaceNV const& surfaces)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVDPAUUnmapSurfacesNV)
                Throw(undefined_behavior(
                    "unloaded function VDPAUUnmapSurfacesNV"));
    }
    glVDPAUUnmapSurfacesNV(surfaces.size(), reinterpret_cast<const GLvdpauSurfaceNV *>(surfaces.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vdpau_unregister_surface_nv(GLvdpauSurfaceNV surface)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVDPAUUnregisterSurfaceNV)
                Throw(undefined_behavior(
                    "unloaded function VDPAUUnregisterSurfaceNV"));
    }
    glVDPAUUnregisterSurfaceNV(surface);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_vdpau_interop
#endif // GL_NV_vdpau_interop
#ifdef GL_NV_vdpau_interop2
namespace nv_vdpau_interop2 {
template<
    class span_const_byte,
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte> &&
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE GLvdpauSurfaceNV vdpau_register_video_surface_with_picture_structure_nv(span_const_byte const& vdpSurface, GLenum target, span_const_u32 const& textureNames, bool isFrameStructure)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVDPAURegisterVideoSurfaceWithPictureStructureNV)
                Throw(undefined_behavior(
                    "unloaded function VDPAURegisterVideoSurfaceWithPictureStructureNV"));
    }
    auto out = glVDPAURegisterVideoSurfaceWithPictureStructureNV(reinterpret_cast<const void *>(vdpSurface.data()), target, textureNames.size(), reinterpret_cast<const GLuint *>(textureNames.data()), isFrameStructure);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // nv_vdpau_interop2
#endif // GL_NV_vdpau_interop2
#ifdef GL_NV_vertex_array_range
namespace nv_vertex_array_range {
constexpr u32 vertex_array_range_nv = 0x851D;
constexpr u32 vertex_array_range_length_nv = 0x851E;
constexpr u32 vertex_array_range_valid_nv = 0x851F;
constexpr u32 max_vertex_array_range_element_nv = 0x8520;
constexpr u32 vertex_array_range_pointer_nv = 0x8521;
STATICINLINE void flush_vertex_array_range_nv()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFlushVertexArrayRangeNV)
                Throw(undefined_behavior(
                    "unloaded function FlushVertexArrayRangeNV"));
    }
    glFlushVertexArrayRangeNV();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void vertex_array_range_nv(i32 length, span_const_byte const& pointer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexArrayRangeNV)
                Throw(undefined_behavior(
                    "unloaded function VertexArrayRangeNV"));
    }
    glVertexArrayRangeNV(length, reinterpret_cast<const void *>(pointer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_vertex_array_range
#endif // GL_NV_vertex_array_range
#ifdef GL_NV_vertex_array_range2
namespace nv_vertex_array_range2 {
constexpr u32 vertex_array_range_without_flush_nv = 0x8533;
} // nv_vertex_array_range2
#endif // GL_NV_vertex_array_range2
#ifdef GL_NV_vertex_attrib_integer_64bit
namespace nv_vertex_attrib_integer_64bit {
constexpr u32 int64_nv = 0x140E;
constexpr u32 unsigned_int64_nv = 0x140F;
template<
    class span_GLint64EXT
>
requires (
    semantic::concepts::Span<span_GLint64EXT> &&
    std::is_same_v<std::decay_t<typename span_GLint64EXT::value_type>, GLint64EXT>)
STATICINLINE void get_vertex_attrib_li64v_nv(u32 index, groups::vertex_attrib_enum pname, span_GLint64EXT params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribLi64vNV)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribLi64vNV"));
    }
    glGetVertexAttribLi64vNV(index, static_cast<GLenum>(pname), reinterpret_cast<GLint64EXT *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE void get_vertex_attrib_lui64v_nv(u32 index, groups::vertex_attrib_enum pname, span_GLuint64EXT params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribLui64vNV)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribLui64vNV"));
    }
    glGetVertexAttribLui64vNV(index, static_cast<GLenum>(pname), reinterpret_cast<GLuint64EXT *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib_l1i64_nv(u32 index, GLint64EXT x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL1i64NV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL1i64NV"));
    }
    glVertexAttribL1i64NV(index, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_GLint64EXT> &&
    std::is_same_v<std::decay_t<typename span_const_GLint64EXT::value_type>, GLint64EXT>)
STATICINLINE void vertex_attrib_l1i64v_nv(u32 index, span_const_GLint64EXT const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL1i64vNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL1i64vNV"));
    }
    glVertexAttribL1i64vNV(index, reinterpret_cast<const GLint64EXT *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib_l1ui64_nv(u32 index, GLuint64EXT x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL1ui64NV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL1ui64NV"));
    }
    glVertexAttribL1ui64NV(index, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_const_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE void vertex_attrib_l1ui64v_nv(u32 index, span_const_GLuint64EXT const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL1ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL1ui64vNV"));
    }
    glVertexAttribL1ui64vNV(index, reinterpret_cast<const GLuint64EXT *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_GLint64EXT
>
requires (
    semantic::concepts::Vector<vec_2_GLint64EXT, GLint64EXT, 2>)
STATICINLINE void vertex_attrib_l2i64_nv(u32 index, vec_2_GLint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL2i64NV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL2i64NV"));
    }
    glVertexAttribL2i64NV(index, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_2_GLint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_2_GLint64EXT::value_type, GLint64EXT, 2>)
STATICINLINE void vertex_attrib_l2i64v_nv(u32 index, span_const_vec_2_GLint64EXT const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL2i64vNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL2i64vNV"));
    }
    glVertexAttribL2i64vNV(index, reinterpret_cast<const GLint64EXT *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_GLuint64EXT
>
requires (
    semantic::concepts::Vector<vec_2_GLuint64EXT, GLuint64EXT, 2>)
STATICINLINE void vertex_attrib_l2ui64_nv(u32 index, vec_2_GLuint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL2ui64NV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL2ui64NV"));
    }
    glVertexAttribL2ui64NV(index, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_2_GLuint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_2_GLuint64EXT::value_type, GLuint64EXT, 2>)
STATICINLINE void vertex_attrib_l2ui64v_nv(u32 index, span_const_vec_2_GLuint64EXT const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL2ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL2ui64vNV"));
    }
    glVertexAttribL2ui64vNV(index, reinterpret_cast<const GLuint64EXT *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLint64EXT
>
requires (
    semantic::concepts::Vector<vec_3_GLint64EXT, GLint64EXT, 3>)
STATICINLINE void vertex_attrib_l3i64_nv(u32 index, vec_3_GLint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL3i64NV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL3i64NV"));
    }
    glVertexAttribL3i64NV(index, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_3_GLint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_3_GLint64EXT::value_type, GLint64EXT, 3>)
STATICINLINE void vertex_attrib_l3i64v_nv(u32 index, span_const_vec_3_GLint64EXT const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL3i64vNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL3i64vNV"));
    }
    glVertexAttribL3i64vNV(index, reinterpret_cast<const GLint64EXT *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLuint64EXT
>
requires (
    semantic::concepts::Vector<vec_3_GLuint64EXT, GLuint64EXT, 3>)
STATICINLINE void vertex_attrib_l3ui64_nv(u32 index, vec_3_GLuint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL3ui64NV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL3ui64NV"));
    }
    glVertexAttribL3ui64NV(index, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_3_GLuint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_3_GLuint64EXT::value_type, GLuint64EXT, 3>)
STATICINLINE void vertex_attrib_l3ui64v_nv(u32 index, span_const_vec_3_GLuint64EXT const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL3ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL3ui64vNV"));
    }
    glVertexAttribL3ui64vNV(index, reinterpret_cast<const GLuint64EXT *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLint64EXT
>
requires (
    semantic::concepts::Vector<vec_4_GLint64EXT, GLint64EXT, 4>)
STATICINLINE void vertex_attrib_l4i64_nv(u32 index, vec_4_GLint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL4i64NV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL4i64NV"));
    }
    glVertexAttribL4i64NV(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_GLint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_4_GLint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_4_GLint64EXT::value_type, GLint64EXT, 4>)
STATICINLINE void vertex_attrib_l4i64v_nv(u32 index, span_const_vec_4_GLint64EXT const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL4i64vNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL4i64vNV"));
    }
    glVertexAttribL4i64vNV(index, reinterpret_cast<const GLint64EXT *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLuint64EXT
>
requires (
    semantic::concepts::Vector<vec_4_GLuint64EXT, GLuint64EXT, 4>)
STATICINLINE void vertex_attrib_l4ui64_nv(u32 index, vec_4_GLuint64EXT const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL4ui64NV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL4ui64NV"));
    }
    glVertexAttribL4ui64NV(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_const_vec_4_GLuint64EXT> &&
    semantic::concepts::Vector<typename span_const_vec_4_GLuint64EXT::value_type, GLuint64EXT, 4>)
STATICINLINE void vertex_attrib_l4ui64v_nv(u32 index, span_const_vec_4_GLuint64EXT const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribL4ui64vNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribL4ui64vNV"));
    }
    glVertexAttribL4ui64vNV(index, reinterpret_cast<const GLuint64EXT *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib_l_format_nv(u32 index, i32 size, groups::vertex_attrib_long type, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribLFormatNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribLFormatNV"));
    }
    glVertexAttribLFormatNV(index, size, static_cast<GLenum>(type), stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_vertex_attrib_integer_64bit
#endif // GL_NV_vertex_attrib_integer_64bit
#ifdef GL_NV_vertex_buffer_unified_memory
namespace nv_vertex_buffer_unified_memory {
constexpr u32 vertex_attrib_array_unified_nv = 0x8F1E;
constexpr u32 element_array_unified_nv = 0x8F1F;
constexpr u32 vertex_attrib_array_address_nv = 0x8F20;
constexpr u32 vertex_array_address_nv = 0x8F21;
constexpr u32 normal_array_address_nv = 0x8F22;
constexpr u32 color_array_address_nv = 0x8F23;
constexpr u32 index_array_address_nv = 0x8F24;
constexpr u32 texture_coord_array_address_nv = 0x8F25;
constexpr u32 edge_flag_array_address_nv = 0x8F26;
constexpr u32 secondary_color_array_address_nv = 0x8F27;
constexpr u32 fog_coord_array_address_nv = 0x8F28;
constexpr u32 element_array_address_nv = 0x8F29;
constexpr u32 vertex_attrib_array_length_nv = 0x8F2A;
constexpr u32 vertex_array_length_nv = 0x8F2B;
constexpr u32 normal_array_length_nv = 0x8F2C;
constexpr u32 color_array_length_nv = 0x8F2D;
constexpr u32 index_array_length_nv = 0x8F2E;
constexpr u32 texture_coord_array_length_nv = 0x8F2F;
constexpr u32 edge_flag_array_length_nv = 0x8F30;
constexpr u32 secondary_color_array_length_nv = 0x8F31;
constexpr u32 fog_coord_array_length_nv = 0x8F32;
constexpr u32 element_array_length_nv = 0x8F33;
constexpr u32 draw_indirect_unified_nv = 0x8F40;
constexpr u32 draw_indirect_address_nv = 0x8F41;
constexpr u32 draw_indirect_length_nv = 0x8F42;
STATICINLINE void buffer_address_range_nv(GLenum pname, u32 index, GLuint64EXT address, GLsizeiptr length)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBufferAddressRangeNV)
                Throw(undefined_behavior(
                    "unloaded function BufferAddressRangeNV"));
    }
    glBufferAddressRangeNV(pname, index, address, length);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void color_format_nv(i32 size, GLenum type, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColorFormatNV)
                Throw(undefined_behavior(
                    "unloaded function ColorFormatNV"));
    }
    glColorFormatNV(size, type, stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void edge_flag_format_nv(i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEdgeFlagFormatNV)
                Throw(undefined_behavior(
                    "unloaded function EdgeFlagFormatNV"));
    }
    glEdgeFlagFormatNV(stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void fog_coord_format_nv(GLenum type, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFogCoordFormatNV)
                Throw(undefined_behavior(
                    "unloaded function FogCoordFormatNV"));
    }
    glFogCoordFormatNV(type, stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLuint64EXT
>
requires (
    semantic::concepts::Span<span_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE void get_integerui64i_vnv(GLenum value, u32 index, span_GLuint64EXT result)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetIntegerui64i_vNV)
                Throw(undefined_behavior(
                    "unloaded function GetIntegerui64i_vNV"));
    }
    glGetIntegerui64i_vNV(value, index, reinterpret_cast<GLuint64EXT *>(result.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void index_format_nv(GLenum type, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIndexFormatNV)
                Throw(undefined_behavior(
                    "unloaded function IndexFormatNV"));
    }
    glIndexFormatNV(type, stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void normal_format_nv(GLenum type, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNormalFormatNV)
                Throw(undefined_behavior(
                    "unloaded function NormalFormatNV"));
    }
    glNormalFormatNV(type, stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void secondary_color_format_nv(i32 size, groups::color_pointer_type type, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSecondaryColorFormatNV)
                Throw(undefined_behavior(
                    "unloaded function SecondaryColorFormatNV"));
    }
    glSecondaryColorFormatNV(size, static_cast<GLenum>(type), stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_coord_format_nv(i32 size, GLenum type, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoordFormatNV)
                Throw(undefined_behavior(
                    "unloaded function TexCoordFormatNV"));
    }
    glTexCoordFormatNV(size, type, stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib_format_nv(u32 index, i32 size, groups::vertex_attrib_type type, bool normalized, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribFormatNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribFormatNV"));
    }
    glVertexAttribFormatNV(index, size, static_cast<GLenum>(type), normalized, stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib_i_format_nv(u32 index, i32 size, groups::vertex_attrib_int type, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribIFormatNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribIFormatNV"));
    }
    glVertexAttribIFormatNV(index, size, static_cast<GLenum>(type), stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_format_nv(i32 size, groups::vertex_pointer_type type, i32 stride)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexFormatNV)
                Throw(undefined_behavior(
                    "unloaded function VertexFormatNV"));
    }
    glVertexFormatNV(size, static_cast<GLenum>(type), stride);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_vertex_buffer_unified_memory
#endif // GL_NV_vertex_buffer_unified_memory
#ifdef GL_NV_vertex_program
namespace nv_vertex_program {
constexpr u32 vertex_program_nv = 0x8620;
constexpr u32 vertex_state_program_nv = 0x8621;
constexpr u32 attrib_array_size_nv = 0x8623;
constexpr u32 attrib_array_stride_nv = 0x8624;
constexpr u32 attrib_array_type_nv = 0x8625;
constexpr u32 current_attrib_nv = 0x8626;
constexpr u32 program_length_nv = 0x8627;
constexpr u32 program_string_nv = 0x8628;
constexpr u32 modelview_projection_nv = 0x8629;
constexpr u32 identity_nv = 0x862A;
constexpr u32 inverse_nv = 0x862B;
constexpr u32 transpose_nv = 0x862C;
constexpr u32 inverse_transpose_nv = 0x862D;
constexpr u32 max_track_matrix_stack_depth_nv = 0x862E;
constexpr u32 max_track_matrices_nv = 0x862F;
constexpr u32 matrix0_nv = 0x8630;
constexpr u32 matrix1_nv = 0x8631;
constexpr u32 matrix2_nv = 0x8632;
constexpr u32 matrix3_nv = 0x8633;
constexpr u32 matrix4_nv = 0x8634;
constexpr u32 matrix5_nv = 0x8635;
constexpr u32 matrix6_nv = 0x8636;
constexpr u32 matrix7_nv = 0x8637;
constexpr u32 current_matrix_stack_depth_nv = 0x8640;
constexpr u32 current_matrix_nv = 0x8641;
constexpr u32 vertex_program_point_size_nv = 0x8642;
constexpr u32 vertex_program_two_side_nv = 0x8643;
constexpr u32 program_parameter_nv = 0x8644;
constexpr u32 attrib_array_pointer_nv = 0x8645;
constexpr u32 program_target_nv = 0x8646;
constexpr u32 program_resident_nv = 0x8647;
constexpr u32 track_matrix_nv = 0x8648;
constexpr u32 track_matrix_transform_nv = 0x8649;
constexpr u32 vertex_program_binding_nv = 0x864A;
constexpr u32 program_error_position_nv = 0x864B;
constexpr u32 vertex_attrib_array0_nv = 0x8650;
constexpr u32 vertex_attrib_array1_nv = 0x8651;
constexpr u32 vertex_attrib_array2_nv = 0x8652;
constexpr u32 vertex_attrib_array3_nv = 0x8653;
constexpr u32 vertex_attrib_array4_nv = 0x8654;
constexpr u32 vertex_attrib_array5_nv = 0x8655;
constexpr u32 vertex_attrib_array6_nv = 0x8656;
constexpr u32 vertex_attrib_array7_nv = 0x8657;
constexpr u32 vertex_attrib_array8_nv = 0x8658;
constexpr u32 vertex_attrib_array9_nv = 0x8659;
constexpr u32 vertex_attrib_array10_nv = 0x865A;
constexpr u32 vertex_attrib_array11_nv = 0x865B;
constexpr u32 vertex_attrib_array12_nv = 0x865C;
constexpr u32 vertex_attrib_array13_nv = 0x865D;
constexpr u32 vertex_attrib_array14_nv = 0x865E;
constexpr u32 vertex_attrib_array15_nv = 0x865F;
constexpr u32 map1_vertex_attrib0_4_nv = 0x8660;
constexpr u32 map1_vertex_attrib1_4_nv = 0x8661;
constexpr u32 map1_vertex_attrib2_4_nv = 0x8662;
constexpr u32 map1_vertex_attrib3_4_nv = 0x8663;
constexpr u32 map1_vertex_attrib4_4_nv = 0x8664;
constexpr u32 map1_vertex_attrib5_4_nv = 0x8665;
constexpr u32 map1_vertex_attrib6_4_nv = 0x8666;
constexpr u32 map1_vertex_attrib7_4_nv = 0x8667;
constexpr u32 map1_vertex_attrib8_4_nv = 0x8668;
constexpr u32 map1_vertex_attrib9_4_nv = 0x8669;
constexpr u32 map1_vertex_attrib10_4_nv = 0x866A;
constexpr u32 map1_vertex_attrib11_4_nv = 0x866B;
constexpr u32 map1_vertex_attrib12_4_nv = 0x866C;
constexpr u32 map1_vertex_attrib13_4_nv = 0x866D;
constexpr u32 map1_vertex_attrib14_4_nv = 0x866E;
constexpr u32 map1_vertex_attrib15_4_nv = 0x866F;
constexpr u32 map2_vertex_attrib0_4_nv = 0x8670;
constexpr u32 map2_vertex_attrib1_4_nv = 0x8671;
constexpr u32 map2_vertex_attrib2_4_nv = 0x8672;
constexpr u32 map2_vertex_attrib3_4_nv = 0x8673;
constexpr u32 map2_vertex_attrib4_4_nv = 0x8674;
constexpr u32 map2_vertex_attrib5_4_nv = 0x8675;
constexpr u32 map2_vertex_attrib6_4_nv = 0x8676;
constexpr u32 map2_vertex_attrib7_4_nv = 0x8677;
constexpr u32 map2_vertex_attrib8_4_nv = 0x8678;
constexpr u32 map2_vertex_attrib9_4_nv = 0x8679;
constexpr u32 map2_vertex_attrib10_4_nv = 0x867A;
constexpr u32 map2_vertex_attrib11_4_nv = 0x867B;
constexpr u32 map2_vertex_attrib12_4_nv = 0x867C;
constexpr u32 map2_vertex_attrib13_4_nv = 0x867D;
constexpr u32 map2_vertex_attrib14_4_nv = 0x867E;
constexpr u32 map2_vertex_attrib15_4_nv = 0x867F;
template<
    class span_bool,
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32> &&
    semantic::concepts::Span<span_bool> &&
    std::is_same_v<std::decay_t<typename span_bool::value_type>, bool>)
STATICINLINE GLboolean are_programs_resident_nv(span_const_u32 const& programs, span_bool residences)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glAreProgramsResidentNV)
                Throw(undefined_behavior(
                    "unloaded function AreProgramsResidentNV"));
    }
    auto out = glAreProgramsResidentNV(programs.size(), reinterpret_cast<const GLuint *>(programs.data()), reinterpret_cast<GLboolean *>(residences.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE void bind_program_nv(groups::vertex_attrib_enum_nv target, u32 id)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindProgramNV)
                Throw(undefined_behavior(
                    "unloaded function BindProgramNV"));
    }
    glBindProgramNV(static_cast<GLenum>(target), id);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_programs_nv(span_const_u32 const& programs)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteProgramsNV)
                Throw(undefined_behavior(
                    "unloaded function DeleteProgramsNV"));
    }
    glDeleteProgramsNV(programs.size(), reinterpret_cast<const GLuint *>(programs.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void execute_program_nv(groups::vertex_attrib_enum_nv target, u32 id, span_const_f32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glExecuteProgramNV)
                Throw(undefined_behavior(
                    "unloaded function ExecuteProgramNV"));
    }
    glExecuteProgramNV(static_cast<GLenum>(target), id, reinterpret_cast<const GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void gen_programs_nv(span_u32 programs)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenProgramsNV)
                Throw(undefined_behavior(
                    "unloaded function GenProgramsNV"));
    }
    glGenProgramsNV(programs.size(), reinterpret_cast<GLuint *>(programs.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f64
>
requires (
    semantic::concepts::Span<span_f64> &&
    std::is_same_v<std::decay_t<typename span_f64::value_type>, f64>)
STATICINLINE void get_program_parameterdv_nv(groups::vertex_attrib_enum_nv target, u32 index, groups::vertex_attrib_enum_nv pname, span_f64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramParameterdvNV)
                Throw(undefined_behavior(
                    "unloaded function GetProgramParameterdvNV"));
    }
    glGetProgramParameterdvNV(static_cast<GLenum>(target), index, static_cast<GLenum>(pname), reinterpret_cast<GLdouble *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_program_parameterfv_nv(groups::vertex_attrib_enum_nv target, u32 index, groups::vertex_attrib_enum_nv pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramParameterfvNV)
                Throw(undefined_behavior(
                    "unloaded function GetProgramParameterfvNV"));
    }
    glGetProgramParameterfvNV(static_cast<GLenum>(target), index, static_cast<GLenum>(pname), reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u8
>
requires (
    semantic::concepts::Span<span_u8> &&
    std::is_same_v<std::decay_t<typename span_u8::value_type>, u8>)
STATICINLINE void get_program_string_nv(u32 id, groups::vertex_attrib_enum_nv pname, span_u8 program)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramStringNV)
                Throw(undefined_behavior(
                    "unloaded function GetProgramStringNV"));
    }
    glGetProgramStringNV(id, static_cast<GLenum>(pname), reinterpret_cast<GLubyte *>(program.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_programiv_nv(u32 id, groups::vertex_attrib_enum_nv pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramivNV)
                Throw(undefined_behavior(
                    "unloaded function GetProgramivNV"));
    }
    glGetProgramivNV(id, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void get_track_matrixiv_nv(groups::vertex_attrib_enum_nv target, u32 address, groups::vertex_attrib_enum_nv pname, i32& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTrackMatrixivNV)
                Throw(undefined_behavior(
                    "unloaded function GetTrackMatrixivNV"));
    }
    glGetTrackMatrixivNV(static_cast<GLenum>(target), address, static_cast<GLenum>(pname), &params);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_vertex_attrib_pointerv_nv(u32 index, groups::vertex_attrib_enum_nv pname, span_byte pointer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribPointervNV)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribPointervNV"));
    }
    glGetVertexAttribPointervNV(index, static_cast<GLenum>(pname), reinterpret_cast<void **>(pointer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void get_vertex_attribdv_nv(u32 index, groups::vertex_attrib_enum_nv pname, f64& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribdvNV)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribdvNV"));
    }
    glGetVertexAttribdvNV(index, static_cast<GLenum>(pname), &params);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void get_vertex_attribfv_nv(u32 index, groups::vertex_attrib_enum_nv pname, f32& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribfvNV)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribfvNV"));
    }
    glGetVertexAttribfvNV(index, static_cast<GLenum>(pname), &params);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void get_vertex_attribiv_nv(u32 index, groups::vertex_attrib_enum_nv pname, i32& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribivNV)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribivNV"));
    }
    glGetVertexAttribivNV(index, static_cast<GLenum>(pname), &params);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_program_nv(u32 id)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsProgramNV)
                Throw(undefined_behavior(
                    "unloaded function IsProgramNV"));
    }
    auto out = glIsProgramNV(id);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_u8
>
requires (
    semantic::concepts::Span<span_const_u8> &&
    std::is_same_v<std::decay_t<typename span_const_u8::value_type>, u8>)
STATICINLINE void load_program_nv(groups::vertex_attrib_enum_nv target, u32 id, span_const_u8 const& program)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glLoadProgramNV)
                Throw(undefined_behavior(
                    "unloaded function LoadProgramNV"));
    }
    glLoadProgramNV(static_cast<GLenum>(target), id, program.size(), reinterpret_cast<const GLubyte *>(program.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f64
>
requires (
    semantic::concepts::Vector<vec_4_f64, f64, 4>)
STATICINLINE void program_parameter4d_nv(groups::vertex_attrib_enum_nv target, u32 index, vec_4_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramParameter4dNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramParameter4dNV"));
    }
    glProgramParameter4dNV(static_cast<GLenum>(target), index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f64
>
requires (
    semantic::concepts::Span<span_const_vec_4_f64> &&
    semantic::concepts::Vector<typename span_const_vec_4_f64::value_type, f64, 4>)
STATICINLINE void program_parameter4dv_nv(groups::vertex_attrib_enum_nv target, u32 index, span_const_vec_4_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramParameter4dvNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramParameter4dvNV"));
    }
    glProgramParameter4dvNV(static_cast<GLenum>(target), index, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f32
>
requires (
    semantic::concepts::Vector<vec_4_f32, f32, 4>)
STATICINLINE void program_parameter4f_nv(groups::vertex_attrib_enum_nv target, u32 index, vec_4_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramParameter4fNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramParameter4fNV"));
    }
    glProgramParameter4fNV(static_cast<GLenum>(target), index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f32
>
requires (
    semantic::concepts::Span<span_const_vec_4_f32> &&
    semantic::concepts::Vector<typename span_const_vec_4_f32::value_type, f32, 4>)
STATICINLINE void program_parameter4fv_nv(groups::vertex_attrib_enum_nv target, u32 index, span_const_vec_4_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramParameter4fvNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramParameter4fvNV"));
    }
    glProgramParameter4fvNV(static_cast<GLenum>(target), index, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f64
>
requires (
    semantic::concepts::Span<span_const_vec_4_f64> &&
    semantic::concepts::Vector<typename span_const_vec_4_f64::value_type, f64, 4>)
STATICINLINE void program_parameters4dv_nv(groups::vertex_attrib_enum_nv target, u32 index, i32 count, span_const_vec_4_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramParameters4dvNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramParameters4dvNV"));
    }
    glProgramParameters4dvNV(static_cast<GLenum>(target), index, count, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f32
>
requires (
    semantic::concepts::Span<span_const_vec_4_f32> &&
    semantic::concepts::Vector<typename span_const_vec_4_f32::value_type, f32, 4>)
STATICINLINE void program_parameters4fv_nv(groups::vertex_attrib_enum_nv target, u32 index, i32 count, span_const_vec_4_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramParameters4fvNV)
                Throw(undefined_behavior(
                    "unloaded function ProgramParameters4fvNV"));
    }
    glProgramParameters4fvNV(static_cast<GLenum>(target), index, count, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void request_resident_programs_nv(span_const_u32 const& programs)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glRequestResidentProgramsNV)
                Throw(undefined_behavior(
                    "unloaded function RequestResidentProgramsNV"));
    }
    glRequestResidentProgramsNV(programs.size(), reinterpret_cast<const GLuint *>(programs.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void track_matrix_nv(groups::vertex_attrib_enum_nv target, u32 address, groups::vertex_attrib_enum_nv matrix, groups::vertex_attrib_enum_nv transform)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTrackMatrixNV)
                Throw(undefined_behavior(
                    "unloaded function TrackMatrixNV"));
    }
    glTrackMatrixNV(static_cast<GLenum>(target), address, static_cast<GLenum>(matrix), static_cast<GLenum>(transform));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib1d_nv(u32 index, f64 x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1dNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1dNV"));
    }
    glVertexAttrib1dNV(index, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f64
>
requires (
    semantic::concepts::Span<span_const_f64> &&
    std::is_same_v<std::decay_t<typename span_const_f64::value_type>, f64>)
STATICINLINE void vertex_attrib1dv_nv(u32 index, span_const_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1dvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1dvNV"));
    }
    glVertexAttrib1dvNV(index, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib1f_nv(u32 index, f32 x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1fNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1fNV"));
    }
    glVertexAttrib1fNV(index, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void vertex_attrib1fv_nv(u32 index, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1fvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1fvNV"));
    }
    glVertexAttrib1fvNV(index, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib1s_nv(u32 index, i16 x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1sNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1sNV"));
    }
    glVertexAttrib1sNV(index, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i16
>
requires (
    semantic::concepts::Span<span_const_i16> &&
    std::is_same_v<std::decay_t<typename span_const_i16::value_type>, i16>)
STATICINLINE void vertex_attrib1sv_nv(u32 index, span_const_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib1svNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib1svNV"));
    }
    glVertexAttrib1svNV(index, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_f64
>
requires (
    semantic::concepts::Vector<vec_2_f64, f64, 2>)
STATICINLINE void vertex_attrib2d_nv(u32 index, vec_2_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2dNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2dNV"));
    }
    glVertexAttrib2dNV(index, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_f64
>
requires (
    semantic::concepts::Span<span_const_vec_2_f64> &&
    semantic::concepts::Vector<typename span_const_vec_2_f64::value_type, f64, 2>)
STATICINLINE void vertex_attrib2dv_nv(u32 index, span_const_vec_2_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2dvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2dvNV"));
    }
    glVertexAttrib2dvNV(index, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_f32
>
requires (
    semantic::concepts::Vector<vec_2_f32, f32, 2>)
STATICINLINE void vertex_attrib2f_nv(u32 index, vec_2_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2fNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2fNV"));
    }
    glVertexAttrib2fNV(index, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_f32
>
requires (
    semantic::concepts::Span<span_const_vec_2_f32> &&
    semantic::concepts::Vector<typename span_const_vec_2_f32::value_type, f32, 2>)
STATICINLINE void vertex_attrib2fv_nv(u32 index, span_const_vec_2_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2fvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2fvNV"));
    }
    glVertexAttrib2fvNV(index, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i16
>
requires (
    semantic::concepts::Vector<vec_2_i16, i16, 2>)
STATICINLINE void vertex_attrib2s_nv(u32 index, vec_2_i16 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2sNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2sNV"));
    }
    glVertexAttrib2sNV(index, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_i16
>
requires (
    semantic::concepts::Span<span_const_vec_2_i16> &&
    semantic::concepts::Vector<typename span_const_vec_2_i16::value_type, i16, 2>)
STATICINLINE void vertex_attrib2sv_nv(u32 index, span_const_vec_2_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib2svNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib2svNV"));
    }
    glVertexAttrib2svNV(index, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f64
>
requires (
    semantic::concepts::Vector<vec_3_f64, f64, 3>)
STATICINLINE void vertex_attrib3d_nv(u32 index, vec_3_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3dNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3dNV"));
    }
    glVertexAttrib3dNV(index, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_f64
>
requires (
    semantic::concepts::Span<span_const_vec_3_f64> &&
    semantic::concepts::Vector<typename span_const_vec_3_f64::value_type, f64, 3>)
STATICINLINE void vertex_attrib3dv_nv(u32 index, span_const_vec_3_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3dvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3dvNV"));
    }
    glVertexAttrib3dvNV(index, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_f32
>
requires (
    semantic::concepts::Vector<vec_3_f32, f32, 3>)
STATICINLINE void vertex_attrib3f_nv(u32 index, vec_3_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3fNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3fNV"));
    }
    glVertexAttrib3fNV(index, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_f32
>
requires (
    semantic::concepts::Span<span_const_vec_3_f32> &&
    semantic::concepts::Vector<typename span_const_vec_3_f32::value_type, f32, 3>)
STATICINLINE void vertex_attrib3fv_nv(u32 index, span_const_vec_3_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3fvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3fvNV"));
    }
    glVertexAttrib3fvNV(index, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i16
>
requires (
    semantic::concepts::Vector<vec_3_i16, i16, 3>)
STATICINLINE void vertex_attrib3s_nv(u32 index, vec_3_i16 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3sNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3sNV"));
    }
    glVertexAttrib3sNV(index, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_i16
>
requires (
    semantic::concepts::Span<span_const_vec_3_i16> &&
    semantic::concepts::Vector<typename span_const_vec_3_i16::value_type, i16, 3>)
STATICINLINE void vertex_attrib3sv_nv(u32 index, span_const_vec_3_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib3svNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib3svNV"));
    }
    glVertexAttrib3svNV(index, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f64
>
requires (
    semantic::concepts::Vector<vec_4_f64, f64, 4>)
STATICINLINE void vertex_attrib4d_nv(u32 index, vec_4_f64 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4dNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4dNV"));
    }
    glVertexAttrib4dNV(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f64
>
requires (
    semantic::concepts::Span<span_const_vec_4_f64> &&
    semantic::concepts::Vector<typename span_const_vec_4_f64::value_type, f64, 4>)
STATICINLINE void vertex_attrib4dv_nv(u32 index, span_const_vec_4_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4dvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4dvNV"));
    }
    glVertexAttrib4dvNV(index, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_f32
>
requires (
    semantic::concepts::Vector<vec_4_f32, f32, 4>)
STATICINLINE void vertex_attrib4f_nv(u32 index, vec_4_f32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4fNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4fNV"));
    }
    glVertexAttrib4fNV(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f32
>
requires (
    semantic::concepts::Span<span_const_vec_4_f32> &&
    semantic::concepts::Vector<typename span_const_vec_4_f32::value_type, f32, 4>)
STATICINLINE void vertex_attrib4fv_nv(u32 index, span_const_vec_4_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4fvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4fvNV"));
    }
    glVertexAttrib4fvNV(index, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_i16
>
requires (
    semantic::concepts::Vector<vec_4_i16, i16, 4>)
STATICINLINE void vertex_attrib4s_nv(u32 index, vec_4_i16 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4sNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4sNV"));
    }
    glVertexAttrib4sNV(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_i16
>
requires (
    semantic::concepts::Span<span_const_vec_4_i16> &&
    semantic::concepts::Vector<typename span_const_vec_4_i16::value_type, i16, 4>)
STATICINLINE void vertex_attrib4sv_nv(u32 index, span_const_vec_4_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4svNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4svNV"));
    }
    glVertexAttrib4svNV(index, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_u8
>
requires (
    semantic::concepts::Vector<vec_4_u8, u8, 4>)
STATICINLINE void vertex_attrib4ub_nv(u32 index, vec_4_u8 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4ubNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4ubNV"));
    }
    glVertexAttrib4ubNV(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u8
>
requires (
    semantic::concepts::Span<span_const_u8> &&
    std::is_same_v<std::decay_t<typename span_const_u8::value_type>, u8>)
STATICINLINE void vertex_attrib4ubv_nv(u32 index, span_const_u8 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttrib4ubvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttrib4ubvNV"));
    }
    glVertexAttrib4ubvNV(index, reinterpret_cast<const GLubyte *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void vertex_attrib_pointer_nv(u32 index, i32 fsize, groups::vertex_attrib_enum_nv type, i32 stride, span_const_byte const& pointer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribPointerNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribPointerNV"));
    }
    glVertexAttribPointerNV(index, fsize, static_cast<GLenum>(type), stride, reinterpret_cast<const void *>(pointer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f64
>
requires (
    semantic::concepts::Span<span_const_f64> &&
    std::is_same_v<std::decay_t<typename span_const_f64::value_type>, f64>)
STATICINLINE void vertex_attribs1dv_nv(u32 index, span_const_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribs1dvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribs1dvNV"));
    }
    glVertexAttribs1dvNV(index, v.size(), reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void vertex_attribs1fv_nv(u32 index, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribs1fvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribs1fvNV"));
    }
    glVertexAttribs1fvNV(index, v.size(), reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i16
>
requires (
    semantic::concepts::Span<span_const_i16> &&
    std::is_same_v<std::decay_t<typename span_const_i16::value_type>, i16>)
STATICINLINE void vertex_attribs1sv_nv(u32 index, span_const_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribs1svNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribs1svNV"));
    }
    glVertexAttribs1svNV(index, v.size(), reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_f64
>
requires (
    semantic::concepts::Span<span_const_vec_2_f64> &&
    semantic::concepts::Vector<typename span_const_vec_2_f64::value_type, f64, 2>)
STATICINLINE void vertex_attribs2dv_nv(u32 index, i32 count, span_const_vec_2_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribs2dvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribs2dvNV"));
    }
    glVertexAttribs2dvNV(index, count, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_f32
>
requires (
    semantic::concepts::Span<span_const_vec_2_f32> &&
    semantic::concepts::Vector<typename span_const_vec_2_f32::value_type, f32, 2>)
STATICINLINE void vertex_attribs2fv_nv(u32 index, i32 count, span_const_vec_2_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribs2fvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribs2fvNV"));
    }
    glVertexAttribs2fvNV(index, count, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_2_i16
>
requires (
    semantic::concepts::Span<span_const_vec_2_i16> &&
    semantic::concepts::Vector<typename span_const_vec_2_i16::value_type, i16, 2>)
STATICINLINE void vertex_attribs2sv_nv(u32 index, i32 count, span_const_vec_2_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribs2svNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribs2svNV"));
    }
    glVertexAttribs2svNV(index, count, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_f64
>
requires (
    semantic::concepts::Span<span_const_vec_3_f64> &&
    semantic::concepts::Vector<typename span_const_vec_3_f64::value_type, f64, 3>)
STATICINLINE void vertex_attribs3dv_nv(u32 index, i32 count, span_const_vec_3_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribs3dvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribs3dvNV"));
    }
    glVertexAttribs3dvNV(index, count, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_f32
>
requires (
    semantic::concepts::Span<span_const_vec_3_f32> &&
    semantic::concepts::Vector<typename span_const_vec_3_f32::value_type, f32, 3>)
STATICINLINE void vertex_attribs3fv_nv(u32 index, i32 count, span_const_vec_3_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribs3fvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribs3fvNV"));
    }
    glVertexAttribs3fvNV(index, count, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_3_i16
>
requires (
    semantic::concepts::Span<span_const_vec_3_i16> &&
    semantic::concepts::Vector<typename span_const_vec_3_i16::value_type, i16, 3>)
STATICINLINE void vertex_attribs3sv_nv(u32 index, i32 count, span_const_vec_3_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribs3svNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribs3svNV"));
    }
    glVertexAttribs3svNV(index, count, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f64
>
requires (
    semantic::concepts::Span<span_const_vec_4_f64> &&
    semantic::concepts::Vector<typename span_const_vec_4_f64::value_type, f64, 4>)
STATICINLINE void vertex_attribs4dv_nv(u32 index, i32 count, span_const_vec_4_f64 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribs4dvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribs4dvNV"));
    }
    glVertexAttribs4dvNV(index, count, reinterpret_cast<const GLdouble *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_f32
>
requires (
    semantic::concepts::Span<span_const_vec_4_f32> &&
    semantic::concepts::Vector<typename span_const_vec_4_f32::value_type, f32, 4>)
STATICINLINE void vertex_attribs4fv_nv(u32 index, i32 count, span_const_vec_4_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribs4fvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribs4fvNV"));
    }
    glVertexAttribs4fvNV(index, count, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_vec_4_i16
>
requires (
    semantic::concepts::Span<span_const_vec_4_i16> &&
    semantic::concepts::Vector<typename span_const_vec_4_i16::value_type, i16, 4>)
STATICINLINE void vertex_attribs4sv_nv(u32 index, i32 count, span_const_vec_4_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribs4svNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribs4svNV"));
    }
    glVertexAttribs4svNV(index, count, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u8
>
requires (
    semantic::concepts::Span<span_const_u8> &&
    std::is_same_v<std::decay_t<typename span_const_u8::value_type>, u8>)
STATICINLINE void vertex_attribs4ubv_nv(u32 index, i32 count, span_const_u8 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribs4ubvNV)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribs4ubvNV"));
    }
    glVertexAttribs4ubvNV(index, count, reinterpret_cast<const GLubyte *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_vertex_program
#endif // GL_NV_vertex_program
#ifdef GL_NV_vertex_program1_1
namespace nv_vertex_program1_1 {
} // nv_vertex_program1_1
#endif // GL_NV_vertex_program1_1
#ifdef GL_NV_vertex_program2
namespace nv_vertex_program2 {
} // nv_vertex_program2
#endif // GL_NV_vertex_program2
#ifdef GL_NV_vertex_program2_option
namespace nv_vertex_program2_option {
constexpr u32 max_program_exec_instructions_nv = 0x88F4;
constexpr u32 max_program_call_depth_nv = 0x88F5;
} // nv_vertex_program2_option
#endif // GL_NV_vertex_program2_option
#ifdef GL_NV_vertex_program3
namespace nv_vertex_program3 {
constexpr u32 max_vertex_texture_image_units_arb = 0x8B4C;
} // nv_vertex_program3
#endif // GL_NV_vertex_program3
#ifdef GL_NV_vertex_program4
namespace nv_vertex_program4 {
constexpr u32 vertex_attrib_array_integer_nv = 0x88FD;
STATICINLINE void get_vertex_attrib_iiv_ext(u32 index, groups::vertex_attrib_enum pname, i32& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribIivEXT)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribIivEXT"));
    }
    glGetVertexAttribIivEXT(index, static_cast<GLenum>(pname), &params);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void get_vertex_attrib_iuiv_ext(u32 index, groups::vertex_attrib_enum pname, u32& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVertexAttribIuivEXT)
                Throw(undefined_behavior(
                    "unloaded function GetVertexAttribIuivEXT"));
    }
    glGetVertexAttribIuivEXT(index, static_cast<GLenum>(pname), &params);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib_i1i_ext(u32 index, i32 x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI1iEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI1iEXT"));
    }
    glVertexAttribI1iEXT(index, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void vertex_attrib_i1iv_ext(u32 index, span_const_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI1ivEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI1ivEXT"));
    }
    glVertexAttribI1ivEXT(index, reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex_attrib_i1ui_ext(u32 index, u32 x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI1uiEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI1uiEXT"));
    }
    glVertexAttribI1uiEXT(index, x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void vertex_attrib_i1uiv_ext(u32 index, span_const_u32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI1uivEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI1uivEXT"));
    }
    glVertexAttribI1uivEXT(index, reinterpret_cast<const GLuint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void vertex_attrib_i2i_ext(u32 index, vec_2_i32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI2iEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI2iEXT"));
    }
    glVertexAttribI2iEXT(index, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void vertex_attrib_i2iv_ext(u32 index, span_const_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI2ivEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI2ivEXT"));
    }
    glVertexAttribI2ivEXT(index, reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_u32
>
requires (
    semantic::concepts::Vector<vec_2_u32, u32, 2>)
STATICINLINE void vertex_attrib_i2ui_ext(u32 index, vec_2_u32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI2uiEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI2uiEXT"));
    }
    glVertexAttribI2uiEXT(index, x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void vertex_attrib_i2uiv_ext(u32 index, span_const_u32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI2uivEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI2uivEXT"));
    }
    glVertexAttribI2uivEXT(index, reinterpret_cast<const GLuint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void vertex_attrib_i3i_ext(u32 index, vec_3_i32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI3iEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI3iEXT"));
    }
    glVertexAttribI3iEXT(index, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void vertex_attrib_i3iv_ext(u32 index, span_const_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI3ivEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI3ivEXT"));
    }
    glVertexAttribI3ivEXT(index, reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_u32
>
requires (
    semantic::concepts::Vector<vec_3_u32, u32, 3>)
STATICINLINE void vertex_attrib_i3ui_ext(u32 index, vec_3_u32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI3uiEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI3uiEXT"));
    }
    glVertexAttribI3uiEXT(index, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void vertex_attrib_i3uiv_ext(u32 index, span_const_u32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI3uivEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI3uivEXT"));
    }
    glVertexAttribI3uivEXT(index, reinterpret_cast<const GLuint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i8
>
requires (
    semantic::concepts::Span<span_const_i8> &&
    std::is_same_v<std::decay_t<typename span_const_i8::value_type>, i8>)
STATICINLINE void vertex_attrib_i4bv_ext(u32 index, span_const_i8 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI4bvEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI4bvEXT"));
    }
    glVertexAttribI4bvEXT(index, reinterpret_cast<const GLbyte *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_i32
>
requires (
    semantic::concepts::Vector<vec_4_i32, i32, 4>)
STATICINLINE void vertex_attrib_i4i_ext(u32 index, vec_4_i32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI4iEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI4iEXT"));
    }
    glVertexAttribI4iEXT(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void vertex_attrib_i4iv_ext(u32 index, span_const_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI4ivEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI4ivEXT"));
    }
    glVertexAttribI4ivEXT(index, reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i16
>
requires (
    semantic::concepts::Span<span_const_i16> &&
    std::is_same_v<std::decay_t<typename span_const_i16::value_type>, i16>)
STATICINLINE void vertex_attrib_i4sv_ext(u32 index, span_const_i16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI4svEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI4svEXT"));
    }
    glVertexAttribI4svEXT(index, reinterpret_cast<const GLshort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u8
>
requires (
    semantic::concepts::Span<span_const_u8> &&
    std::is_same_v<std::decay_t<typename span_const_u8::value_type>, u8>)
STATICINLINE void vertex_attrib_i4ubv_ext(u32 index, span_const_u8 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI4ubvEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI4ubvEXT"));
    }
    glVertexAttribI4ubvEXT(index, reinterpret_cast<const GLubyte *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_u32
>
requires (
    semantic::concepts::Vector<vec_4_u32, u32, 4>)
STATICINLINE void vertex_attrib_i4ui_ext(u32 index, vec_4_u32 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI4uiEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI4uiEXT"));
    }
    glVertexAttribI4uiEXT(index, x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void vertex_attrib_i4uiv_ext(u32 index, span_const_u32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI4uivEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI4uivEXT"));
    }
    glVertexAttribI4uivEXT(index, reinterpret_cast<const GLuint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u16
>
requires (
    semantic::concepts::Span<span_const_u16> &&
    std::is_same_v<std::decay_t<typename span_const_u16::value_type>, u16>)
STATICINLINE void vertex_attrib_i4usv_ext(u32 index, span_const_u16 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribI4usvEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribI4usvEXT"));
    }
    glVertexAttribI4usvEXT(index, reinterpret_cast<const GLushort *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void vertex_attrib_i_pointer_ext(u32 index, i32 size, groups::vertex_attrib_int type, i32 stride, span_const_byte const& pointer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertexAttribIPointerEXT)
                Throw(undefined_behavior(
                    "unloaded function VertexAttribIPointerEXT"));
    }
    glVertexAttribIPointerEXT(index, size, static_cast<GLenum>(type), stride, reinterpret_cast<const void *>(pointer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_vertex_program4
#endif // GL_NV_vertex_program4
#ifdef GL_NV_video_capture
namespace nv_video_capture {
constexpr u32 video_buffer_nv = 0x9020;
constexpr u32 video_buffer_binding_nv = 0x9021;
constexpr u32 field_upper_nv = 0x9022;
constexpr u32 field_lower_nv = 0x9023;
constexpr u32 num_video_capture_streams_nv = 0x9024;
constexpr u32 next_video_capture_buffer_status_nv = 0x9025;
constexpr u32 video_capture_to_422_supported_nv = 0x9026;
constexpr u32 last_video_capture_status_nv = 0x9027;
constexpr u32 video_buffer_pitch_nv = 0x9028;
constexpr u32 video_color_conversion_matrix_nv = 0x9029;
constexpr u32 video_color_conversion_max_nv = 0x902A;
constexpr u32 video_color_conversion_min_nv = 0x902B;
constexpr u32 video_color_conversion_offset_nv = 0x902C;
constexpr u32 video_buffer_internal_format_nv = 0x902D;
constexpr u32 partial_success_nv = 0x902E;
constexpr u32 success_nv = 0x902F;
constexpr u32 failure_nv = 0x9030;
constexpr u32 ycbycr8_422_nv = 0x9031;
constexpr u32 ycbaycr8a_4224_nv = 0x9032;
constexpr u32 z6y10z6cb10z6y10z6cr10_422_nv = 0x9033;
constexpr u32 z6y10z6cb10z6a10z6y10z6cr10z6a10_4224_nv = 0x9034;
constexpr u32 z4y12z4cb12z4y12z4cr12_422_nv = 0x9035;
constexpr u32 z4y12z4cb12z4a12z4y12z4cr12z4a12_4224_nv = 0x9036;
constexpr u32 z4y12z4cb12z4cr12_444_nv = 0x9037;
constexpr u32 video_capture_frame_width_nv = 0x9038;
constexpr u32 video_capture_frame_height_nv = 0x9039;
constexpr u32 video_capture_field_upper_height_nv = 0x903A;
constexpr u32 video_capture_field_lower_height_nv = 0x903B;
constexpr u32 video_capture_surface_origin_nv = 0x903C;
STATICINLINE void begin_video_capture_nv(u32 video_capture_slot)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBeginVideoCaptureNV)
                Throw(undefined_behavior(
                    "unloaded function BeginVideoCaptureNV"));
    }
    glBeginVideoCaptureNV(video_capture_slot);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void bind_video_capture_stream_buffer_nv(u32 video_capture_slot, u32 stream, GLenum frame_region, GLintptrARB offset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindVideoCaptureStreamBufferNV)
                Throw(undefined_behavior(
                    "unloaded function BindVideoCaptureStreamBufferNV"));
    }
    glBindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void bind_video_capture_stream_texture_nv(u32 video_capture_slot, u32 stream, GLenum frame_region, GLenum target, u32 texture)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindVideoCaptureStreamTextureNV)
                Throw(undefined_behavior(
                    "unloaded function BindVideoCaptureStreamTextureNV"));
        glIsTexture(texture);
    }
    glBindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void end_video_capture_nv(u32 video_capture_slot)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEndVideoCaptureNV)
                Throw(undefined_behavior(
                    "unloaded function EndVideoCaptureNV"));
    }
    glEndVideoCaptureNV(video_capture_slot);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f64
>
requires (
    semantic::concepts::Span<span_f64> &&
    std::is_same_v<std::decay_t<typename span_f64::value_type>, f64>)
STATICINLINE void get_video_capture_streamdv_nv(u32 video_capture_slot, u32 stream, GLenum pname, span_f64 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVideoCaptureStreamdvNV)
                Throw(undefined_behavior(
                    "unloaded function GetVideoCaptureStreamdvNV"));
    }
    glGetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, reinterpret_cast<GLdouble *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_video_capture_streamfv_nv(u32 video_capture_slot, u32 stream, GLenum pname, span_f32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVideoCaptureStreamfvNV)
                Throw(undefined_behavior(
                    "unloaded function GetVideoCaptureStreamfvNV"));
    }
    glGetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, reinterpret_cast<GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_video_capture_streamiv_nv(u32 video_capture_slot, u32 stream, GLenum pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVideoCaptureStreamivNV)
                Throw(undefined_behavior(
                    "unloaded function GetVideoCaptureStreamivNV"));
    }
    glGetVideoCaptureStreamivNV(video_capture_slot, stream, pname, reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_video_captureiv_nv(u32 video_capture_slot, GLenum pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetVideoCaptureivNV)
                Throw(undefined_behavior(
                    "unloaded function GetVideoCaptureivNV"));
    }
    glGetVideoCaptureivNV(video_capture_slot, pname, reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLuint64EXT,
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32> &&
    semantic::concepts::Span<span_GLuint64EXT> &&
    std::is_same_v<std::decay_t<typename span_GLuint64EXT::value_type>, GLuint64EXT>)
STATICINLINE GLenum video_capture_nv(u32 video_capture_slot, span_u32 sequence_num, span_GLuint64EXT capture_time)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVideoCaptureNV)
                Throw(undefined_behavior(
                    "unloaded function VideoCaptureNV"));
    }
    auto out = glVideoCaptureNV(video_capture_slot, reinterpret_cast<GLuint *>(sequence_num.data()), reinterpret_cast<GLuint64EXT *>(capture_time.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_f64
>
requires (
    semantic::concepts::Span<span_const_f64> &&
    std::is_same_v<std::decay_t<typename span_const_f64::value_type>, f64>)
STATICINLINE void video_capture_stream_parameterdv_nv(u32 video_capture_slot, u32 stream, GLenum pname, span_const_f64 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVideoCaptureStreamParameterdvNV)
                Throw(undefined_behavior(
                    "unloaded function VideoCaptureStreamParameterdvNV"));
    }
    glVideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, reinterpret_cast<const GLdouble *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void video_capture_stream_parameterfv_nv(u32 video_capture_slot, u32 stream, GLenum pname, span_const_f32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVideoCaptureStreamParameterfvNV)
                Throw(undefined_behavior(
                    "unloaded function VideoCaptureStreamParameterfvNV"));
    }
    glVideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, reinterpret_cast<const GLfloat *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void video_capture_stream_parameteriv_nv(u32 video_capture_slot, u32 stream, GLenum pname, span_const_i32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVideoCaptureStreamParameterivNV)
                Throw(undefined_behavior(
                    "unloaded function VideoCaptureStreamParameterivNV"));
    }
    glVideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, reinterpret_cast<const GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_video_capture
#endif // GL_NV_video_capture
#ifdef GL_NV_viewport_array
namespace nv_viewport_array {
constexpr u32 depth_range = 0x0B70;
constexpr u32 viewport = 0x0BA2;
constexpr u32 scissor_box = 0x0C10;
constexpr u32 scissor_test = 0x0C11;
constexpr u32 max_viewports_nv = 0x825B;
constexpr u32 viewport_subpixel_bits_nv = 0x825C;
constexpr u32 viewport_bounds_range_nv = 0x825D;
constexpr u32 viewport_index_provoking_vertex_nv = 0x825F;
template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void depth_range_arrayfv_nv(u32 first, i32 count, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDepthRangeArrayfvNV)
                Throw(undefined_behavior(
                    "unloaded function DepthRangeArrayfvNV"));
    }
    glDepthRangeArrayfvNV(first, count, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void depth_range_indexedf_nv(u32 index, f32 n, f32 f)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDepthRangeIndexedfNV)
                Throw(undefined_behavior(
                    "unloaded function DepthRangeIndexedfNV"));
    }
    glDepthRangeIndexedfNV(index, n, f);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void disablei_nv(groups::enable_cap target, u32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDisableiNV)
                Throw(undefined_behavior(
                    "unloaded function DisableiNV"));
    }
    glDisableiNV(static_cast<GLenum>(target), index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void enablei_nv(groups::enable_cap target, u32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEnableiNV)
                Throw(undefined_behavior(
                    "unloaded function EnableiNV"));
    }
    glEnableiNV(static_cast<GLenum>(target), index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_floati_vnv(groups::get_prop target, u32 index, span_f32 data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetFloati_vNV)
                Throw(undefined_behavior(
                    "unloaded function GetFloati_vNV"));
    }
    glGetFloati_vNV(static_cast<GLenum>(target), index, reinterpret_cast<GLfloat *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_enabledi_nv(groups::enable_cap target, u32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsEnablediNV)
                Throw(undefined_behavior(
                    "unloaded function IsEnablediNV"));
    }
    auto out = glIsEnablediNV(static_cast<GLenum>(target), index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void scissor_arrayv_nv(u32 first, i32 count, span_const_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glScissorArrayvNV)
                Throw(undefined_behavior(
                    "unloaded function ScissorArrayvNV"));
    }
    glScissorArrayvNV(first, count, reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void scissor_indexed_nv(u32 index, i32 left, i32 bottom, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glScissorIndexedNV)
                Throw(undefined_behavior(
                    "unloaded function ScissorIndexedNV"));
    }
    glScissorIndexedNV(index, left, bottom, width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void scissor_indexedv_nv(u32 index, span_const_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glScissorIndexedvNV)
                Throw(undefined_behavior(
                    "unloaded function ScissorIndexedvNV"));
    }
    glScissorIndexedvNV(index, reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void viewport_arrayv_nv(u32 first, i32 count, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glViewportArrayvNV)
                Throw(undefined_behavior(
                    "unloaded function ViewportArrayvNV"));
    }
    glViewportArrayvNV(first, count, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_f32
>
requires (
    semantic::concepts::Vector<vec_2_f32, f32, 2>)
STATICINLINE void viewport_indexedf_nv(u32 index, vec_2_f32 const& x, vec_2_f32 const& w)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glViewportIndexedfNV)
                Throw(undefined_behavior(
                    "unloaded function ViewportIndexedfNV"));
    }
    glViewportIndexedfNV(index, x.x(), x.y(), w[0], w[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void viewport_indexedfv_nv(u32 index, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glViewportIndexedfvNV)
                Throw(undefined_behavior(
                    "unloaded function ViewportIndexedfvNV"));
    }
    glViewportIndexedfvNV(index, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_viewport_array
#endif // GL_NV_viewport_array
#ifdef GL_NV_viewport_array2
namespace nv_viewport_array2 {
} // nv_viewport_array2
#endif // GL_NV_viewport_array2
#ifdef GL_NV_viewport_swizzle
namespace nv_viewport_swizzle {
constexpr u32 viewport_swizzle_positive_x_nv = 0x9350;
constexpr u32 viewport_swizzle_negative_x_nv = 0x9351;
constexpr u32 viewport_swizzle_positive_y_nv = 0x9352;
constexpr u32 viewport_swizzle_negative_y_nv = 0x9353;
constexpr u32 viewport_swizzle_positive_z_nv = 0x9354;
constexpr u32 viewport_swizzle_negative_z_nv = 0x9355;
constexpr u32 viewport_swizzle_positive_w_nv = 0x9356;
constexpr u32 viewport_swizzle_negative_w_nv = 0x9357;
constexpr u32 viewport_swizzle_x_nv = 0x9358;
constexpr u32 viewport_swizzle_y_nv = 0x9359;
constexpr u32 viewport_swizzle_z_nv = 0x935A;
constexpr u32 viewport_swizzle_w_nv = 0x935B;
STATICINLINE void viewport_swizzle_nv(u32 index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glViewportSwizzleNV)
                Throw(undefined_behavior(
                    "unloaded function ViewportSwizzleNV"));
    }
    glViewportSwizzleNV(index, swizzlex, swizzley, swizzlez, swizzlew);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // nv_viewport_swizzle
#endif // GL_NV_viewport_swizzle
#ifdef GL_OES_EGL_image
namespace oes_egl_image {
STATICINLINE void egl_image_target_renderbuffer_storage_oes(GLenum target, GLeglImageOES image)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEGLImageTargetRenderbufferStorageOES)
                Throw(undefined_behavior(
                    "unloaded function EGLImageTargetRenderbufferStorageOES"));
    }
    glEGLImageTargetRenderbufferStorageOES(target, image);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void egl_image_target_texture_2does(GLenum target, GLeglImageOES image)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEGLImageTargetTexture2DOES)
                Throw(undefined_behavior(
                    "unloaded function EGLImageTargetTexture2DOES"));
    }
    glEGLImageTargetTexture2DOES(target, image);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // oes_egl_image
#endif // GL_OES_EGL_image
#ifdef GL_OES_EGL_image_external
namespace oes_egl_image_external {
constexpr u32 texture_external_oes = 0x8D65;
constexpr u32 sampler_external_oes = 0x8D66;
constexpr u32 texture_binding_external_oes = 0x8D67;
constexpr u32 required_texture_image_units_oes = 0x8D68;
} // oes_egl_image_external
#endif // GL_OES_EGL_image_external
#ifdef GL_OES_EGL_image_external_essl3
namespace oes_egl_image_external_essl3 {
} // oes_egl_image_external_essl3
#endif // GL_OES_EGL_image_external_essl3
#ifdef GL_OES_byte_coordinates
namespace oes_byte_coordinates {
constexpr u32 byte = 0x1400;
STATICINLINE void multi_tex_coord1b_oes(groups::texture_unit texture, i8 s)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord1bOES)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord1bOES"));
    }
    glMultiTexCoord1bOES(static_cast<GLenum>(texture), s);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i8
>
requires (
    semantic::concepts::Span<span_const_i8> &&
    std::is_same_v<std::decay_t<typename span_const_i8::value_type>, i8>)
STATICINLINE void multi_tex_coord1bv_oes(groups::texture_unit texture, span_const_i8 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord1bvOES)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord1bvOES"));
    }
    glMultiTexCoord1bvOES(static_cast<GLenum>(texture), reinterpret_cast<const GLbyte *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord2b_oes(groups::texture_unit texture, i8 s, i8 t)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord2bOES)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord2bOES"));
    }
    glMultiTexCoord2bOES(static_cast<GLenum>(texture), s, t);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i8
>
requires (
    semantic::concepts::Span<span_const_i8> &&
    std::is_same_v<std::decay_t<typename span_const_i8::value_type>, i8>)
STATICINLINE void multi_tex_coord2bv_oes(groups::texture_unit texture, span_const_i8 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord2bvOES)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord2bvOES"));
    }
    glMultiTexCoord2bvOES(static_cast<GLenum>(texture), reinterpret_cast<const GLbyte *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord3b_oes(groups::texture_unit texture, i8 s, i8 t, i8 r)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord3bOES)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord3bOES"));
    }
    glMultiTexCoord3bOES(static_cast<GLenum>(texture), s, t, r);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i8
>
requires (
    semantic::concepts::Span<span_const_i8> &&
    std::is_same_v<std::decay_t<typename span_const_i8::value_type>, i8>)
STATICINLINE void multi_tex_coord3bv_oes(groups::texture_unit texture, span_const_i8 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord3bvOES)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord3bvOES"));
    }
    glMultiTexCoord3bvOES(static_cast<GLenum>(texture), reinterpret_cast<const GLbyte *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord4b_oes(groups::texture_unit texture, i8 s, i8 t, i8 r, i8 q)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord4bOES)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord4bOES"));
    }
    glMultiTexCoord4bOES(static_cast<GLenum>(texture), s, t, r, q);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i8
>
requires (
    semantic::concepts::Span<span_const_i8> &&
    std::is_same_v<std::decay_t<typename span_const_i8::value_type>, i8>)
STATICINLINE void multi_tex_coord4bv_oes(groups::texture_unit texture, span_const_i8 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord4bvOES)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord4bvOES"));
    }
    glMultiTexCoord4bvOES(static_cast<GLenum>(texture), reinterpret_cast<const GLbyte *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_coord1b_oes(i8 s)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord1bOES)
                Throw(undefined_behavior(
                    "unloaded function TexCoord1bOES"));
    }
    glTexCoord1bOES(s);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i8
>
requires (
    semantic::concepts::Span<span_const_i8> &&
    std::is_same_v<std::decay_t<typename span_const_i8::value_type>, i8>)
STATICINLINE void tex_coord1bv_oes(span_const_i8 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord1bvOES)
                Throw(undefined_behavior(
                    "unloaded function TexCoord1bvOES"));
    }
    glTexCoord1bvOES(reinterpret_cast<const GLbyte *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_coord2b_oes(i8 s, i8 t)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord2bOES)
                Throw(undefined_behavior(
                    "unloaded function TexCoord2bOES"));
    }
    glTexCoord2bOES(s, t);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i8
>
requires (
    semantic::concepts::Span<span_const_i8> &&
    std::is_same_v<std::decay_t<typename span_const_i8::value_type>, i8>)
STATICINLINE void tex_coord2bv_oes(span_const_i8 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord2bvOES)
                Throw(undefined_behavior(
                    "unloaded function TexCoord2bvOES"));
    }
    glTexCoord2bvOES(reinterpret_cast<const GLbyte *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_coord3b_oes(i8 s, i8 t, i8 r)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord3bOES)
                Throw(undefined_behavior(
                    "unloaded function TexCoord3bOES"));
    }
    glTexCoord3bOES(s, t, r);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i8
>
requires (
    semantic::concepts::Span<span_const_i8> &&
    std::is_same_v<std::decay_t<typename span_const_i8::value_type>, i8>)
STATICINLINE void tex_coord3bv_oes(span_const_i8 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord3bvOES)
                Throw(undefined_behavior(
                    "unloaded function TexCoord3bvOES"));
    }
    glTexCoord3bvOES(reinterpret_cast<const GLbyte *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_coord4b_oes(i8 s, i8 t, i8 r, i8 q)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord4bOES)
                Throw(undefined_behavior(
                    "unloaded function TexCoord4bOES"));
    }
    glTexCoord4bOES(s, t, r, q);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i8
>
requires (
    semantic::concepts::Span<span_const_i8> &&
    std::is_same_v<std::decay_t<typename span_const_i8::value_type>, i8>)
STATICINLINE void tex_coord4bv_oes(span_const_i8 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord4bvOES)
                Throw(undefined_behavior(
                    "unloaded function TexCoord4bvOES"));
    }
    glTexCoord4bvOES(reinterpret_cast<const GLbyte *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i8
>
requires (
    semantic::concepts::Vector<vec_2_i8, i8, 2>)
STATICINLINE void vertex2b_oes(vec_2_i8 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex2bOES)
                Throw(undefined_behavior(
                    "unloaded function Vertex2bOES"));
    }
    glVertex2bOES(x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i8
>
requires (
    semantic::concepts::Span<span_const_i8> &&
    std::is_same_v<std::decay_t<typename span_const_i8::value_type>, i8>)
STATICINLINE void vertex2bv_oes(span_const_i8 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex2bvOES)
                Throw(undefined_behavior(
                    "unloaded function Vertex2bvOES"));
    }
    glVertex2bvOES(reinterpret_cast<const GLbyte *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_i8
>
requires (
    semantic::concepts::Vector<vec_3_i8, i8, 3>)
STATICINLINE void vertex3b_oes(vec_3_i8 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex3bOES)
                Throw(undefined_behavior(
                    "unloaded function Vertex3bOES"));
    }
    glVertex3bOES(x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i8
>
requires (
    semantic::concepts::Span<span_const_i8> &&
    std::is_same_v<std::decay_t<typename span_const_i8::value_type>, i8>)
STATICINLINE void vertex3bv_oes(span_const_i8 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex3bvOES)
                Throw(undefined_behavior(
                    "unloaded function Vertex3bvOES"));
    }
    glVertex3bvOES(reinterpret_cast<const GLbyte *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_i8
>
requires (
    semantic::concepts::Vector<vec_4_i8, i8, 4>)
STATICINLINE void vertex4b_oes(vec_4_i8 const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex4bOES)
                Throw(undefined_behavior(
                    "unloaded function Vertex4bOES"));
    }
    glVertex4bOES(x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i8
>
requires (
    semantic::concepts::Span<span_const_i8> &&
    std::is_same_v<std::decay_t<typename span_const_i8::value_type>, i8>)
STATICINLINE void vertex4bv_oes(span_const_i8 const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex4bvOES)
                Throw(undefined_behavior(
                    "unloaded function Vertex4bvOES"));
    }
    glVertex4bvOES(reinterpret_cast<const GLbyte *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // oes_byte_coordinates
#endif // GL_OES_byte_coordinates
#ifdef GL_OES_compressed_ETC1_RGB8_sub_texture
namespace oes_compressed_etc1_rgb8_sub_texture {
} // oes_compressed_etc1_rgb8_sub_texture
#endif // GL_OES_compressed_ETC1_RGB8_sub_texture
#ifdef GL_OES_compressed_ETC1_RGB8_texture
namespace oes_compressed_etc1_rgb8_texture {
constexpr u32 etc1_rgb8_oes = 0x8D64;
} // oes_compressed_etc1_rgb8_texture
#endif // GL_OES_compressed_ETC1_RGB8_texture
#ifdef GL_OES_compressed_paletted_texture
namespace oes_compressed_paletted_texture {
constexpr u32 palette4_rgb8_oes = 0x8B90;
constexpr u32 palette4_rgba8_oes = 0x8B91;
constexpr u32 palette4_r5_g6_b5_oes = 0x8B92;
constexpr u32 palette4_rgba4_oes = 0x8B93;
constexpr u32 palette4_rgb5_a1_oes = 0x8B94;
constexpr u32 palette8_rgb8_oes = 0x8B95;
constexpr u32 palette8_rgba8_oes = 0x8B96;
constexpr u32 palette8_r5_g6_b5_oes = 0x8B97;
constexpr u32 palette8_rgba4_oes = 0x8B98;
constexpr u32 palette8_rgb5_a1_oes = 0x8B99;
} // oes_compressed_paletted_texture
#endif // GL_OES_compressed_paletted_texture
#ifdef GL_OES_copy_image
namespace oes_copy_image {
STATICINLINE void copy_image_sub_data_oes(u32 srcName, groups::copy_buffer_sub_data_target srcTarget, i32 srcLevel, i32 srcX, i32 srcY, i32 srcZ, u32 dstName, groups::copy_buffer_sub_data_target dstTarget, i32 dstLevel, i32 dstX, i32 dstY, i32 dstZ, i32 srcWidth, i32 srcHeight, i32 srcDepth)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCopyImageSubDataOES)
                Throw(undefined_behavior(
                    "unloaded function CopyImageSubDataOES"));
    }
    glCopyImageSubDataOES(srcName, static_cast<GLenum>(srcTarget), srcLevel, srcX, srcY, srcZ, dstName, static_cast<GLenum>(dstTarget), dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // oes_copy_image
#endif // GL_OES_copy_image
#ifdef GL_OES_depth24
namespace oes_depth24 {
constexpr u32 depth_component24_oes = 0x81A6;
} // oes_depth24
#endif // GL_OES_depth24
#ifdef GL_OES_depth32
namespace oes_depth32 {
constexpr u32 depth_component32_oes = 0x81A7;
} // oes_depth32
#endif // GL_OES_depth32
#ifdef GL_OES_depth_texture
namespace oes_depth_texture {
constexpr u32 unsigned_short = 0x1403;
constexpr u32 unsigned_int = 0x1405;
constexpr u32 depth_component = 0x1902;
} // oes_depth_texture
#endif // GL_OES_depth_texture
#ifdef GL_OES_draw_buffers_indexed
namespace oes_draw_buffers_indexed {
constexpr u32 zero = 0;
constexpr u32 one = 1;
constexpr u32 src_color = 0x0300;
constexpr u32 one_minus_src_color = 0x0301;
constexpr u32 src_alpha = 0x0302;
constexpr u32 one_minus_src_alpha = 0x0303;
constexpr u32 dst_alpha = 0x0304;
constexpr u32 one_minus_dst_alpha = 0x0305;
constexpr u32 dst_color = 0x0306;
constexpr u32 one_minus_dst_color = 0x0307;
constexpr u32 src_alpha_saturate = 0x0308;
constexpr u32 blend = 0x0BE2;
constexpr u32 color_writemask = 0x0C23;
constexpr u32 constant_color = 0x8001;
constexpr u32 one_minus_constant_color = 0x8002;
constexpr u32 constant_alpha = 0x8003;
constexpr u32 one_minus_constant_alpha = 0x8004;
constexpr u32 func_add = 0x8006;
constexpr u32 min = 0x8007;
constexpr u32 max = 0x8008;
constexpr u32 blend_equation_rgb = 0x8009;
constexpr u32 func_subtract = 0x800A;
constexpr u32 func_reverse_subtract = 0x800B;
constexpr u32 blend_dst_rgb = 0x80C8;
constexpr u32 blend_src_rgb = 0x80C9;
constexpr u32 blend_dst_alpha = 0x80CA;
constexpr u32 blend_src_alpha = 0x80CB;
constexpr u32 blend_equation_alpha = 0x883D;
STATICINLINE void blend_equation_separatei_oes(u32 buf, groups::blend_equation_mode_ext modeRGB, groups::blend_equation_mode_ext modeAlpha)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendEquationSeparateiOES)
                Throw(undefined_behavior(
                    "unloaded function BlendEquationSeparateiOES"));
    }
    glBlendEquationSeparateiOES(buf, static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void blend_equationi_oes(u32 buf, groups::blend_equation_mode_ext mode)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendEquationiOES)
                Throw(undefined_behavior(
                    "unloaded function BlendEquationiOES"));
    }
    glBlendEquationiOES(buf, static_cast<GLenum>(mode));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void blend_func_separatei_oes(u32 buf, groups::blending_factor srcRGB, groups::blending_factor dstRGB, groups::blending_factor srcAlpha, groups::blending_factor dstAlpha)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendFuncSeparateiOES)
                Throw(undefined_behavior(
                    "unloaded function BlendFuncSeparateiOES"));
    }
    glBlendFuncSeparateiOES(buf, static_cast<GLenum>(srcRGB), static_cast<GLenum>(dstRGB), static_cast<GLenum>(srcAlpha), static_cast<GLenum>(dstAlpha));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void blend_funci_oes(u32 buf, groups::blending_factor src, groups::blending_factor dst)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendFunciOES)
                Throw(undefined_behavior(
                    "unloaded function BlendFunciOES"));
    }
    glBlendFunciOES(buf, static_cast<GLenum>(src), static_cast<GLenum>(dst));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void color_maski_oes(u32 index, bool r, bool g, bool b, bool a)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColorMaskiOES)
                Throw(undefined_behavior(
                    "unloaded function ColorMaskiOES"));
    }
    glColorMaskiOES(index, r, g, b, a);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void disablei_oes(groups::enable_cap target, u32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDisableiOES)
                Throw(undefined_behavior(
                    "unloaded function DisableiOES"));
    }
    glDisableiOES(static_cast<GLenum>(target), index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void enablei_oes(groups::enable_cap target, u32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEnableiOES)
                Throw(undefined_behavior(
                    "unloaded function EnableiOES"));
    }
    glEnableiOES(static_cast<GLenum>(target), index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_enabledi_oes(groups::enable_cap target, u32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsEnablediOES)
                Throw(undefined_behavior(
                    "unloaded function IsEnablediOES"));
    }
    auto out = glIsEnablediOES(static_cast<GLenum>(target), index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // oes_draw_buffers_indexed
#endif // GL_OES_draw_buffers_indexed
#ifdef GL_OES_draw_elements_base_vertex
namespace oes_draw_elements_base_vertex {
STATICINLINE void draw_elements_base_vertex_oes(groups::primitive_type mode, i32 count, groups::draw_elements_type type, ptroff indices, i32 basevertex)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawElementsBaseVertexOES)
                Throw(undefined_behavior(
                    "unloaded function DrawElementsBaseVertexOES"));
    }
    glDrawElementsBaseVertexOES(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), reinterpret_cast<const void*>(indices), basevertex);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void draw_elements_instanced_base_vertex_oes(groups::primitive_type mode, i32 count, groups::draw_elements_type type, ptroff indices, i32 instancecount, i32 basevertex)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawElementsInstancedBaseVertexOES)
                Throw(undefined_behavior(
                    "unloaded function DrawElementsInstancedBaseVertexOES"));
    }
    glDrawElementsInstancedBaseVertexOES(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), reinterpret_cast<const void*>(indices), instancecount, basevertex);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void draw_range_elements_base_vertex_oes(groups::primitive_type mode, u32 start, u32 end, i32 count, groups::draw_elements_type type, span_const_byte const& indices, i32 basevertex)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDrawRangeElementsBaseVertexOES)
                Throw(undefined_behavior(
                    "unloaded function DrawRangeElementsBaseVertexOES"));
    }
    glDrawRangeElementsBaseVertexOES(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), reinterpret_cast<const void *>(indices.data()), basevertex);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void multi_draw_elements_base_vertex_ext(groups::primitive_type mode, span_const_i32 count, groups::draw_elements_type type, ptroff indices, span_const_i32 basevertex)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiDrawElementsBaseVertexEXT)
                Throw(undefined_behavior(
                    "unloaded function MultiDrawElementsBaseVertexEXT"));
    }
    GLsizei drawcount = count.size();
    detail::assert_equal(count.size(), drawcount);
    detail::assert_equal(basevertex.size(), drawcount);
    glMultiDrawElementsBaseVertexEXT(static_cast<GLenum>(mode), count.data(), static_cast<GLenum>(type), reinterpret_cast<const void*>(indices), basevertex.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // oes_draw_elements_base_vertex
#endif // GL_OES_draw_elements_base_vertex
#ifdef GL_OES_element_index_uint
namespace oes_element_index_uint {
constexpr u32 unsigned_int = 0x1405;
} // oes_element_index_uint
#endif // GL_OES_element_index_uint
#ifdef GL_OES_fbo_render_mipmap
namespace oes_fbo_render_mipmap {
} // oes_fbo_render_mipmap
#endif // GL_OES_fbo_render_mipmap
#ifdef GL_OES_fixed_point
namespace oes_fixed_point {
constexpr u32 fixed_oes = 0x140C;
STATICINLINE void alpha_funcx_oes(groups::alpha_function func, GLfixed ref)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glAlphaFuncxOES)
                Throw(undefined_behavior(
                    "unloaded function AlphaFuncxOES"));
    }
    glAlphaFuncxOES(static_cast<GLenum>(func), ref);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLfixed
>
requires (
    semantic::concepts::Vector<vec_4_GLfixed, GLfixed, 4>)
STATICINLINE void clear_colorx_oes(vec_4_GLfixed const& red)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClearColorxOES)
                Throw(undefined_behavior(
                    "unloaded function ClearColorxOES"));
    }
    glClearColorxOES(red.x(), red.y(), red.z(), red.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void clear_depthx_oes(GLfixed depth)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClearDepthxOES)
                Throw(undefined_behavior(
                    "unloaded function ClearDepthxOES"));
    }
    glClearDepthxOES(depth);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void clip_planex_oes(groups::clip_plane_name plane, span_const_GLfixed const& equation)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClipPlanexOES)
                Throw(undefined_behavior(
                    "unloaded function ClipPlanexOES"));
    }
    glClipPlanexOES(static_cast<GLenum>(plane), reinterpret_cast<const GLfixed *>(equation.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLfixed
>
requires (
    semantic::concepts::Vector<vec_4_GLfixed, GLfixed, 4>)
STATICINLINE void color4x_oes(vec_4_GLfixed const& red)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColor4xOES)
                Throw(undefined_behavior(
                    "unloaded function Color4xOES"));
    }
    glColor4xOES(red.x(), red.y(), red.z(), red.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void depth_rangex_oes(GLfixed n, GLfixed f)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDepthRangexOES)
                Throw(undefined_behavior(
                    "unloaded function DepthRangexOES"));
    }
    glDepthRangexOES(n, f);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void fogx_oes(groups::fog_prop pname, GLfixed param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFogxOES)
                Throw(undefined_behavior(
                    "unloaded function FogxOES"));
    }
    glFogxOES(static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void fogxv_oes(groups::fog_prop pname, span_const_GLfixed const& param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFogxvOES)
                Throw(undefined_behavior(
                    "unloaded function FogxvOES"));
    }
    glFogxvOES(static_cast<GLenum>(pname), reinterpret_cast<const GLfixed *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void frustumx_oes(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFrustumxOES)
                Throw(undefined_behavior(
                    "unloaded function FrustumxOES"));
    }
    glFrustumxOES(l, r, b, t, n, f);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLfixed
>
requires (
    semantic::concepts::Span<span_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_GLfixed::value_type>, GLfixed>)
STATICINLINE void get_clip_planex_oes(groups::clip_plane_name plane, span_GLfixed equation)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetClipPlanexOES)
                Throw(undefined_behavior(
                    "unloaded function GetClipPlanexOES"));
    }
    glGetClipPlanexOES(static_cast<GLenum>(plane), reinterpret_cast<GLfixed *>(equation.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLfixed
>
requires (
    semantic::concepts::Span<span_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_GLfixed::value_type>, GLfixed>)
STATICINLINE void get_fixedv_oes(groups::get_prop pname, span_GLfixed params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetFixedvOES)
                Throw(undefined_behavior(
                    "unloaded function GetFixedvOES"));
    }
    glGetFixedvOES(static_cast<GLenum>(pname), reinterpret_cast<GLfixed *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLfixed
>
requires (
    semantic::concepts::Span<span_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_GLfixed::value_type>, GLfixed>)
STATICINLINE void get_tex_envxv_oes(groups::texture_env_target target, groups::texture_env_parameter pname, span_GLfixed params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTexEnvxvOES)
                Throw(undefined_behavior(
                    "unloaded function GetTexEnvxvOES"));
    }
    glGetTexEnvxvOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLfixed *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLfixed
>
requires (
    semantic::concepts::Span<span_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_GLfixed::value_type>, GLfixed>)
STATICINLINE void get_tex_parameterxv_oes(groups::texture_target target, groups::get_texture_parameter pname, span_GLfixed params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTexParameterxvOES)
                Throw(undefined_behavior(
                    "unloaded function GetTexParameterxvOES"));
    }
    glGetTexParameterxvOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLfixed *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void light_modelx_oes(groups::light_model_parameter pname, GLfixed param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glLightModelxOES)
                Throw(undefined_behavior(
                    "unloaded function LightModelxOES"));
    }
    glLightModelxOES(static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void light_modelxv_oes(groups::light_model_parameter pname, span_const_GLfixed const& param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glLightModelxvOES)
                Throw(undefined_behavior(
                    "unloaded function LightModelxvOES"));
    }
    glLightModelxvOES(static_cast<GLenum>(pname), reinterpret_cast<const GLfixed *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void lightx_oes(groups::light_name light, groups::light_parameter pname, GLfixed param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glLightxOES)
                Throw(undefined_behavior(
                    "unloaded function LightxOES"));
    }
    glLightxOES(static_cast<GLenum>(light), static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void lightxv_oes(groups::light_name light, groups::light_parameter pname, span_const_GLfixed const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glLightxvOES)
                Throw(undefined_behavior(
                    "unloaded function LightxvOES"));
    }
    glLightxvOES(static_cast<GLenum>(light), static_cast<GLenum>(pname), reinterpret_cast<const GLfixed *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void line_widthx_oes(GLfixed width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glLineWidthxOES)
                Throw(undefined_behavior(
                    "unloaded function LineWidthxOES"));
    }
    glLineWidthxOES(width);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void load_matrixx_oes(span_const_GLfixed const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glLoadMatrixxOES)
                Throw(undefined_behavior(
                    "unloaded function LoadMatrixxOES"));
    }
    glLoadMatrixxOES(reinterpret_cast<const GLfixed *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void materialx_oes(groups::material_face face, groups::material_parameter pname, GLfixed param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMaterialxOES)
                Throw(undefined_behavior(
                    "unloaded function MaterialxOES"));
    }
    glMaterialxOES(static_cast<GLenum>(face), static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void materialxv_oes(groups::material_face face, groups::material_parameter pname, span_const_GLfixed const& param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMaterialxvOES)
                Throw(undefined_behavior(
                    "unloaded function MaterialxvOES"));
    }
    glMaterialxvOES(static_cast<GLenum>(face), static_cast<GLenum>(pname), reinterpret_cast<const GLfixed *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void mult_matrixx_oes(span_const_GLfixed const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultMatrixxOES)
                Throw(undefined_behavior(
                    "unloaded function MultMatrixxOES"));
    }
    glMultMatrixxOES(reinterpret_cast<const GLfixed *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord4x_oes(groups::texture_unit texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord4xOES)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord4xOES"));
    }
    glMultiTexCoord4xOES(static_cast<GLenum>(texture), s, t, r, q);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void normal3x_oes(GLfixed nx, GLfixed ny, GLfixed nz)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNormal3xOES)
                Throw(undefined_behavior(
                    "unloaded function Normal3xOES"));
    }
    glNormal3xOES(nx, ny, nz);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void orthox_oes(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glOrthoxOES)
                Throw(undefined_behavior(
                    "unloaded function OrthoxOES"));
    }
    glOrthoxOES(l, r, b, t, n, f);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void point_parameterxv_oes(groups::point_parameter_name_arb pname, span_const_GLfixed const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPointParameterxvOES)
                Throw(undefined_behavior(
                    "unloaded function PointParameterxvOES"));
    }
    glPointParameterxvOES(static_cast<GLenum>(pname), reinterpret_cast<const GLfixed *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void point_sizex_oes(GLfixed size)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPointSizexOES)
                Throw(undefined_behavior(
                    "unloaded function PointSizexOES"));
    }
    glPointSizexOES(size);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void polygon_offsetx_oes(GLfixed factor, GLfixed units)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPolygonOffsetxOES)
                Throw(undefined_behavior(
                    "unloaded function PolygonOffsetxOES"));
    }
    glPolygonOffsetxOES(factor, units);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLfixed
>
requires (
    semantic::concepts::Vector<vec_3_GLfixed, GLfixed, 3>)
STATICINLINE void rotatex_oes(GLfixed angle, vec_3_GLfixed const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glRotatexOES)
                Throw(undefined_behavior(
                    "unloaded function RotatexOES"));
    }
    glRotatexOES(angle, x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLfixed
>
requires (
    semantic::concepts::Vector<vec_3_GLfixed, GLfixed, 3>)
STATICINLINE void scalex_oes(vec_3_GLfixed const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glScalexOES)
                Throw(undefined_behavior(
                    "unloaded function ScalexOES"));
    }
    glScalexOES(x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_envx_oes(groups::texture_env_target target, groups::texture_env_parameter pname, GLfixed param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexEnvxOES)
                Throw(undefined_behavior(
                    "unloaded function TexEnvxOES"));
    }
    glTexEnvxOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void tex_envxv_oes(groups::texture_env_target target, groups::texture_env_parameter pname, span_const_GLfixed const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexEnvxvOES)
                Throw(undefined_behavior(
                    "unloaded function TexEnvxvOES"));
    }
    glTexEnvxvOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<const GLfixed *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_parameterx_oes(groups::texture_target target, groups::get_texture_parameter pname, GLfixed param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexParameterxOES)
                Throw(undefined_behavior(
                    "unloaded function TexParameterxOES"));
    }
    glTexParameterxOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void tex_parameterxv_oes(groups::texture_target target, groups::get_texture_parameter pname, span_const_GLfixed const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexParameterxvOES)
                Throw(undefined_behavior(
                    "unloaded function TexParameterxvOES"));
    }
    glTexParameterxvOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<const GLfixed *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLfixed
>
requires (
    semantic::concepts::Vector<vec_3_GLfixed, GLfixed, 3>)
STATICINLINE void translatex_oes(vec_3_GLfixed const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTranslatexOES)
                Throw(undefined_behavior(
                    "unloaded function TranslatexOES"));
    }
    glTranslatexOES(x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLfixed
>
requires (
    semantic::concepts::Span<span_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_GLfixed::value_type>, GLfixed>)
STATICINLINE void get_lightxv_oes(groups::light_name light, groups::light_parameter pname, span_GLfixed params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetLightxvOES)
                Throw(undefined_behavior(
                    "unloaded function GetLightxvOES"));
    }
    glGetLightxvOES(static_cast<GLenum>(light), static_cast<GLenum>(pname), reinterpret_cast<GLfixed *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLfixed
>
requires (
    semantic::concepts::Span<span_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_GLfixed::value_type>, GLfixed>)
STATICINLINE void get_materialxv_oes(groups::material_face face, groups::material_parameter pname, span_GLfixed params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetMaterialxvOES)
                Throw(undefined_behavior(
                    "unloaded function GetMaterialxvOES"));
    }
    glGetMaterialxvOES(static_cast<GLenum>(face), static_cast<GLenum>(pname), reinterpret_cast<GLfixed *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void point_parameterx_oes(groups::point_parameter_name_arb pname, GLfixed param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPointParameterxOES)
                Throw(undefined_behavior(
                    "unloaded function PointParameterxOES"));
    }
    glPointParameterxOES(static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void sample_coveragex_oes(GLclampx value, bool invert)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSampleCoveragexOES)
                Throw(undefined_behavior(
                    "unloaded function SampleCoveragexOES"));
    }
    glSampleCoveragexOES(value, invert);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void accumx_oes(GLenum op, GLfixed value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glAccumxOES)
                Throw(undefined_behavior(
                    "unloaded function AccumxOES"));
    }
    glAccumxOES(op, value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u8,
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2> &&
    semantic::concepts::Span<span_const_u8> &&
    std::is_same_v<std::decay_t<typename span_const_u8::value_type>, u8>)
STATICINLINE void bitmapx_oes(vec_2_i32 const& width, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, span_const_u8 const& bitmap)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBitmapxOES)
                Throw(undefined_behavior(
                    "unloaded function BitmapxOES"));
    }
    glBitmapxOES(width[0], width[1], xorig, yorig, xmove, ymove, reinterpret_cast<const GLubyte *>(bitmap.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLfixed
>
requires (
    semantic::concepts::Vector<vec_4_GLfixed, GLfixed, 4>)
STATICINLINE void blend_colorx_oes(vec_4_GLfixed const& red)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBlendColorxOES)
                Throw(undefined_behavior(
                    "unloaded function BlendColorxOES"));
    }
    glBlendColorxOES(red.x(), red.y(), red.z(), red.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLfixed
>
requires (
    semantic::concepts::Vector<vec_4_GLfixed, GLfixed, 4>)
STATICINLINE void clear_accumx_oes(vec_4_GLfixed const& red)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClearAccumxOES)
                Throw(undefined_behavior(
                    "unloaded function ClearAccumxOES"));
    }
    glClearAccumxOES(red.x(), red.y(), red.z(), red.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLfixed
>
requires (
    semantic::concepts::Vector<vec_3_GLfixed, GLfixed, 3>)
STATICINLINE void color3x_oes(vec_3_GLfixed const& red)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColor3xOES)
                Throw(undefined_behavior(
                    "unloaded function Color3xOES"));
    }
    glColor3xOES(red.x(), red.y(), red.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void color3xv_oes(span_const_GLfixed const& components)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColor3xvOES)
                Throw(undefined_behavior(
                    "unloaded function Color3xvOES"));
    }
    glColor3xvOES(reinterpret_cast<const GLfixed *>(components.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void color4xv_oes(span_const_GLfixed const& components)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glColor4xvOES)
                Throw(undefined_behavior(
                    "unloaded function Color4xvOES"));
    }
    glColor4xvOES(reinterpret_cast<const GLfixed *>(components.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void convolution_parameterx_oes(groups::convolution_target_ext target, groups::convolution_parameter_ext pname, GLfixed param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glConvolutionParameterxOES)
                Throw(undefined_behavior(
                    "unloaded function ConvolutionParameterxOES"));
    }
    glConvolutionParameterxOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void convolution_parameterxv_oes(groups::convolution_target_ext target, groups::convolution_parameter_ext pname, span_const_GLfixed const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glConvolutionParameterxvOES)
                Throw(undefined_behavior(
                    "unloaded function ConvolutionParameterxvOES"));
    }
    glConvolutionParameterxvOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<const GLfixed *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void eval_coord1x_oes(GLfixed u)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEvalCoord1xOES)
                Throw(undefined_behavior(
                    "unloaded function EvalCoord1xOES"));
    }
    glEvalCoord1xOES(u);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void eval_coord1xv_oes(span_const_GLfixed const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEvalCoord1xvOES)
                Throw(undefined_behavior(
                    "unloaded function EvalCoord1xvOES"));
    }
    glEvalCoord1xvOES(reinterpret_cast<const GLfixed *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void eval_coord2x_oes(GLfixed u, GLfixed v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEvalCoord2xOES)
                Throw(undefined_behavior(
                    "unloaded function EvalCoord2xOES"));
    }
    glEvalCoord2xOES(u, v);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void eval_coord2xv_oes(span_const_GLfixed const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEvalCoord2xvOES)
                Throw(undefined_behavior(
                    "unloaded function EvalCoord2xvOES"));
    }
    glEvalCoord2xvOES(reinterpret_cast<const GLfixed *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void feedback_bufferx_oes(GLenum type, span_const_GLfixed const& buffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFeedbackBufferxOES)
                Throw(undefined_behavior(
                    "unloaded function FeedbackBufferxOES"));
    }
    glFeedbackBufferxOES(buffer.size(), type, reinterpret_cast<const GLfixed *>(buffer.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLfixed
>
requires (
    semantic::concepts::Span<span_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_GLfixed::value_type>, GLfixed>)
STATICINLINE void get_convolution_parameterxv_oes(GLenum target, GLenum pname, span_GLfixed params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetConvolutionParameterxvOES)
                Throw(undefined_behavior(
                    "unloaded function GetConvolutionParameterxvOES"));
    }
    glGetConvolutionParameterxvOES(target, pname, reinterpret_cast<GLfixed *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLfixed
>
requires (
    semantic::concepts::Span<span_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_GLfixed::value_type>, GLfixed>)
STATICINLINE void get_histogram_parameterxv_oes(groups::histogram_target_ext target, groups::get_histogram_parameter_prop_ext pname, span_GLfixed params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetHistogramParameterxvOES)
                Throw(undefined_behavior(
                    "unloaded function GetHistogramParameterxvOES"));
    }
    glGetHistogramParameterxvOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLfixed *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLfixed
>
requires (
    semantic::concepts::Span<span_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_GLfixed::value_type>, GLfixed>)
STATICINLINE void get_lightx_oes(groups::light_name light, groups::light_parameter pname, span_GLfixed params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetLightxOES)
                Throw(undefined_behavior(
                    "unloaded function GetLightxOES"));
    }
    glGetLightxOES(static_cast<GLenum>(light), static_cast<GLenum>(pname), reinterpret_cast<GLfixed *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLfixed
>
requires (
    semantic::concepts::Span<span_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_GLfixed::value_type>, GLfixed>)
STATICINLINE void get_mapxv_oes(groups::map_target target, groups::get_map_query query, span_GLfixed v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetMapxvOES)
                Throw(undefined_behavior(
                    "unloaded function GetMapxvOES"));
    }
    glGetMapxvOES(static_cast<GLenum>(target), static_cast<GLenum>(query), reinterpret_cast<GLfixed *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void get_materialx_oes(groups::material_face face, groups::material_parameter pname, GLfixed param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetMaterialxOES)
                Throw(undefined_behavior(
                    "unloaded function GetMaterialxOES"));
    }
    glGetMaterialxOES(static_cast<GLenum>(face), static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLfixed
>
requires (
    semantic::concepts::Span<span_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_GLfixed::value_type>, GLfixed>)
STATICINLINE void get_pixel_mapxv(groups::pixel_map map, span_GLfixed values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetPixelMapxv)
                Throw(undefined_behavior(
                    "unloaded function GetPixelMapxv"));
    }
    glGetPixelMapxv(static_cast<GLenum>(map), values.size(), reinterpret_cast<GLfixed *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLfixed
>
requires (
    semantic::concepts::Span<span_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_GLfixed::value_type>, GLfixed>)
STATICINLINE void get_tex_genxv_oes(groups::texture_coord_name coord, groups::texture_gen_parameter pname, span_GLfixed params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTexGenxvOES)
                Throw(undefined_behavior(
                    "unloaded function GetTexGenxvOES"));
    }
    glGetTexGenxvOES(static_cast<GLenum>(coord), static_cast<GLenum>(pname), reinterpret_cast<GLfixed *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLfixed
>
requires (
    semantic::concepts::Span<span_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_GLfixed::value_type>, GLfixed>)
STATICINLINE void get_tex_level_parameterxv_oes(groups::texture_target target, i32 level, groups::get_texture_parameter pname, span_GLfixed params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTexLevelParameterxvOES)
                Throw(undefined_behavior(
                    "unloaded function GetTexLevelParameterxvOES"));
    }
    glGetTexLevelParameterxvOES(static_cast<GLenum>(target), level, static_cast<GLenum>(pname), reinterpret_cast<GLfixed *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void indexx_oes(GLfixed component)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIndexxOES)
                Throw(undefined_behavior(
                    "unloaded function IndexxOES"));
    }
    glIndexxOES(component);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void indexxv_oes(span_const_GLfixed const& component)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIndexxvOES)
                Throw(undefined_behavior(
                    "unloaded function IndexxvOES"));
    }
    glIndexxvOES(reinterpret_cast<const GLfixed *>(component.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void load_transpose_matrixx_oes(span_const_GLfixed const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glLoadTransposeMatrixxOES)
                Throw(undefined_behavior(
                    "unloaded function LoadTransposeMatrixxOES"));
    }
    glLoadTransposeMatrixxOES(reinterpret_cast<const GLfixed *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void map1x_oes(groups::map_target target, GLfixed u1, GLfixed u2, i32 stride, i32 order, GLfixed points)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMap1xOES)
                Throw(undefined_behavior(
                    "unloaded function Map1xOES"));
    }
    glMap1xOES(static_cast<GLenum>(target), u1, u2, stride, order, points);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void map2x_oes(groups::map_target target, GLfixed u1, GLfixed u2, i32 ustride, i32 uorder, GLfixed v1, GLfixed v2, i32 vstride, i32 vorder, GLfixed points)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMap2xOES)
                Throw(undefined_behavior(
                    "unloaded function Map2xOES"));
    }
    glMap2xOES(static_cast<GLenum>(target), u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void map_grid1x_oes(i32 n, GLfixed u1, GLfixed u2)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMapGrid1xOES)
                Throw(undefined_behavior(
                    "unloaded function MapGrid1xOES"));
    }
    glMapGrid1xOES(n, u1, u2);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void map_grid2x_oes(i32 n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMapGrid2xOES)
                Throw(undefined_behavior(
                    "unloaded function MapGrid2xOES"));
    }
    glMapGrid2xOES(n, u1, u2, v1, v2);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void mult_transpose_matrixx_oes(span_const_GLfixed const& m)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultTransposeMatrixxOES)
                Throw(undefined_behavior(
                    "unloaded function MultTransposeMatrixxOES"));
    }
    glMultTransposeMatrixxOES(reinterpret_cast<const GLfixed *>(m.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord1x_oes(groups::texture_unit texture, GLfixed s)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord1xOES)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord1xOES"));
    }
    glMultiTexCoord1xOES(static_cast<GLenum>(texture), s);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void multi_tex_coord1xv_oes(groups::texture_unit texture, span_const_GLfixed const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord1xvOES)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord1xvOES"));
    }
    glMultiTexCoord1xvOES(static_cast<GLenum>(texture), reinterpret_cast<const GLfixed *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord2x_oes(groups::texture_unit texture, GLfixed s, GLfixed t)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord2xOES)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord2xOES"));
    }
    glMultiTexCoord2xOES(static_cast<GLenum>(texture), s, t);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void multi_tex_coord2xv_oes(groups::texture_unit texture, span_const_GLfixed const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord2xvOES)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord2xvOES"));
    }
    glMultiTexCoord2xvOES(static_cast<GLenum>(texture), reinterpret_cast<const GLfixed *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void multi_tex_coord3x_oes(groups::texture_unit texture, GLfixed s, GLfixed t, GLfixed r)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord3xOES)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord3xOES"));
    }
    glMultiTexCoord3xOES(static_cast<GLenum>(texture), s, t, r);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void multi_tex_coord3xv_oes(groups::texture_unit texture, span_const_GLfixed const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord3xvOES)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord3xvOES"));
    }
    glMultiTexCoord3xvOES(static_cast<GLenum>(texture), reinterpret_cast<const GLfixed *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void multi_tex_coord4xv_oes(groups::texture_unit texture, span_const_GLfixed const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMultiTexCoord4xvOES)
                Throw(undefined_behavior(
                    "unloaded function MultiTexCoord4xvOES"));
    }
    glMultiTexCoord4xvOES(static_cast<GLenum>(texture), reinterpret_cast<const GLfixed *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void normal3xv_oes(span_const_GLfixed const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glNormal3xvOES)
                Throw(undefined_behavior(
                    "unloaded function Normal3xvOES"));
    }
    glNormal3xvOES(reinterpret_cast<const GLfixed *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void pass_throughx_oes(GLfixed token)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPassThroughxOES)
                Throw(undefined_behavior(
                    "unloaded function PassThroughxOES"));
    }
    glPassThroughxOES(token);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void pixel_mapx(groups::pixel_map map, span_const_GLfixed const& values)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPixelMapx)
                Throw(undefined_behavior(
                    "unloaded function PixelMapx"));
    }
    glPixelMapx(static_cast<GLenum>(map), values.size(), reinterpret_cast<const GLfixed *>(values.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void pixel_storex(groups::pixel_store_parameter pname, GLfixed param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPixelStorex)
                Throw(undefined_behavior(
                    "unloaded function PixelStorex"));
    }
    glPixelStorex(static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void pixel_transferx_oes(groups::pixel_transfer_parameter pname, GLfixed param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPixelTransferxOES)
                Throw(undefined_behavior(
                    "unloaded function PixelTransferxOES"));
    }
    glPixelTransferxOES(static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void pixel_zoomx_oes(GLfixed xfactor, GLfixed yfactor)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPixelZoomxOES)
                Throw(undefined_behavior(
                    "unloaded function PixelZoomxOES"));
    }
    glPixelZoomxOES(xfactor, yfactor);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed,
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32> &&
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void prioritize_texturesx_oes(span_const_u32 const& textures, span_const_GLfixed const& priorities)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPrioritizeTexturesxOES)
                Throw(undefined_behavior(
                    "unloaded function PrioritizeTexturesxOES"));
    }
    glPrioritizeTexturesxOES(textures.size(), reinterpret_cast<const GLuint *>(textures.data()), reinterpret_cast<const GLfixed *>(priorities.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_GLfixed
>
requires (
    semantic::concepts::Vector<vec_2_GLfixed, GLfixed, 2>)
STATICINLINE void raster_pos2x_oes(vec_2_GLfixed const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glRasterPos2xOES)
                Throw(undefined_behavior(
                    "unloaded function RasterPos2xOES"));
    }
    glRasterPos2xOES(x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void raster_pos2xv_oes(span_const_GLfixed const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glRasterPos2xvOES)
                Throw(undefined_behavior(
                    "unloaded function RasterPos2xvOES"));
    }
    glRasterPos2xvOES(reinterpret_cast<const GLfixed *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLfixed
>
requires (
    semantic::concepts::Vector<vec_3_GLfixed, GLfixed, 3>)
STATICINLINE void raster_pos3x_oes(vec_3_GLfixed const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glRasterPos3xOES)
                Throw(undefined_behavior(
                    "unloaded function RasterPos3xOES"));
    }
    glRasterPos3xOES(x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void raster_pos3xv_oes(span_const_GLfixed const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glRasterPos3xvOES)
                Throw(undefined_behavior(
                    "unloaded function RasterPos3xvOES"));
    }
    glRasterPos3xvOES(reinterpret_cast<const GLfixed *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_4_GLfixed
>
requires (
    semantic::concepts::Vector<vec_4_GLfixed, GLfixed, 4>)
STATICINLINE void raster_pos4x_oes(vec_4_GLfixed const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glRasterPos4xOES)
                Throw(undefined_behavior(
                    "unloaded function RasterPos4xOES"));
    }
    glRasterPos4xOES(x.x(), x.y(), x.z(), x.w());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void raster_pos4xv_oes(span_const_GLfixed const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glRasterPos4xvOES)
                Throw(undefined_behavior(
                    "unloaded function RasterPos4xvOES"));
    }
    glRasterPos4xvOES(reinterpret_cast<const GLfixed *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void rectx_oes(GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glRectxOES)
                Throw(undefined_behavior(
                    "unloaded function RectxOES"));
    }
    glRectxOES(x1, y1, x2, y2);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void rectxv_oes(span_const_GLfixed const& v1, span_const_GLfixed const& v2)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glRectxvOES)
                Throw(undefined_behavior(
                    "unloaded function RectxvOES"));
    }
    glRectxvOES(reinterpret_cast<const GLfixed *>(v1.data()), reinterpret_cast<const GLfixed *>(v2.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_coord1x_oes(GLfixed s)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord1xOES)
                Throw(undefined_behavior(
                    "unloaded function TexCoord1xOES"));
    }
    glTexCoord1xOES(s);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void tex_coord1xv_oes(span_const_GLfixed const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord1xvOES)
                Throw(undefined_behavior(
                    "unloaded function TexCoord1xvOES"));
    }
    glTexCoord1xvOES(reinterpret_cast<const GLfixed *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_coord2x_oes(GLfixed s, GLfixed t)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord2xOES)
                Throw(undefined_behavior(
                    "unloaded function TexCoord2xOES"));
    }
    glTexCoord2xOES(s, t);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void tex_coord2xv_oes(span_const_GLfixed const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord2xvOES)
                Throw(undefined_behavior(
                    "unloaded function TexCoord2xvOES"));
    }
    glTexCoord2xvOES(reinterpret_cast<const GLfixed *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_coord3x_oes(GLfixed s, GLfixed t, GLfixed r)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord3xOES)
                Throw(undefined_behavior(
                    "unloaded function TexCoord3xOES"));
    }
    glTexCoord3xOES(s, t, r);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void tex_coord3xv_oes(span_const_GLfixed const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord3xvOES)
                Throw(undefined_behavior(
                    "unloaded function TexCoord3xvOES"));
    }
    glTexCoord3xvOES(reinterpret_cast<const GLfixed *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_coord4x_oes(GLfixed s, GLfixed t, GLfixed r, GLfixed q)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord4xOES)
                Throw(undefined_behavior(
                    "unloaded function TexCoord4xOES"));
    }
    glTexCoord4xOES(s, t, r, q);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void tex_coord4xv_oes(span_const_GLfixed const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexCoord4xvOES)
                Throw(undefined_behavior(
                    "unloaded function TexCoord4xvOES"));
    }
    glTexCoord4xvOES(reinterpret_cast<const GLfixed *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_genx_oes(groups::texture_coord_name coord, groups::texture_gen_parameter pname, GLfixed param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexGenxOES)
                Throw(undefined_behavior(
                    "unloaded function TexGenxOES"));
    }
    glTexGenxOES(static_cast<GLenum>(coord), static_cast<GLenum>(pname), param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void tex_genxv_oes(groups::texture_coord_name coord, groups::texture_gen_parameter pname, span_const_GLfixed const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexGenxvOES)
                Throw(undefined_behavior(
                    "unloaded function TexGenxvOES"));
    }
    glTexGenxvOES(static_cast<GLenum>(coord), static_cast<GLenum>(pname), reinterpret_cast<const GLfixed *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void vertex2x_oes(GLfixed x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex2xOES)
                Throw(undefined_behavior(
                    "unloaded function Vertex2xOES"));
    }
    glVertex2xOES(x);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void vertex2xv_oes(span_const_GLfixed const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex2xvOES)
                Throw(undefined_behavior(
                    "unloaded function Vertex2xvOES"));
    }
    glVertex2xvOES(reinterpret_cast<const GLfixed *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_GLfixed
>
requires (
    semantic::concepts::Vector<vec_2_GLfixed, GLfixed, 2>)
STATICINLINE void vertex3x_oes(vec_2_GLfixed const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex3xOES)
                Throw(undefined_behavior(
                    "unloaded function Vertex3xOES"));
    }
    glVertex3xOES(x.x(), x.y());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void vertex3xv_oes(span_const_GLfixed const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex3xvOES)
                Throw(undefined_behavior(
                    "unloaded function Vertex3xvOES"));
    }
    glVertex3xvOES(reinterpret_cast<const GLfixed *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_3_GLfixed
>
requires (
    semantic::concepts::Vector<vec_3_GLfixed, GLfixed, 3>)
STATICINLINE void vertex4x_oes(vec_3_GLfixed const& x)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex4xOES)
                Throw(undefined_behavior(
                    "unloaded function Vertex4xOES"));
    }
    glVertex4xOES(x.x(), x.y(), x.z());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_GLfixed
>
requires (
    semantic::concepts::Span<span_const_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_const_GLfixed::value_type>, GLfixed>)
STATICINLINE void vertex4xv_oes(span_const_GLfixed const& coords)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glVertex4xvOES)
                Throw(undefined_behavior(
                    "unloaded function Vertex4xvOES"));
    }
    glVertex4xvOES(reinterpret_cast<const GLfixed *>(coords.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // oes_fixed_point
#endif // GL_OES_fixed_point
#ifdef GL_OES_fragment_precision_high
namespace oes_fragment_precision_high {
} // oes_fragment_precision_high
#endif // GL_OES_fragment_precision_high
#ifdef GL_OES_geometry_point_size
namespace oes_geometry_point_size {
} // oes_geometry_point_size
#endif // GL_OES_geometry_point_size
#ifdef GL_OES_geometry_shader
namespace oes_geometry_shader {
constexpr u32 geometry_shader_bit_oes = 0x00000004;
constexpr u32 lines_adjacency_oes = 0x000A;
constexpr u32 line_strip_adjacency_oes = 0x000B;
constexpr u32 triangles_adjacency_oes = 0x000C;
constexpr u32 triangle_strip_adjacency_oes = 0x000D;
constexpr u32 layer_provoking_vertex_oes = 0x825E;
constexpr u32 undefined_vertex_oes = 0x8260;
constexpr u32 geometry_shader_invocations_oes = 0x887F;
constexpr u32 geometry_linked_vertices_out_oes = 0x8916;
constexpr u32 geometry_linked_input_type_oes = 0x8917;
constexpr u32 geometry_linked_output_type_oes = 0x8918;
constexpr u32 max_geometry_uniform_blocks_oes = 0x8A2C;
constexpr u32 max_combined_geometry_uniform_components_oes = 0x8A32;
constexpr u32 max_geometry_texture_image_units_oes = 0x8C29;
constexpr u32 primitives_generated_oes = 0x8C87;
constexpr u32 framebuffer_attachment_layered_oes = 0x8DA7;
constexpr u32 framebuffer_incomplete_layer_targets_oes = 0x8DA8;
constexpr u32 geometry_shader_oes = 0x8DD9;
constexpr u32 max_geometry_uniform_components_oes = 0x8DDF;
constexpr u32 max_geometry_output_vertices_oes = 0x8DE0;
constexpr u32 max_geometry_total_output_components_oes = 0x8DE1;
constexpr u32 first_vertex_convention_oes = 0x8E4D;
constexpr u32 last_vertex_convention_oes = 0x8E4E;
constexpr u32 max_geometry_shader_invocations_oes = 0x8E5A;
constexpr u32 max_geometry_image_uniforms_oes = 0x90CD;
constexpr u32 max_geometry_shader_storage_blocks_oes = 0x90D7;
constexpr u32 max_geometry_input_components_oes = 0x9123;
constexpr u32 max_geometry_output_components_oes = 0x9124;
constexpr u32 max_geometry_atomic_counter_buffers_oes = 0x92CF;
constexpr u32 max_geometry_atomic_counters_oes = 0x92D5;
constexpr u32 referenced_by_geometry_shader_oes = 0x9309;
constexpr u32 framebuffer_default_layers_oes = 0x9312;
constexpr u32 max_framebuffer_layers_oes = 0x9317;
STATICINLINE void framebuffer_texture_oes(groups::framebuffer_target target, groups::framebuffer_attachment attachment, u32 texture, i32 level)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferTextureOES)
                Throw(undefined_behavior(
                    "unloaded function FramebufferTextureOES"));
        glIsTexture(texture);
    }
    glFramebufferTextureOES(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // oes_geometry_shader
#endif // GL_OES_geometry_shader
#ifdef GL_OES_get_program_binary
namespace oes_get_program_binary {
constexpr u32 program_binary_length_oes = 0x8741;
constexpr u32 num_program_binary_formats_oes = 0x87FE;
constexpr u32 program_binary_formats_oes = 0x87FF;
template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_program_binary_oes(u32 program, i32& length, GLenum& binaryFormat, span_byte binary)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetProgramBinaryOES)
                Throw(undefined_behavior(
                    "unloaded function GetProgramBinaryOES"));
        glIsProgram(program);
    }
    glGetProgramBinaryOES(program, binary.size(), &length, &binaryFormat, reinterpret_cast<void *>(binary.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte
>
requires (
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void program_binary_oes(u32 program, GLenum binaryFormat, span_const_byte const& binary, i32 length)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glProgramBinaryOES)
                Throw(undefined_behavior(
                    "unloaded function ProgramBinaryOES"));
        glIsProgram(program);
    }
    glProgramBinaryOES(program, binaryFormat, reinterpret_cast<const void *>(binary.data()), length);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // oes_get_program_binary
#endif // GL_OES_get_program_binary
#ifdef GL_OES_gpu_shader5
namespace oes_gpu_shader5 {
} // oes_gpu_shader5
#endif // GL_OES_gpu_shader5
#ifdef GL_OES_mapbuffer
namespace oes_mapbuffer {
constexpr u32 write_only_oes = 0x88B9;
constexpr u32 buffer_access_oes = 0x88BB;
constexpr u32 buffer_mapped_oes = 0x88BC;
constexpr u32 buffer_map_pointer_oes = 0x88BD;
template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void get_buffer_pointerv_oes(groups::buffer_target_arb target, groups::buffer_pointer_name_arb pname, span_byte params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetBufferPointervOES)
                Throw(undefined_behavior(
                    "unloaded function GetBufferPointervOES"));
    }
    glGetBufferPointervOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<void **>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void * map_buffer_oes(groups::buffer_target_arb target, groups::buffer_access_arb access)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMapBufferOES)
                Throw(undefined_behavior(
                    "unloaded function MapBufferOES"));
    }
    auto out = glMapBufferOES(static_cast<GLenum>(target), static_cast<GLenum>(access));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

STATICINLINE GLboolean unmap_buffer_oes(GLenum target)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glUnmapBufferOES)
                Throw(undefined_behavior(
                    "unloaded function UnmapBufferOES"));
    }
    auto out = glUnmapBufferOES(target);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // oes_mapbuffer
#endif // GL_OES_mapbuffer
#ifdef GL_OES_packed_depth_stencil
namespace oes_packed_depth_stencil {
constexpr u32 depth_stencil_oes = 0x84F9;
constexpr u32 unsigned_int_24_8_oes = 0x84FA;
constexpr u32 depth24_stencil8_oes = 0x88F0;
} // oes_packed_depth_stencil
#endif // GL_OES_packed_depth_stencil
#ifdef GL_OES_primitive_bounding_box
namespace oes_primitive_bounding_box {
constexpr u32 primitive_bounding_box_oes = 0x92BE;
STATICINLINE void primitive_bounding_box_oes(f32 minX, f32 minY, f32 minZ, f32 minW, f32 maxX, f32 maxY, f32 maxZ, f32 maxW)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPrimitiveBoundingBoxOES)
                Throw(undefined_behavior(
                    "unloaded function PrimitiveBoundingBoxOES"));
    }
    glPrimitiveBoundingBoxOES(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // oes_primitive_bounding_box
#endif // GL_OES_primitive_bounding_box
#ifdef GL_OES_query_matrix
namespace oes_query_matrix {
template<
    class span_GLfixed,
    class span_i32
>
requires (
    semantic::concepts::Span<span_GLfixed> &&
    std::is_same_v<std::decay_t<typename span_GLfixed::value_type>, GLfixed> &&
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE GLbitfield query_matrixx_oes(span_GLfixed mantissa, span_i32 exponent)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glQueryMatrixxOES)
                Throw(undefined_behavior(
                    "unloaded function QueryMatrixxOES"));
    }
    auto out = glQueryMatrixxOES(reinterpret_cast<GLfixed *>(mantissa.data()), reinterpret_cast<GLint *>(exponent.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // oes_query_matrix
#endif // GL_OES_query_matrix
#ifdef GL_OES_read_format
namespace oes_read_format {
constexpr u32 implementation_color_read_type_oes = 0x8B9A;
constexpr u32 implementation_color_read_format_oes = 0x8B9B;
} // oes_read_format
#endif // GL_OES_read_format
#ifdef GL_OES_required_internalformat
namespace oes_required_internalformat {
constexpr u32 alpha8_oes = 0x803C;
constexpr u32 luminance8_oes = 0x8040;
constexpr u32 luminance4_alpha4_oes = 0x8043;
constexpr u32 luminance8_alpha8_oes = 0x8045;
constexpr u32 rgb8_oes = 0x8051;
constexpr u32 rgb10_ext = 0x8052;
constexpr u32 rgba4_oes = 0x8056;
constexpr u32 rgb5_a1_oes = 0x8057;
constexpr u32 rgba8_oes = 0x8058;
constexpr u32 rgb10_a2_ext = 0x8059;
constexpr u32 depth_component16_oes = 0x81A5;
constexpr u32 depth_component24_oes = 0x81A6;
constexpr u32 depth_component32_oes = 0x81A7;
constexpr u32 depth24_stencil8_oes = 0x88F0;
constexpr u32 rgb565_oes = 0x8D62;
} // oes_required_internalformat
#endif // GL_OES_required_internalformat
#ifdef GL_OES_rgb8_rgba8
namespace oes_rgb8_rgba8 {
constexpr u32 rgb8_oes = 0x8051;
constexpr u32 rgba8_oes = 0x8058;
} // oes_rgb8_rgba8
#endif // GL_OES_rgb8_rgba8
#ifdef GL_OES_sample_shading
namespace oes_sample_shading {
constexpr u32 sample_shading_oes = 0x8C36;
constexpr u32 min_sample_shading_value_oes = 0x8C37;
STATICINLINE void min_sample_shading_oes(f32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glMinSampleShadingOES)
                Throw(undefined_behavior(
                    "unloaded function MinSampleShadingOES"));
    }
    glMinSampleShadingOES(value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // oes_sample_shading
#endif // GL_OES_sample_shading
#ifdef GL_OES_sample_variables
namespace oes_sample_variables {
} // oes_sample_variables
#endif // GL_OES_sample_variables
#ifdef GL_OES_shader_image_atomic
namespace oes_shader_image_atomic {
} // oes_shader_image_atomic
#endif // GL_OES_shader_image_atomic
#ifdef GL_OES_shader_io_blocks
namespace oes_shader_io_blocks {
} // oes_shader_io_blocks
#endif // GL_OES_shader_io_blocks
#ifdef GL_OES_shader_multisample_interpolation
namespace oes_shader_multisample_interpolation {
constexpr u32 min_fragment_interpolation_offset_oes = 0x8E5B;
constexpr u32 max_fragment_interpolation_offset_oes = 0x8E5C;
constexpr u32 fragment_interpolation_offset_bits_oes = 0x8E5D;
} // oes_shader_multisample_interpolation
#endif // GL_OES_shader_multisample_interpolation
#ifdef GL_OES_single_precision
namespace oes_single_precision {
STATICINLINE void clear_depthf_oes(GLclampf depth)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClearDepthfOES)
                Throw(undefined_behavior(
                    "unloaded function ClearDepthfOES"));
    }
    glClearDepthfOES(depth);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void clip_planef_oes(groups::clip_plane_name plane, span_const_f32 const& equation)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glClipPlanefOES)
                Throw(undefined_behavior(
                    "unloaded function ClipPlanefOES"));
    }
    glClipPlanefOES(static_cast<GLenum>(plane), reinterpret_cast<const GLfloat *>(equation.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void depth_rangef_oes(GLclampf n, GLclampf f)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDepthRangefOES)
                Throw(undefined_behavior(
                    "unloaded function DepthRangefOES"));
    }
    glDepthRangefOES(n, f);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void frustumf_oes(f32 l, f32 r, f32 b, f32 t, f32 n, f32 f)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFrustumfOES)
                Throw(undefined_behavior(
                    "unloaded function FrustumfOES"));
    }
    glFrustumfOES(l, r, b, t, n, f);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_clip_planef_oes(groups::clip_plane_name plane, span_f32 equation)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetClipPlanefOES)
                Throw(undefined_behavior(
                    "unloaded function GetClipPlanefOES"));
    }
    glGetClipPlanefOES(static_cast<GLenum>(plane), reinterpret_cast<GLfloat *>(equation.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void orthof_oes(f32 l, f32 r, f32 b, f32 t, f32 n, f32 f)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glOrthofOES)
                Throw(undefined_behavior(
                    "unloaded function OrthofOES"));
    }
    glOrthofOES(l, r, b, t, n, f);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // oes_single_precision
#endif // GL_OES_single_precision
#ifdef GL_OES_standard_derivatives
namespace oes_standard_derivatives {
constexpr u32 fragment_shader_derivative_hint_oes = 0x8B8B;
} // oes_standard_derivatives
#endif // GL_OES_standard_derivatives
#ifdef GL_OES_stencil1
namespace oes_stencil1 {
constexpr u32 stencil_index1_oes = 0x8D46;
} // oes_stencil1
#endif // GL_OES_stencil1
#ifdef GL_OES_stencil4
namespace oes_stencil4 {
constexpr u32 stencil_index4_oes = 0x8D47;
} // oes_stencil4
#endif // GL_OES_stencil4
#ifdef GL_OES_surfaceless_context
namespace oes_surfaceless_context {
constexpr u32 framebuffer_undefined_oes = 0x8219;
} // oes_surfaceless_context
#endif // GL_OES_surfaceless_context
#ifdef GL_OES_tessellation_point_size
namespace oes_tessellation_point_size {
} // oes_tessellation_point_size
#endif // GL_OES_tessellation_point_size
#ifdef GL_OES_tessellation_shader
namespace oes_tessellation_shader {
constexpr u32 tess_control_shader_bit_oes = 0x00000008;
constexpr u32 tess_evaluation_shader_bit_oes = 0x00000010;
constexpr u32 triangles = 0x0004;
constexpr u32 quads_oes = 0x0007;
constexpr u32 patches_oes = 0x000E;
constexpr u32 equal = 0x0202;
constexpr u32 cw = 0x0900;
constexpr u32 ccw = 0x0901;
constexpr u32 primitive_restart_for_patches_supported_oes = 0x8221;
constexpr u32 max_tess_control_input_components_oes = 0x886C;
constexpr u32 max_tess_evaluation_input_components_oes = 0x886D;
constexpr u32 max_combined_tess_control_uniform_components_oes = 0x8E1E;
constexpr u32 max_combined_tess_evaluation_uniform_components_oes = 0x8E1F;
constexpr u32 patch_vertices_oes = 0x8E72;
constexpr u32 tess_control_output_vertices_oes = 0x8E75;
constexpr u32 tess_gen_mode_oes = 0x8E76;
constexpr u32 tess_gen_spacing_oes = 0x8E77;
constexpr u32 tess_gen_vertex_order_oes = 0x8E78;
constexpr u32 tess_gen_point_mode_oes = 0x8E79;
constexpr u32 isolines_oes = 0x8E7A;
constexpr u32 fractional_odd_oes = 0x8E7B;
constexpr u32 fractional_even_oes = 0x8E7C;
constexpr u32 max_patch_vertices_oes = 0x8E7D;
constexpr u32 max_tess_gen_level_oes = 0x8E7E;
constexpr u32 max_tess_control_uniform_components_oes = 0x8E7F;
constexpr u32 max_tess_evaluation_uniform_components_oes = 0x8E80;
constexpr u32 max_tess_control_texture_image_units_oes = 0x8E81;
constexpr u32 max_tess_evaluation_texture_image_units_oes = 0x8E82;
constexpr u32 max_tess_control_output_components_oes = 0x8E83;
constexpr u32 max_tess_patch_components_oes = 0x8E84;
constexpr u32 max_tess_control_total_output_components_oes = 0x8E85;
constexpr u32 max_tess_evaluation_output_components_oes = 0x8E86;
constexpr u32 tess_evaluation_shader_oes = 0x8E87;
constexpr u32 tess_control_shader_oes = 0x8E88;
constexpr u32 max_tess_control_uniform_blocks_oes = 0x8E89;
constexpr u32 max_tess_evaluation_uniform_blocks_oes = 0x8E8A;
constexpr u32 max_tess_control_image_uniforms_oes = 0x90CB;
constexpr u32 max_tess_evaluation_image_uniforms_oes = 0x90CC;
constexpr u32 max_tess_control_shader_storage_blocks_oes = 0x90D8;
constexpr u32 max_tess_evaluation_shader_storage_blocks_oes = 0x90D9;
constexpr u32 max_tess_control_atomic_counter_buffers_oes = 0x92CD;
constexpr u32 max_tess_evaluation_atomic_counter_buffers_oes = 0x92CE;
constexpr u32 max_tess_control_atomic_counters_oes = 0x92D3;
constexpr u32 max_tess_evaluation_atomic_counters_oes = 0x92D4;
constexpr u32 is_per_patch_oes = 0x92E7;
constexpr u32 referenced_by_tess_control_shader_oes = 0x9307;
constexpr u32 referenced_by_tess_evaluation_shader_oes = 0x9308;
STATICINLINE void patch_parameteri_oes(groups::patch_parameter_name pname, i32 value)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glPatchParameteriOES)
                Throw(undefined_behavior(
                    "unloaded function PatchParameteriOES"));
    }
    glPatchParameteriOES(static_cast<GLenum>(pname), value);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // oes_tessellation_shader
#endif // GL_OES_tessellation_shader
#ifdef GL_OES_texture_3D
namespace oes_texture_3d {
constexpr u32 texture_binding_3d_oes = 0x806A;
constexpr u32 texture_3d_oes = 0x806F;
constexpr u32 texture_wrap_r_oes = 0x8072;
constexpr u32 max_3d_texture_size_oes = 0x8073;
constexpr u32 sampler_3d_oes = 0x8B5F;
constexpr u32 framebuffer_attachment_texture_3d_zoffset_oes = 0x8CD4;
template<
    class span_const_byte,
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void compressed_tex_image_3does(groups::texture_target target, i32 level, groups::internal_format internalformat, vec_3_i32 const& width, i32 border, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCompressedTexImage3DOES)
                Throw(undefined_behavior(
                    "unloaded function CompressedTexImage3DOES"));
    }
    glCompressedTexImage3DOES(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width[0], width[1], width[2], border, data.size(), reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void compressed_tex_sub_image_3does(groups::texture_target target, i32 level, vec_3_i32 const& xoffset, vec_3_i32 const& width, groups::pixel_format format, span_const_byte const& data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCompressedTexSubImage3DOES)
                Throw(undefined_behavior(
                    "unloaded function CompressedTexSubImage3DOES"));
    }
    glCompressedTexSubImage3DOES(static_cast<GLenum>(target), level, xoffset.x(), xoffset.y(), xoffset.z(), width[0], width[1], width[2], static_cast<GLenum>(format), data.size(), reinterpret_cast<const void *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32,
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3> &&
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void copy_tex_sub_image_3does(GLenum target, i32 level, vec_3_i32 const& xoffset, vec_2_i32 const& x, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glCopyTexSubImage3DOES)
                Throw(undefined_behavior(
                    "unloaded function CopyTexSubImage3DOES"));
    }
    glCopyTexSubImage3DOES(target, level, xoffset.x(), xoffset.y(), xoffset.z(), x.x(), x.y(), width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void framebuffer_texture_3does(groups::framebuffer_target target, groups::framebuffer_attachment attachment, groups::texture_target textarget, u32 texture, i32 level, i32 zoffset)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferTexture3DOES)
                Throw(undefined_behavior(
                    "unloaded function FramebufferTexture3DOES"));
        glIsTexture(texture);
    }
    glFramebufferTexture3DOES(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level, zoffset);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void tex_image_3does(groups::texture_target target, i32 level, groups::internal_format internalformat, vec_3_i32 const& width, i32 border, groups::pixel_format format, groups::pixel_type type, span_const_byte const& pixels)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexImage3DOES)
                Throw(undefined_behavior(
                    "unloaded function TexImage3DOES"));
    }
    glTexImage3DOES(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width[0], width[1], width[2], border, static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<const void *>(pixels.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_byte,
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3> &&
    semantic::concepts::Span<span_const_byte> &&
    std::is_same_v<std::decay_t<typename span_const_byte::value_type>, const std::byte>)
STATICINLINE void tex_sub_image_3does(groups::texture_target target, i32 level, vec_3_i32 const& xoffset, vec_3_i32 const& width, groups::pixel_format format, groups::pixel_type type, span_const_byte const& pixels)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexSubImage3DOES)
                Throw(undefined_behavior(
                    "unloaded function TexSubImage3DOES"));
    }
    glTexSubImage3DOES(static_cast<GLenum>(target), level, xoffset.x(), xoffset.y(), xoffset.z(), width[0], width[1], width[2], static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<const void *>(pixels.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // oes_texture_3d
#endif // GL_OES_texture_3D
#ifdef GL_OES_texture_border_clamp
namespace oes_texture_border_clamp {
constexpr u32 texture_border_color_oes = 0x1004;
constexpr u32 clamp_to_border_oes = 0x812D;
template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_sampler_parameter_iiv_oes(u32 sampler, groups::sampler_parameter_i pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetSamplerParameterIivOES)
                Throw(undefined_behavior(
                    "unloaded function GetSamplerParameterIivOES"));
        glIsSampler(sampler);
    }
    glGetSamplerParameterIivOES(sampler, static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_sampler_parameter_iuiv_oes(u32 sampler, groups::sampler_parameter_i pname, span_u32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetSamplerParameterIuivOES)
                Throw(undefined_behavior(
                    "unloaded function GetSamplerParameterIuivOES"));
        glIsSampler(sampler);
    }
    glGetSamplerParameterIuivOES(sampler, static_cast<GLenum>(pname), reinterpret_cast<GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void get_tex_parameter_iiv_oes(groups::texture_target target, groups::get_texture_parameter pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTexParameterIivOES)
                Throw(undefined_behavior(
                    "unloaded function GetTexParameterIivOES"));
    }
    glGetTexParameterIivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_tex_parameter_iuiv_oes(groups::texture_target target, groups::get_texture_parameter pname, span_u32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetTexParameterIuivOES)
                Throw(undefined_behavior(
                    "unloaded function GetTexParameterIuivOES"));
    }
    glGetTexParameterIuivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void sampler_parameter_iiv_oes(u32 sampler, groups::sampler_parameter_i pname, span_const_i32 const& param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSamplerParameterIivOES)
                Throw(undefined_behavior(
                    "unloaded function SamplerParameterIivOES"));
        glIsSampler(sampler);
    }
    glSamplerParameterIivOES(sampler, static_cast<GLenum>(pname), reinterpret_cast<const GLint *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void sampler_parameter_iuiv_oes(u32 sampler, groups::sampler_parameter_i pname, span_const_u32 const& param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glSamplerParameterIuivOES)
                Throw(undefined_behavior(
                    "unloaded function SamplerParameterIuivOES"));
        glIsSampler(sampler);
    }
    glSamplerParameterIuivOES(sampler, static_cast<GLenum>(pname), reinterpret_cast<const GLuint *>(param.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void tex_parameter_iiv_oes(groups::texture_target target, groups::texture_parameter_name pname, span_const_i32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexParameterIivOES)
                Throw(undefined_behavior(
                    "unloaded function TexParameterIivOES"));
    }
    glTexParameterIivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<const GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void tex_parameter_iuiv_oes(groups::texture_target target, groups::texture_parameter_name pname, span_const_u32 const& params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexParameterIuivOES)
                Throw(undefined_behavior(
                    "unloaded function TexParameterIuivOES"));
    }
    glTexParameterIuivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), reinterpret_cast<const GLuint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // oes_texture_border_clamp
#endif // GL_OES_texture_border_clamp
#ifdef GL_OES_texture_buffer
namespace oes_texture_buffer {
constexpr u32 texture_buffer_oes = 0x8C2A;
constexpr u32 texture_buffer_binding_oes = 0x8C2A;
constexpr u32 max_texture_buffer_size_oes = 0x8C2B;
constexpr u32 texture_binding_buffer_oes = 0x8C2C;
constexpr u32 texture_buffer_data_store_binding_oes = 0x8C2D;
constexpr u32 sampler_buffer_oes = 0x8DC2;
constexpr u32 int_sampler_buffer_oes = 0x8DD0;
constexpr u32 unsigned_int_sampler_buffer_oes = 0x8DD8;
constexpr u32 image_buffer_oes = 0x9051;
constexpr u32 int_image_buffer_oes = 0x905C;
constexpr u32 unsigned_int_image_buffer_oes = 0x9067;
constexpr u32 texture_buffer_offset_oes = 0x919D;
constexpr u32 texture_buffer_size_oes = 0x919E;
constexpr u32 texture_buffer_offset_alignment_oes = 0x919F;
STATICINLINE void tex_buffer_oes(groups::texture_target target, groups::sized_internal_format internalformat, u32 buffer)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexBufferOES)
                Throw(undefined_behavior(
                    "unloaded function TexBufferOES"));
        glIsBuffer(buffer);
    }
    glTexBufferOES(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_buffer_range_oes(groups::texture_target target, groups::sized_internal_format internalformat, u32 buffer, GLintptr offset, GLsizeiptr size)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexBufferRangeOES)
                Throw(undefined_behavior(
                    "unloaded function TexBufferRangeOES"));
        glIsBuffer(buffer);
    }
    glTexBufferRangeOES(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer, offset, size);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // oes_texture_buffer
#endif // GL_OES_texture_buffer
#ifdef GL_OES_texture_compression_astc
namespace oes_texture_compression_astc {
constexpr u32 compressed_rgba_astc_4x4_khr = 0x93B0;
constexpr u32 compressed_rgba_astc_5x4_khr = 0x93B1;
constexpr u32 compressed_rgba_astc_5x5_khr = 0x93B2;
constexpr u32 compressed_rgba_astc_6x5_khr = 0x93B3;
constexpr u32 compressed_rgba_astc_6x6_khr = 0x93B4;
constexpr u32 compressed_rgba_astc_8x5_khr = 0x93B5;
constexpr u32 compressed_rgba_astc_8x6_khr = 0x93B6;
constexpr u32 compressed_rgba_astc_8x8_khr = 0x93B7;
constexpr u32 compressed_rgba_astc_10x5_khr = 0x93B8;
constexpr u32 compressed_rgba_astc_10x6_khr = 0x93B9;
constexpr u32 compressed_rgba_astc_10x8_khr = 0x93BA;
constexpr u32 compressed_rgba_astc_10x10_khr = 0x93BB;
constexpr u32 compressed_rgba_astc_12x10_khr = 0x93BC;
constexpr u32 compressed_rgba_astc_12x12_khr = 0x93BD;
constexpr u32 compressed_rgba_astc_3x3x3_oes = 0x93C0;
constexpr u32 compressed_rgba_astc_4x3x3_oes = 0x93C1;
constexpr u32 compressed_rgba_astc_4x4x3_oes = 0x93C2;
constexpr u32 compressed_rgba_astc_4x4x4_oes = 0x93C3;
constexpr u32 compressed_rgba_astc_5x4x4_oes = 0x93C4;
constexpr u32 compressed_rgba_astc_5x5x4_oes = 0x93C5;
constexpr u32 compressed_rgba_astc_5x5x5_oes = 0x93C6;
constexpr u32 compressed_rgba_astc_6x5x5_oes = 0x93C7;
constexpr u32 compressed_rgba_astc_6x6x5_oes = 0x93C8;
constexpr u32 compressed_rgba_astc_6x6x6_oes = 0x93C9;
constexpr u32 compressed_srgb8_alpha8_astc_4x4_khr = 0x93D0;
constexpr u32 compressed_srgb8_alpha8_astc_5x4_khr = 0x93D1;
constexpr u32 compressed_srgb8_alpha8_astc_5x5_khr = 0x93D2;
constexpr u32 compressed_srgb8_alpha8_astc_6x5_khr = 0x93D3;
constexpr u32 compressed_srgb8_alpha8_astc_6x6_khr = 0x93D4;
constexpr u32 compressed_srgb8_alpha8_astc_8x5_khr = 0x93D5;
constexpr u32 compressed_srgb8_alpha8_astc_8x6_khr = 0x93D6;
constexpr u32 compressed_srgb8_alpha8_astc_8x8_khr = 0x93D7;
constexpr u32 compressed_srgb8_alpha8_astc_10x5_khr = 0x93D8;
constexpr u32 compressed_srgb8_alpha8_astc_10x6_khr = 0x93D9;
constexpr u32 compressed_srgb8_alpha8_astc_10x8_khr = 0x93DA;
constexpr u32 compressed_srgb8_alpha8_astc_10x10_khr = 0x93DB;
constexpr u32 compressed_srgb8_alpha8_astc_12x10_khr = 0x93DC;
constexpr u32 compressed_srgb8_alpha8_astc_12x12_khr = 0x93DD;
constexpr u32 compressed_srgb8_alpha8_astc_3x3x3_oes = 0x93E0;
constexpr u32 compressed_srgb8_alpha8_astc_4x3x3_oes = 0x93E1;
constexpr u32 compressed_srgb8_alpha8_astc_4x4x3_oes = 0x93E2;
constexpr u32 compressed_srgb8_alpha8_astc_4x4x4_oes = 0x93E3;
constexpr u32 compressed_srgb8_alpha8_astc_5x4x4_oes = 0x93E4;
constexpr u32 compressed_srgb8_alpha8_astc_5x5x4_oes = 0x93E5;
constexpr u32 compressed_srgb8_alpha8_astc_5x5x5_oes = 0x93E6;
constexpr u32 compressed_srgb8_alpha8_astc_6x5x5_oes = 0x93E7;
constexpr u32 compressed_srgb8_alpha8_astc_6x6x5_oes = 0x93E8;
constexpr u32 compressed_srgb8_alpha8_astc_6x6x6_oes = 0x93E9;
} // oes_texture_compression_astc
#endif // GL_OES_texture_compression_astc
#ifdef GL_OES_texture_cube_map_array
namespace oes_texture_cube_map_array {
constexpr u32 texture_cube_map_array_oes = 0x9009;
constexpr u32 texture_binding_cube_map_array_oes = 0x900A;
constexpr u32 sampler_cube_map_array_oes = 0x900C;
constexpr u32 sampler_cube_map_array_shadow_oes = 0x900D;
constexpr u32 int_sampler_cube_map_array_oes = 0x900E;
constexpr u32 unsigned_int_sampler_cube_map_array_oes = 0x900F;
constexpr u32 image_cube_map_array_oes = 0x9054;
constexpr u32 int_image_cube_map_array_oes = 0x905F;
constexpr u32 unsigned_int_image_cube_map_array_oes = 0x906A;
} // oes_texture_cube_map_array
#endif // GL_OES_texture_cube_map_array
#ifdef GL_OES_texture_float
namespace oes_texture_float {
constexpr u32 float = 0x1406;
} // oes_texture_float
#endif // GL_OES_texture_float
#ifdef GL_OES_texture_float_linear
namespace oes_texture_float_linear {
} // oes_texture_float_linear
#endif // GL_OES_texture_float_linear
#ifdef GL_OES_texture_half_float
namespace oes_texture_half_float {
constexpr u32 half_float_oes = 0x8D61;
} // oes_texture_half_float
#endif // GL_OES_texture_half_float
#ifdef GL_OES_texture_half_float_linear
namespace oes_texture_half_float_linear {
} // oes_texture_half_float_linear
#endif // GL_OES_texture_half_float_linear
#ifdef GL_OES_texture_npot
namespace oes_texture_npot {
} // oes_texture_npot
#endif // GL_OES_texture_npot
#ifdef GL_OES_texture_stencil8
namespace oes_texture_stencil8 {
constexpr u32 stencil_index_oes = 0x1901;
constexpr u32 stencil_index8_oes = 0x8D48;
} // oes_texture_stencil8
#endif // GL_OES_texture_stencil8
#ifdef GL_OES_texture_storage_multisample_2d_array
namespace oes_texture_storage_multisample_2d_array {
constexpr u32 texture_2d_multisample_array_oes = 0x9102;
constexpr u32 texture_binding_2d_multisample_array_oes = 0x9105;
constexpr u32 sampler_2d_multisample_array_oes = 0x910B;
constexpr u32 int_sampler_2d_multisample_array_oes = 0x910C;
constexpr u32 unsigned_int_sampler_2d_multisample_array_oes = 0x910D;
template<
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3>)
STATICINLINE void tex_storage_3d_multisample_oes(groups::texture_target target, i32 samples, groups::sized_internal_format internalformat, vec_3_i32 const& width, bool fixedsamplelocations)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexStorage3DMultisampleOES)
                Throw(undefined_behavior(
                    "unloaded function TexStorage3DMultisampleOES"));
    }
    glTexStorage3DMultisampleOES(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width[0], width[1], width[2], fixedsamplelocations);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // oes_texture_storage_multisample_2d_array
#endif // GL_OES_texture_storage_multisample_2d_array
#ifdef GL_OES_texture_view
namespace oes_texture_view {
constexpr u32 texture_view_min_level_oes = 0x82DB;
constexpr u32 texture_view_num_levels_oes = 0x82DC;
constexpr u32 texture_view_min_layer_oes = 0x82DD;
constexpr u32 texture_view_num_layers_oes = 0x82DE;
constexpr u32 texture_immutable_levels = 0x82DF;
STATICINLINE void texture_view_oes(u32 texture, groups::texture_target target, u32 origtexture, groups::sized_internal_format internalformat, u32 minlevel, u32 numlevels, u32 minlayer, u32 numlayers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureViewOES)
                Throw(undefined_behavior(
                    "unloaded function TextureViewOES"));
        glIsTexture(texture);
    }
    glTextureViewOES(texture, static_cast<GLenum>(target), origtexture, static_cast<GLenum>(internalformat), minlevel, numlevels, minlayer, numlayers);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // oes_texture_view
#endif // GL_OES_texture_view
#ifdef GL_OES_vertex_array_object
namespace oes_vertex_array_object {
constexpr u32 vertex_array_binding_oes = 0x85B5;
STATICINLINE void bind_vertex_array_oes(u32 array)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glBindVertexArrayOES)
                Throw(undefined_behavior(
                    "unloaded function BindVertexArrayOES"));
        glIsVertexArray(array);
    }
    glBindVertexArrayOES(array);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_u32
>
requires (
    semantic::concepts::Span<span_const_u32> &&
    std::is_same_v<std::decay_t<typename span_const_u32::value_type>, u32>)
STATICINLINE void delete_vertex_arrays_oes(span_const_u32 const& arrays)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDeleteVertexArraysOES)
                Throw(undefined_behavior(
                    "unloaded function DeleteVertexArraysOES"));
    }
    glDeleteVertexArraysOES(arrays.size(), reinterpret_cast<const GLuint *>(arrays.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void gen_vertex_arrays_oes(span_u32 arrays)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGenVertexArraysOES)
                Throw(undefined_behavior(
                    "unloaded function GenVertexArraysOES"));
    }
    glGenVertexArraysOES(arrays.size(), reinterpret_cast<GLuint *>(arrays.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_vertex_array_oes(u32 array)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsVertexArrayOES)
                Throw(undefined_behavior(
                    "unloaded function IsVertexArrayOES"));
        glIsVertexArray(array);
    }
    auto out = glIsVertexArrayOES(array);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // oes_vertex_array_object
#endif // GL_OES_vertex_array_object
#ifdef GL_OES_vertex_half_float
namespace oes_vertex_half_float {
constexpr u32 half_float_oes = 0x8D61;
} // oes_vertex_half_float
#endif // GL_OES_vertex_half_float
#ifdef GL_OES_vertex_type_10_10_10_2
namespace oes_vertex_type_10_10_10_2 {
constexpr u32 unsigned_int_10_10_10_2_oes = 0x8DF6;
constexpr u32 int_10_10_10_2_oes = 0x8DF7;
} // oes_vertex_type_10_10_10_2
#endif // GL_OES_vertex_type_10_10_10_2
#ifdef GL_OES_viewport_array
namespace oes_viewport_array {
constexpr u32 depth_range = 0x0B70;
constexpr u32 viewport = 0x0BA2;
constexpr u32 scissor_box = 0x0C10;
constexpr u32 scissor_test = 0x0C11;
constexpr u32 max_viewports_oes = 0x825B;
constexpr u32 viewport_subpixel_bits_oes = 0x825C;
constexpr u32 viewport_bounds_range_oes = 0x825D;
constexpr u32 viewport_index_provoking_vertex_oes = 0x825F;
template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void depth_range_arrayfv_oes(u32 first, i32 count, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDepthRangeArrayfvOES)
                Throw(undefined_behavior(
                    "unloaded function DepthRangeArrayfvOES"));
    }
    glDepthRangeArrayfvOES(first, count, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void depth_range_indexedf_oes(u32 index, f32 n, f32 f)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDepthRangeIndexedfOES)
                Throw(undefined_behavior(
                    "unloaded function DepthRangeIndexedfOES"));
    }
    glDepthRangeIndexedfOES(index, n, f);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void disablei_oes(groups::enable_cap target, u32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDisableiOES)
                Throw(undefined_behavior(
                    "unloaded function DisableiOES"));
    }
    glDisableiOES(static_cast<GLenum>(target), index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void enablei_oes(groups::enable_cap target, u32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEnableiOES)
                Throw(undefined_behavior(
                    "unloaded function EnableiOES"));
    }
    glEnableiOES(static_cast<GLenum>(target), index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_f32
>
requires (
    semantic::concepts::Span<span_f32> &&
    std::is_same_v<std::decay_t<typename span_f32::value_type>, f32>)
STATICINLINE void get_floati_voes(groups::get_prop target, u32 index, span_f32 data)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetFloati_vOES)
                Throw(undefined_behavior(
                    "unloaded function GetFloati_vOES"));
    }
    glGetFloati_vOES(static_cast<GLenum>(target), index, reinterpret_cast<GLfloat *>(data.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean is_enabledi_oes(groups::enable_cap target, u32 index)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glIsEnablediOES)
                Throw(undefined_behavior(
                    "unloaded function IsEnablediOES"));
    }
    auto out = glIsEnablediOES(static_cast<GLenum>(target), index);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void scissor_arrayv_oes(u32 first, i32 count, span_const_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glScissorArrayvOES)
                Throw(undefined_behavior(
                    "unloaded function ScissorArrayvOES"));
    }
    glScissorArrayvOES(first, count, reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_i32
>
requires (
    semantic::concepts::Vector<vec_2_i32, i32, 2>)
STATICINLINE void scissor_indexed_oes(u32 index, i32 left, i32 bottom, vec_2_i32 const& width)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glScissorIndexedOES)
                Throw(undefined_behavior(
                    "unloaded function ScissorIndexedOES"));
    }
    glScissorIndexedOES(index, left, bottom, width[0], width[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_i32
>
requires (
    semantic::concepts::Span<span_const_i32> &&
    std::is_same_v<std::decay_t<typename span_const_i32::value_type>, i32>)
STATICINLINE void scissor_indexedv_oes(u32 index, span_const_i32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glScissorIndexedvOES)
                Throw(undefined_behavior(
                    "unloaded function ScissorIndexedvOES"));
    }
    glScissorIndexedvOES(index, reinterpret_cast<const GLint *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void viewport_arrayv_oes(u32 first, i32 count, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glViewportArrayvOES)
                Throw(undefined_behavior(
                    "unloaded function ViewportArrayvOES"));
    }
    glViewportArrayvOES(first, count, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_f32
>
requires (
    semantic::concepts::Vector<vec_2_f32, f32, 2>)
STATICINLINE void viewport_indexedf_oes(u32 index, vec_2_f32 const& x, vec_2_f32 const& w)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glViewportIndexedfOES)
                Throw(undefined_behavior(
                    "unloaded function ViewportIndexedfOES"));
    }
    glViewportIndexedfOES(index, x.x(), x.y(), w[0], w[1]);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_const_f32
>
requires (
    semantic::concepts::Span<span_const_f32> &&
    std::is_same_v<std::decay_t<typename span_const_f32::value_type>, f32>)
STATICINLINE void viewport_indexedfv_oes(u32 index, span_const_f32 const& v)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glViewportIndexedfvOES)
                Throw(undefined_behavior(
                    "unloaded function ViewportIndexedfvOES"));
    }
    glViewportIndexedfvOES(index, reinterpret_cast<const GLfloat *>(v.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // oes_viewport_array
#endif // GL_OES_viewport_array
#ifdef GL_QCOM_alpha_test
namespace qcom_alpha_test {
constexpr u32 alpha_test_qcom = 0x0BC0;
constexpr u32 alpha_test_func_qcom = 0x0BC1;
constexpr u32 alpha_test_ref_qcom = 0x0BC2;
STATICINLINE void alpha_func_qcom(GLenum func, GLclampf ref)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glAlphaFuncQCOM)
                Throw(undefined_behavior(
                    "unloaded function AlphaFuncQCOM"));
    }
    glAlphaFuncQCOM(func, ref);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // qcom_alpha_test
#endif // GL_QCOM_alpha_test
#ifdef GL_QCOM_binning_control
namespace qcom_binning_control {
constexpr u32 binning_control_hint_qcom = 0x8FB0;
constexpr u32 cpu_optimized_qcom = 0x8FB1;
constexpr u32 gpu_optimized_qcom = 0x8FB2;
constexpr u32 render_direct_to_framebuffer_qcom = 0x8FB3;
} // qcom_binning_control
#endif // GL_QCOM_binning_control
#ifdef GL_QCOM_driver_control
namespace qcom_driver_control {
STATICINLINE void disable_driver_control_qcom(u32 driverControl)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glDisableDriverControlQCOM)
                Throw(undefined_behavior(
                    "unloaded function DisableDriverControlQCOM"));
    }
    glDisableDriverControlQCOM(driverControl);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void enable_driver_control_qcom(u32 driverControl)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEnableDriverControlQCOM)
                Throw(undefined_behavior(
                    "unloaded function EnableDriverControlQCOM"));
    }
    glEnableDriverControlQCOM(driverControl);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_GLchar,
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32> &&
    semantic::concepts::Span<span_GLchar> &&
    std::is_same_v<std::decay_t<typename span_GLchar::value_type>, GLchar>)
STATICINLINE void get_driver_control_string_qcom(u32 driverControl, span_i32 length, span_GLchar driverControlString)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetDriverControlStringQCOM)
                Throw(undefined_behavior(
                    "unloaded function GetDriverControlStringQCOM"));
    }
    glGetDriverControlStringQCOM(driverControl, driverControlString.size(), reinterpret_cast<GLsizei *>(length.data()), driverControlString.data());
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32,
    class span_u32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32> &&
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void get_driver_controls_qcom(span_i32 num, span_u32 driverControls)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glGetDriverControlsQCOM)
                Throw(undefined_behavior(
                    "unloaded function GetDriverControlsQCOM"));
    }
    glGetDriverControlsQCOM(reinterpret_cast<GLint *>(num.data()), driverControls.size(), reinterpret_cast<GLuint *>(driverControls.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // qcom_driver_control
#endif // GL_QCOM_driver_control
#ifdef GL_QCOM_extended_get
namespace qcom_extended_get {
constexpr u32 texture_width_qcom = 0x8BD2;
constexpr u32 texture_height_qcom = 0x8BD3;
constexpr u32 texture_depth_qcom = 0x8BD4;
constexpr u32 texture_internal_format_qcom = 0x8BD5;
constexpr u32 texture_format_qcom = 0x8BD6;
constexpr u32 texture_type_qcom = 0x8BD7;
constexpr u32 texture_image_valid_qcom = 0x8BD8;
constexpr u32 texture_num_levels_qcom = 0x8BD9;
constexpr u32 texture_target_qcom = 0x8BDA;
constexpr u32 texture_object_valid_qcom = 0x8BDB;
constexpr u32 state_restore = 0x8BDC;
template<
    class span_byte
>
requires (
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void ext_get_buffer_pointerv_qcom(GLenum target, span_byte params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glExtGetBufferPointervQCOM)
                Throw(undefined_behavior(
                    "unloaded function ExtGetBufferPointervQCOM"));
    }
    glExtGetBufferPointervQCOM(target, reinterpret_cast<void **>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void ext_get_buffers_qcom(span_u32 buffers, i32 maxBuffers, i32& numBuffers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glExtGetBuffersQCOM)
                Throw(undefined_behavior(
                    "unloaded function ExtGetBuffersQCOM"));
    }
    glExtGetBuffersQCOM(reinterpret_cast<GLuint *>(buffers.data()), maxBuffers, &numBuffers);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void ext_get_framebuffers_qcom(span_u32 framebuffers, i32 maxFramebuffers, i32& numFramebuffers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glExtGetFramebuffersQCOM)
                Throw(undefined_behavior(
                    "unloaded function ExtGetFramebuffersQCOM"));
    }
    glExtGetFramebuffersQCOM(reinterpret_cast<GLuint *>(framebuffers.data()), maxFramebuffers, &numFramebuffers);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void ext_get_renderbuffers_qcom(span_u32 renderbuffers, i32 maxRenderbuffers, i32& numRenderbuffers)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glExtGetRenderbuffersQCOM)
                Throw(undefined_behavior(
                    "unloaded function ExtGetRenderbuffersQCOM"));
    }
    glExtGetRenderbuffersQCOM(reinterpret_cast<GLuint *>(renderbuffers.data()), maxRenderbuffers, &numRenderbuffers);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void ext_get_tex_level_parameteriv_qcom(u32 texture, GLenum face, i32 level, GLenum pname, span_i32 params)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glExtGetTexLevelParameterivQCOM)
                Throw(undefined_behavior(
                    "unloaded function ExtGetTexLevelParameterivQCOM"));
        glIsTexture(texture);
    }
    glExtGetTexLevelParameterivQCOM(texture, face, level, pname, reinterpret_cast<GLint *>(params.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_byte,
    class vec_3_i32
>
requires (
    semantic::concepts::Vector<vec_3_i32, i32, 3> &&
    semantic::concepts::Span<span_byte> &&
    std::is_same_v<std::decay_t<typename span_byte::value_type>, std::byte>)
STATICINLINE void ext_get_tex_sub_image_qcom(GLenum target, i32 level, vec_3_i32 const& xoffset, vec_3_i32 const& width, groups::pixel_format format, groups::pixel_type type, span_byte texels)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glExtGetTexSubImageQCOM)
                Throw(undefined_behavior(
                    "unloaded function ExtGetTexSubImageQCOM"));
    }
    glExtGetTexSubImageQCOM(target, level, xoffset.x(), xoffset.y(), xoffset.z(), width[0], width[1], width[2], static_cast<GLenum>(format), static_cast<GLenum>(type), reinterpret_cast<void *>(texels.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_i32,
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32> &&
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void ext_get_textures_qcom(span_u32 textures, i32 maxTextures, span_i32 numTextures)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glExtGetTexturesQCOM)
                Throw(undefined_behavior(
                    "unloaded function ExtGetTexturesQCOM"));
    }
    glExtGetTexturesQCOM(reinterpret_cast<GLuint *>(textures.data()), maxTextures, reinterpret_cast<GLint *>(numTextures.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void ext_tex_object_state_overridei_qcom(GLenum target, GLenum pname, i32 param)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glExtTexObjectStateOverrideiQCOM)
                Throw(undefined_behavior(
                    "unloaded function ExtTexObjectStateOverrideiQCOM"));
    }
    glExtTexObjectStateOverrideiQCOM(target, pname, param);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // qcom_extended_get
#endif // GL_QCOM_extended_get
#ifdef GL_QCOM_extended_get2
namespace qcom_extended_get2 {
template<
    class span_i32
>
requires (
    semantic::concepts::Span<span_i32> &&
    std::is_same_v<std::decay_t<typename span_i32::value_type>, i32>)
STATICINLINE void ext_get_program_binary_source_qcom(u32 program, groups::shader_type shadertype, span_i32 length)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glExtGetProgramBinarySourceQCOM)
                Throw(undefined_behavior(
                    "unloaded function ExtGetProgramBinarySourceQCOM"));
        glIsProgram(program);
    }
    glExtGetProgramBinarySourceQCOM(program, static_cast<GLenum>(shadertype), reinterpret_cast<GLint *>(length.data()));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void ext_get_programs_qcom(span_u32 programs, i32 maxPrograms, i32& numPrograms)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glExtGetProgramsQCOM)
                Throw(undefined_behavior(
                    "unloaded function ExtGetProgramsQCOM"));
    }
    glExtGetProgramsQCOM(reinterpret_cast<GLuint *>(programs.data()), maxPrograms, &numPrograms);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class span_u32
>
requires (
    semantic::concepts::Span<span_u32> &&
    std::is_same_v<std::decay_t<typename span_u32::value_type>, u32>)
STATICINLINE void ext_get_shaders_qcom(span_u32 shaders, i32 maxShaders, i32& numShaders)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glExtGetShadersQCOM)
                Throw(undefined_behavior(
                    "unloaded function ExtGetShadersQCOM"));
    }
    glExtGetShadersQCOM(reinterpret_cast<GLuint *>(shaders.data()), maxShaders, &numShaders);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE GLboolean ext_is_program_binary_qcom(u32 program)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glExtIsProgramBinaryQCOM)
                Throw(undefined_behavior(
                    "unloaded function ExtIsProgramBinaryQCOM"));
        glIsProgram(program);
    }
    auto out = glExtIsProgramBinaryQCOM(program);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
    return out;
}

} // qcom_extended_get2
#endif // GL_QCOM_extended_get2
#ifdef GL_QCOM_framebuffer_foveated
namespace qcom_framebuffer_foveated {
constexpr u32 foveation_enable_bit_qcom = 0x00000001;
constexpr u32 foveation_scaled_bin_method_bit_qcom = 0x00000002;
STATICINLINE void framebuffer_foveation_config_qcom(u32 framebuffer, u32 numLayers, u32 focalPointsPerLayer, u32 requestedFeatures, u32& providedFeatures)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferFoveationConfigQCOM)
                Throw(undefined_behavior(
                    "unloaded function FramebufferFoveationConfigQCOM"));
        glIsFramebuffer(framebuffer);
    }
    glFramebufferFoveationConfigQCOM(framebuffer, numLayers, focalPointsPerLayer, requestedFeatures, &providedFeatures);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void framebuffer_foveation_parameters_qcom(u32 framebuffer, u32 layer, u32 focalPoint, f32 focalX, f32 focalY, f32 gainX, f32 gainY, f32 foveaArea)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferFoveationParametersQCOM)
                Throw(undefined_behavior(
                    "unloaded function FramebufferFoveationParametersQCOM"));
        glIsFramebuffer(framebuffer);
    }
    glFramebufferFoveationParametersQCOM(framebuffer, layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // qcom_framebuffer_foveated
#endif // GL_QCOM_framebuffer_foveated
#ifdef GL_QCOM_motion_estimation
namespace qcom_motion_estimation {
constexpr u32 foveation_scaled_bin_method_bit_qcom = 0x00000002;
constexpr u32 motion_estimation_search_block_x_qcom = 0x8C90;
constexpr u32 motion_estimation_search_block_y_qcom = 0x8C91;
STATICINLINE void tex_estimate_motion_qcom(u32 ref, u32 target, u32 output)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexEstimateMotionQCOM)
                Throw(undefined_behavior(
                    "unloaded function TexEstimateMotionQCOM"));
    }
    glTexEstimateMotionQCOM(ref, target, output);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

STATICINLINE void tex_estimate_motion_regions_qcom(u32 ref, u32 target, u32 output, u32 mask)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTexEstimateMotionRegionsQCOM)
                Throw(undefined_behavior(
                    "unloaded function TexEstimateMotionRegionsQCOM"));
    }
    glTexEstimateMotionRegionsQCOM(ref, target, output, mask);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // qcom_motion_estimation
#endif // GL_QCOM_motion_estimation
#ifdef GL_QCOM_frame_extrapolation
namespace qcom_frame_extrapolation {
STATICINLINE void extrapolate_tex_2dqcom(u32 src1, u32 src2, u32 output, f32 scaleFactor)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glExtrapolateTex2DQCOM)
                Throw(undefined_behavior(
                    "unloaded function ExtrapolateTex2DQCOM"));
    }
    glExtrapolateTex2DQCOM(src1, src2, output, scaleFactor);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // qcom_frame_extrapolation
#endif // GL_QCOM_frame_extrapolation
#ifdef GL_QCOM_render_shared_exponent
namespace qcom_render_shared_exponent {
} // qcom_render_shared_exponent
#endif // GL_QCOM_render_shared_exponent
#ifdef GL_QCOM_texture_foveated
namespace qcom_texture_foveated {
constexpr u32 foveation_enable_bit_qcom = 0x00000001;
constexpr u32 foveation_scaled_bin_method_bit_qcom = 0x00000002;
constexpr u32 texture_foveated_feature_bits_qcom = 0x8BFB;
constexpr u32 texture_foveated_min_pixel_density_qcom = 0x8BFC;
constexpr u32 texture_foveated_feature_query_qcom = 0x8BFD;
constexpr u32 texture_foveated_num_focal_points_query_qcom = 0x8BFE;
constexpr u32 framebuffer_incomplete_foveation_qcom = 0x8BFF;
STATICINLINE void texture_foveation_parameters_qcom(u32 texture, u32 layer, u32 focalPoint, f32 focalX, f32 focalY, f32 gainX, f32 gainY, f32 foveaArea)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glTextureFoveationParametersQCOM)
                Throw(undefined_behavior(
                    "unloaded function TextureFoveationParametersQCOM"));
        glIsTexture(texture);
    }
    glTextureFoveationParametersQCOM(texture, layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea);
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // qcom_texture_foveated
#endif // GL_QCOM_texture_foveated
#ifdef GL_QCOM_texture_foveated2
namespace qcom_texture_foveated2 {
constexpr u32 texture_foveated_cutoff_density_qcom = 0x96A0;
} // qcom_texture_foveated2
#endif // GL_QCOM_texture_foveated2
#ifdef GL_QCOM_texture_foveated_subsampled_layout
namespace qcom_texture_foveated_subsampled_layout {
constexpr u32 foveation_subsampled_layout_method_bit_qcom = 0x00000004;
constexpr u32 max_shader_subsampled_image_units_qcom = 0x8FA1;
} // qcom_texture_foveated_subsampled_layout
#endif // GL_QCOM_texture_foveated_subsampled_layout
#ifdef GL_QCOM_perfmon_global_mode
namespace qcom_perfmon_global_mode {
constexpr u32 perfmon_global_mode_qcom = 0x8FA0;
} // qcom_perfmon_global_mode
#endif // GL_QCOM_perfmon_global_mode
#ifdef GL_QCOM_shader_framebuffer_fetch_noncoherent
namespace qcom_shader_framebuffer_fetch_noncoherent {
constexpr u32 framebuffer_fetch_noncoherent_qcom = 0x96A2;
STATICINLINE void framebuffer_fetch_barrier_qcom()
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glFramebufferFetchBarrierQCOM)
                Throw(undefined_behavior(
                    "unloaded function FramebufferFetchBarrierQCOM"));
    }
    glFramebufferFetchBarrierQCOM();
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // qcom_shader_framebuffer_fetch_noncoherent
#endif // GL_QCOM_shader_framebuffer_fetch_noncoherent
#ifdef GL_QCOM_shader_framebuffer_fetch_rate
namespace qcom_shader_framebuffer_fetch_rate {
} // qcom_shader_framebuffer_fetch_rate
#endif // GL_QCOM_shader_framebuffer_fetch_rate
#ifdef GL_QCOM_shading_rate
namespace qcom_shading_rate {
constexpr u32 shading_rate_qcom = 0x96A4;
constexpr u32 shading_rate_preserve_aspect_ratio_qcom = 0x96A5;
constexpr u32 shading_rate_1x1_pixels_qcom = 0x96A6;
constexpr u32 shading_rate_1x2_pixels_qcom = 0x96A7;
constexpr u32 shading_rate_2x1_pixels_qcom = 0x96A8;
constexpr u32 shading_rate_2x2_pixels_qcom = 0x96A9;
constexpr u32 shading_rate_4x2_pixels_qcom = 0x96AC;
constexpr u32 shading_rate_4x4_pixels_qcom = 0x96AE;
STATICINLINE void shading_rate_qcom(groups::shading_rate_qcom rate)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glShadingRateQCOM)
                Throw(undefined_behavior(
                    "unloaded function ShadingRateQCOM"));
    }
    glShadingRateQCOM(static_cast<GLenum>(rate));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // qcom_shading_rate
#endif // GL_QCOM_shading_rate
#ifdef GL_QCOM_tiled_rendering
namespace qcom_tiled_rendering {
constexpr u32 color_buffer_bit0_qcom = 0x00000001;
constexpr u32 color_buffer_bit1_qcom = 0x00000002;
constexpr u32 color_buffer_bit2_qcom = 0x00000004;
constexpr u32 color_buffer_bit3_qcom = 0x00000008;
constexpr u32 color_buffer_bit4_qcom = 0x00000010;
constexpr u32 color_buffer_bit5_qcom = 0x00000020;
constexpr u32 color_buffer_bit6_qcom = 0x00000040;
constexpr u32 color_buffer_bit7_qcom = 0x00000080;
constexpr u32 depth_buffer_bit0_qcom = 0x00000100;
constexpr u32 depth_buffer_bit1_qcom = 0x00000200;
constexpr u32 depth_buffer_bit2_qcom = 0x00000400;
constexpr u32 depth_buffer_bit3_qcom = 0x00000800;
constexpr u32 depth_buffer_bit4_qcom = 0x00001000;
constexpr u32 depth_buffer_bit5_qcom = 0x00002000;
constexpr u32 depth_buffer_bit6_qcom = 0x00004000;
constexpr u32 depth_buffer_bit7_qcom = 0x00008000;
constexpr u32 stencil_buffer_bit0_qcom = 0x00010000;
constexpr u32 stencil_buffer_bit1_qcom = 0x00020000;
constexpr u32 stencil_buffer_bit2_qcom = 0x00040000;
constexpr u32 stencil_buffer_bit3_qcom = 0x00080000;
constexpr u32 stencil_buffer_bit4_qcom = 0x00100000;
constexpr u32 stencil_buffer_bit5_qcom = 0x00200000;
constexpr u32 stencil_buffer_bit6_qcom = 0x00400000;
constexpr u32 stencil_buffer_bit7_qcom = 0x00800000;
constexpr u32 multisample_buffer_bit0_qcom = 0x01000000;
constexpr u32 multisample_buffer_bit1_qcom = 0x02000000;
constexpr u32 multisample_buffer_bit2_qcom = 0x04000000;
constexpr u32 multisample_buffer_bit3_qcom = 0x08000000;
constexpr u32 multisample_buffer_bit4_qcom = 0x10000000;
constexpr u32 multisample_buffer_bit5_qcom = 0x20000000;
constexpr u32 multisample_buffer_bit6_qcom = 0x40000000;
constexpr u32 multisample_buffer_bit7_qcom = 0x80000000;
STATICINLINE void end_tiling_qcom(groups::buffer_bit_qcom preserveMask)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glEndTilingQCOM)
                Throw(undefined_behavior(
                    "unloaded function EndTilingQCOM"));
    }
    glEndTilingQCOM(static_cast<GLenum>(preserveMask));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

template<
    class vec_2_u32
>
requires (
    semantic::concepts::Vector<vec_2_u32, u32, 2>)
STATICINLINE void start_tiling_qcom(vec_2_u32 const& x, vec_2_u32 const& width, groups::buffer_bit_qcom preserveMask)
{
    if constexpr(compile_info::debug_mode)
    {
        if constexpr(gl::is_linked)
            if(!glStartTilingQCOM)
                Throw(undefined_behavior(
                    "unloaded function StartTilingQCOM"));
    }
    glStartTilingQCOM(x.x(), x.y(), width[0], width[1], static_cast<GLenum>(preserveMask));
    if constexpr(compile_info::debug_mode)
    {
        if(auto error = glGetError(); error != GL_NO_ERROR)
            Throw(undefined_behavior("GL error occurred: " + std::to_string(error)));
    }
}

} // qcom_tiled_rendering
#endif // GL_QCOM_tiled_rendering
#ifdef GL_QCOM_writeonly_rendering
namespace qcom_writeonly_rendering {
constexpr u32 writeonly_rendering_qcom = 0x8823;
} // qcom_writeonly_rendering
#endif // GL_QCOM_writeonly_rendering
#ifdef GL_QCOM_YUV_texture_gather
namespace qcom_yuv_texture_gather {
} // qcom_yuv_texture_gather
#endif // GL_QCOM_YUV_texture_gather
} // gl::ext
